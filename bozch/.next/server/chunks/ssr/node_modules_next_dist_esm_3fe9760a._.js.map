{"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/esm/shared/lib/segment.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/app-router-headers.js","turbopack:///[project]/node_modules/next/dist/esm/shared/lib/segment-cache/segment-value-encoding.js","turbopack:///[project]/node_modules/next/dist/esm/client/route-params.js","turbopack:///[project]/node_modules/next/dist/src/client/components/http-access-fallback/http-access-fallback.ts","turbopack:///[project]/node_modules/next/dist/esm/client/components/is-next-router-error.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/redirect-status-code.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/redirect-error.js","turbopack:///[project]/node_modules/next/dist/src/lib/framework/boundary-constants.tsx","turbopack:///[project]/node_modules/next/dist/src/shared/lib/invariant-error.ts","turbopack:///[project]/node_modules/next/dist/esm/shared/lib/lazy-dynamic/bailout-to-csr.js","turbopack:///[project]/node_modules/next/dist/esm/server/app-render/dynamic-rendering.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/hooks-server-context.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/static-generation-bailout.js","turbopack:///[project]/node_modules/next/dist/esm/shared/lib/promise-with-resolvers.js","turbopack:///[project]/node_modules/next/dist/esm/server/dynamic-rendering-utils.js","turbopack:///[project]/node_modules/next/dist/esm/server/app-render/staged-rendering.js","turbopack:///[project]/node_modules/next/dist/esm/lib/scheduler.js","turbopack:///[project]/node_modules/next/dist/esm/server/lib/router-utils/is-postpone.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/unstable-rethrow.server.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/navigation-untracked.js","turbopack:///[project]/node_modules/next/dist/esm/shared/lib/utils/warn-once.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/http-access-fallback/error-boundary.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/layout-router.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/redirect-boundary.js","turbopack:///[project]/node_modules/next/dist/esm/client/flight-data-helpers.js","turbopack:///[project]/node_modules/next/dist/esm/client/app-build-id.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/router-reducer/set-cache-busting-search-param.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/router-reducer/fetch-server-response.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/handle-isr-error.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/error-boundary.js","turbopack:///[project]/node_modules/next/dist/esm/shared/lib/router/utils/disable-smooth-scroll.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/readonly-url-search-params.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/redirect.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/not-found.js","turbopack:///[project]/node_modules/next/dist/esm/client/app-find-source-map-url.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/router-reducer/create-href-from-url.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/match-segments.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/router-reducer/router-reducer-types.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/unrecognized-action-error.js","turbopack:///[project]/node_modules/next/dist/esm/shared/lib/router/utils/is-bot.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/forbidden.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/unauthorized.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/bfcache.js","turbopack:///[project]/node_modules/next/dist/esm/shared/lib/router/utils/cache-busting-search-param.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/navigation.react-server.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/router-reducer/create-router-cache-key.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/navigation.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/use-action-queue.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/nav-failure-handler.js","turbopack:///[project]/node_modules/next/dist/esm/shared/lib/router/utils/interception-routes.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/unresolved-thenable.js","turbopack:///[project]/node_modules/next/dist/esm/client/app-call-server.js","turbopack:///[project]/node_modules/next/dist/esm/shared/lib/page-path/ensure-leading-slash.js","turbopack:///[project]/node_modules/next/dist/esm/shared/lib/router/utils/html-bots.js","turbopack:///[project]/node_modules/next/dist/esm/shared/lib/is-thenable.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/unstable-rethrow.js","turbopack:///[project]/node_modules/next/dist/esm/shared/lib/hash.js","turbopack:///[project]/node_modules/next/dist/esm/shared/lib/router/utils/app-paths.js","turbopack:///[project]/node_modules/next/dist/src/client/components/render-from-template-context.tsx","turbopack:///[project]/node_modules/next/dist/esm/server/create-deduped-by-callsite-server-error-logger.js","turbopack:///[project]/node_modules/next/dist/esm/shared/lib/utils/reflect-utils.js","turbopack:///[project]/node_modules/next/dist/esm/server/web/spec-extension/adapters/reflect.js","turbopack:///[project]/node_modules/next/dist/esm/server/request/utils.js","turbopack:///[project]/node_modules/next/dist/esm/server/request/search-params.js","turbopack:///[project]/node_modules/next/dist/src/server/request/params.ts","turbopack:///[project]/node_modules/next/dist/src/client/components/client-page.tsx","turbopack:///[project]/node_modules/next/dist/src/client/components/client-segment.tsx","turbopack:///[project]/node_modules/next/dist/src/lib/metadata/generate/icon-mark.tsx","turbopack:///[project]/node_modules/next/dist/src/lib/framework/boundary-components.tsx"],"sourcesContent":["export function getSegmentValue(segment) {\r\n    return Array.isArray(segment) ? segment[1] : segment;\r\n}\r\nexport function isGroupSegment(segment) {\r\n    // Use array[0] for performant purpose\r\n    return segment[0] === '(' && segment.endsWith(')');\r\n}\r\nexport function isParallelRouteSegment(segment) {\r\n    return segment.startsWith('@') && segment !== '@children';\r\n}\r\nexport function addSearchParamsIfPageSegment(segment, searchParams) {\r\n    const isPageSegment = segment.includes(PAGE_SEGMENT_KEY);\r\n    if (isPageSegment) {\r\n        const stringifiedQuery = JSON.stringify(searchParams);\r\n        return stringifiedQuery !== '{}' ? PAGE_SEGMENT_KEY + '?' + stringifiedQuery : PAGE_SEGMENT_KEY;\r\n    }\r\n    return segment;\r\n}\r\nexport function computeSelectedLayoutSegment(segments, parallelRouteKey) {\r\n    if (!segments || segments.length === 0) {\r\n        return null;\r\n    }\r\n    // For 'children', use first segment; for other parallel routes, use last segment\r\n    const rawSegment = parallelRouteKey === 'children' ? segments[0] : segments[segments.length - 1];\r\n    // If the default slot is showing, return null since it's not technically \"selected\" (it's a fallback)\r\n    // Returning an internal value like `__DEFAULT__` would be confusing\r\n    return rawSegment === DEFAULT_SEGMENT_KEY ? null : rawSegment;\r\n}\r\n/** Get the canonical parameters from the current level to the leaf node. */ export function getSelectedLayoutSegmentPath(tree, parallelRouteKey, first = true, segmentPath = []) {\r\n    let node;\r\n    if (first) {\r\n        // Use the provided parallel route key on the first parallel route\r\n        node = tree[1][parallelRouteKey];\r\n    } else {\r\n        // After first parallel route prefer children, if there's no children pick the first parallel route.\r\n        const parallelRoutes = tree[1];\r\n        node = parallelRoutes.children ?? Object.values(parallelRoutes)[0];\r\n    }\r\n    if (!node) return segmentPath;\r\n    const segment = node[0];\r\n    let segmentValue = getSegmentValue(segment);\r\n    if (!segmentValue || segmentValue.startsWith(PAGE_SEGMENT_KEY)) {\r\n        return segmentPath;\r\n    }\r\n    segmentPath.push(segmentValue);\r\n    return getSelectedLayoutSegmentPath(node, parallelRouteKey, false, segmentPath);\r\n}\r\nexport const PAGE_SEGMENT_KEY = '__PAGE__';\r\nexport const DEFAULT_SEGMENT_KEY = '__DEFAULT__';\r\n\r\n//# sourceMappingURL=segment.js.map","export const RSC_HEADER = 'rsc';\r\nexport const ACTION_HEADER = 'next-action';\r\n// TODO: Instead of sending the full router state, we only need to send the\r\n// segment path. Saves bytes. Then we could also use this field for segment\r\n// prefetches, which also need to specify a particular segment.\r\nexport const NEXT_ROUTER_STATE_TREE_HEADER = 'next-router-state-tree';\r\nexport const NEXT_ROUTER_PREFETCH_HEADER = 'next-router-prefetch';\r\n// This contains the path to the segment being prefetched.\r\n// TODO: If we change next-router-state-tree to be a segment path, we can use\r\n// that instead. Then next-router-prefetch and next-router-segment-prefetch can\r\n// be merged into a single enum.\r\nexport const NEXT_ROUTER_SEGMENT_PREFETCH_HEADER = 'next-router-segment-prefetch';\r\nexport const NEXT_HMR_REFRESH_HEADER = 'next-hmr-refresh';\r\nexport const NEXT_HMR_REFRESH_HASH_COOKIE = '__next_hmr_refresh_hash__';\r\nexport const NEXT_URL = 'next-url';\r\nexport const RSC_CONTENT_TYPE_HEADER = 'text/x-component';\r\nexport const FLIGHT_HEADERS = [\r\n    RSC_HEADER,\r\n    NEXT_ROUTER_STATE_TREE_HEADER,\r\n    NEXT_ROUTER_PREFETCH_HEADER,\r\n    NEXT_HMR_REFRESH_HEADER,\r\n    NEXT_ROUTER_SEGMENT_PREFETCH_HEADER\r\n];\r\nexport const NEXT_RSC_UNION_QUERY = '_rsc';\r\nexport const NEXT_ROUTER_STALE_TIME_HEADER = 'x-nextjs-stale-time';\r\nexport const NEXT_DID_POSTPONE_HEADER = 'x-nextjs-postponed';\r\nexport const NEXT_REWRITTEN_PATH_HEADER = 'x-nextjs-rewritten-path';\r\nexport const NEXT_REWRITTEN_QUERY_HEADER = 'x-nextjs-rewritten-query';\r\nexport const NEXT_IS_PRERENDER_HEADER = 'x-nextjs-prerender';\r\nexport const NEXT_ACTION_NOT_FOUND_HEADER = 'x-nextjs-action-not-found';\r\nexport const NEXT_REQUEST_ID_HEADER = 'x-nextjs-request-id';\r\nexport const NEXT_HTML_REQUEST_ID_HEADER = 'x-nextjs-html-request-id';\r\n\r\n//# sourceMappingURL=app-router-headers.js.map","import { PAGE_SEGMENT_KEY } from '../segment';\r\nexport const ROOT_SEGMENT_REQUEST_KEY = '';\r\nexport const ROOT_SEGMENT_CACHE_KEY = '';\r\nexport function createSegmentRequestKeyPart(segment) {\r\n    if (typeof segment === 'string') {\r\n        if (segment.startsWith(PAGE_SEGMENT_KEY)) {\r\n            // The Flight Router State type sometimes includes the search params in\r\n            // the page segment. However, the Segment Cache tracks this as a separate\r\n            // key. So, we strip the search params here, and then add them back when\r\n            // the cache entry is turned back into a FlightRouterState. This is an\r\n            // unfortunate consequence of the FlightRouteState being used both as a\r\n            // transport type and as a cache key; we'll address this once more of the\r\n            // Segment Cache implementation has settled.\r\n            // TODO: We should hoist the search params out of the FlightRouterState\r\n            // type entirely, This is our plan for dynamic route params, too.\r\n            return PAGE_SEGMENT_KEY;\r\n        }\r\n        const safeName = // TODO: FlightRouterState encodes Not Found routes as \"/_not-found\".\r\n        // But params typically don't include the leading slash. We should use\r\n        // a different encoding to avoid this special case.\r\n        segment === '/_not-found' ? '_not-found' : encodeToFilesystemAndURLSafeString(segment);\r\n        // Since this is not a dynamic segment, it's fully encoded. It does not\r\n        // need to be \"hydrated\" with a param value.\r\n        return safeName;\r\n    }\r\n    const name = segment[0];\r\n    const paramType = segment[2];\r\n    const safeName = encodeToFilesystemAndURLSafeString(name);\r\n    const encodedName = '$' + paramType + '$' + safeName;\r\n    return encodedName;\r\n}\r\nexport function appendSegmentRequestKeyPart(parentRequestKey, parallelRouteKey, childRequestKeyPart) {\r\n    // Aside from being filesystem safe, segment keys are also designed so that\r\n    // each segment and parallel route creates its own subdirectory. Roughly in\r\n    // the same shape as the source app directory. This is mostly just for easier\r\n    // debugging (you can open up the build folder and navigate the output); if\r\n    // we wanted to do we could just use a flat structure.\r\n    // Omit the parallel route key for children, since this is the most\r\n    // common case. Saves some bytes (and it's what the app directory does).\r\n    const slotKey = parallelRouteKey === 'children' ? childRequestKeyPart : `@${encodeToFilesystemAndURLSafeString(parallelRouteKey)}/${childRequestKeyPart}`;\r\n    return parentRequestKey + '/' + slotKey;\r\n}\r\nexport function createSegmentCacheKeyPart(requestKeyPart, segment) {\r\n    if (typeof segment === 'string') {\r\n        return requestKeyPart;\r\n    }\r\n    const paramValue = segment[1];\r\n    const safeValue = encodeToFilesystemAndURLSafeString(paramValue);\r\n    return requestKeyPart + '$' + safeValue;\r\n}\r\nexport function appendSegmentCacheKeyPart(parentSegmentKey, parallelRouteKey, childCacheKeyPart) {\r\n    const slotKey = parallelRouteKey === 'children' ? childCacheKeyPart : `@${encodeToFilesystemAndURLSafeString(parallelRouteKey)}/${childCacheKeyPart}`;\r\n    return parentSegmentKey + '/' + slotKey;\r\n}\r\n// Define a regex pattern to match the most common characters found in a route\r\n// param. It excludes anything that might not be cross-platform filesystem\r\n// compatible, like |. It does not need to be precise because the fallback is to\r\n// just base64url-encode the whole parameter, which is fine; we just don't do it\r\n// by default for compactness, and for easier debugging.\r\nconst simpleParamValueRegex = /^[a-zA-Z0-9\\-_@]+$/;\r\nfunction encodeToFilesystemAndURLSafeString(value) {\r\n    if (simpleParamValueRegex.test(value)) {\r\n        return value;\r\n    }\r\n    // If there are any unsafe characters, base64url-encode the entire value.\r\n    // We also add a ! prefix so it doesn't collide with the simple case.\r\n    const base64url = btoa(value).replace(/\\+/g, '-') // Replace '+' with '-'\r\n    .replace(/\\//g, '_') // Replace '/' with '_'\r\n    .replace(/=+$/, '') // Remove trailing '='\r\n    ;\r\n    return '!' + base64url;\r\n}\r\nexport function convertSegmentPathToStaticExportFilename(segmentPath) {\r\n    return `__next${segmentPath.replace(/\\//g, '.')}.txt`;\r\n}\r\n\r\n//# sourceMappingURL=segment-value-encoding.js.map","import { addSearchParamsIfPageSegment, DEFAULT_SEGMENT_KEY, PAGE_SEGMENT_KEY } from '../shared/lib/segment';\r\nimport { ROOT_SEGMENT_REQUEST_KEY } from '../shared/lib/segment-cache/segment-value-encoding';\r\nimport { NEXT_REWRITTEN_PATH_HEADER, NEXT_REWRITTEN_QUERY_HEADER, NEXT_RSC_UNION_QUERY } from './components/app-router-headers';\r\nexport function getRenderedSearch(response) {\r\n    // If the server performed a rewrite, the search params used to render the\r\n    // page will be different from the params in the request URL. In this case,\r\n    // the response will include a header that gives the rewritten search query.\r\n    const rewrittenQuery = response.headers.get(NEXT_REWRITTEN_QUERY_HEADER);\r\n    if (rewrittenQuery !== null) {\r\n        return rewrittenQuery === '' ? '' : '?' + rewrittenQuery;\r\n    }\r\n    // If the header is not present, there was no rewrite, so we use the search\r\n    // query of the response URL.\r\n    return urlToUrlWithoutFlightMarker(new URL(response.url)).search;\r\n}\r\nexport function getRenderedPathname(response) {\r\n    // If the server performed a rewrite, the pathname used to render the\r\n    // page will be different from the pathname in the request URL. In this case,\r\n    // the response will include a header that gives the rewritten pathname.\r\n    const rewrittenPath = response.headers.get(NEXT_REWRITTEN_PATH_HEADER);\r\n    return rewrittenPath ?? urlToUrlWithoutFlightMarker(new URL(response.url)).pathname;\r\n}\r\nexport function parseDynamicParamFromURLPart(paramType, pathnameParts, partIndex) {\r\n    // This needs to match the behavior in get-dynamic-param.ts.\r\n    switch(paramType){\r\n        // Catchalls\r\n        case 'c':\r\n        case 'ci':\r\n            {\r\n                // Catchalls receive all the remaining URL parts. If there are no\r\n                // remaining pathname parts, return an empty array.\r\n                return partIndex < pathnameParts.length ? pathnameParts.slice(partIndex).map((s)=>encodeURIComponent(s)) : [];\r\n            }\r\n        // Optional catchalls\r\n        case 'oc':\r\n            {\r\n                // Optional catchalls receive all the remaining URL parts, unless this is\r\n                // the end of the pathname, in which case they return null.\r\n                return partIndex < pathnameParts.length ? pathnameParts.slice(partIndex).map((s)=>encodeURIComponent(s)) : null;\r\n            }\r\n        // Dynamic\r\n        case 'd':\r\n        case 'di':\r\n            {\r\n                if (partIndex >= pathnameParts.length) {\r\n                    // The route tree expected there to be more parts in the URL than there\r\n                    // actually are. This could happen if the x-nextjs-rewritten-path header\r\n                    // is incorrectly set, or potentially due to bug in Next.js. TODO:\r\n                    // Should this be a hard error? During a prefetch, we can just abort.\r\n                    // During a client navigation, we could trigger a hard refresh. But if\r\n                    // it happens during initial render, we don't really have any\r\n                    // recovery options.\r\n                    return '';\r\n                }\r\n                return encodeURIComponent(pathnameParts[partIndex]);\r\n            }\r\n        default:\r\n            paramType;\r\n            return '';\r\n    }\r\n}\r\nexport function doesStaticSegmentAppearInURL(segment) {\r\n    // This is not a parameterized segment; however, we need to determine\r\n    // whether or not this segment appears in the URL. For example, this route\r\n    // groups do not appear in the URL, so they should be skipped. Any other\r\n    // special cases must be handled here.\r\n    // TODO: Consider encoding this directly into the router tree instead of\r\n    // inferring it on the client based on the segment type. Something like\r\n    // a `doesAppearInURL` flag in FlightRouterState.\r\n    if (segment === ROOT_SEGMENT_REQUEST_KEY || // For some reason, the loader tree sometimes includes extra __PAGE__\r\n    // \"layouts\" when part of a parallel route. But it's not a leaf node.\r\n    // Otherwise, we wouldn't need this special case because pages are\r\n    // always leaf nodes.\r\n    // TODO: Investigate why the loader produces these fake page segments.\r\n    segment.startsWith(PAGE_SEGMENT_KEY) || // Route groups.\r\n    segment[0] === '(' && segment.endsWith(')') || segment === DEFAULT_SEGMENT_KEY || segment === '/_not-found') {\r\n        return false;\r\n    } else {\r\n        // All other segment types appear in the URL\r\n        return true;\r\n    }\r\n}\r\nexport function getCacheKeyForDynamicParam(paramValue, renderedSearch) {\r\n    // This needs to match the logic in get-dynamic-param.ts, until we're able to\r\n    // unify the various implementations so that these are always computed on\r\n    // the client.\r\n    if (typeof paramValue === 'string') {\r\n        // TODO: Refactor or remove this helper function to accept a string rather\r\n        // than the whole segment type. Also we can probably just append the\r\n        // search string instead of turning it into JSON.\r\n        const pageSegmentWithSearchParams = addSearchParamsIfPageSegment(paramValue, Object.fromEntries(new URLSearchParams(renderedSearch)));\r\n        return pageSegmentWithSearchParams;\r\n    } else if (paramValue === null) {\r\n        return '';\r\n    } else {\r\n        return paramValue.join('/');\r\n    }\r\n}\r\nexport function urlToUrlWithoutFlightMarker(url) {\r\n    const urlWithoutFlightParameters = new URL(url);\r\n    urlWithoutFlightParameters.searchParams.delete(NEXT_RSC_UNION_QUERY);\r\n    if (process.env.NODE_ENV === 'production') {\r\n        if (process.env.__NEXT_CONFIG_OUTPUT === 'export' && urlWithoutFlightParameters.pathname.endsWith('.txt')) {\r\n            const { pathname } = urlWithoutFlightParameters;\r\n            const length = pathname.endsWith('/index.txt') ? 10 : 4;\r\n            // Slice off `/index.txt` or `.txt` from the end of the pathname\r\n            urlWithoutFlightParameters.pathname = pathname.slice(0, -length);\r\n        }\r\n    }\r\n    return urlWithoutFlightParameters;\r\n}\r\nexport function getParamValueFromCacheKey(paramCacheKey, paramType) {\r\n    // Turn the cache key string sent by the server (as part of FlightRouterState)\r\n    // into a value that can be passed to `useParams` and client components.\r\n    const isCatchAll = paramType === 'c' || paramType === 'oc';\r\n    if (isCatchAll) {\r\n        // Catch-all param keys are a concatenation of the path segments.\r\n        // See equivalent logic in `getSelectedParams`.\r\n        // TODO: We should just pass the array directly, rather than concatenate\r\n        // it to a string and then split it back to an array. It needs to be an\r\n        // array in some places, like when passing a key React, but we can convert\r\n        // it at runtime in those places.\r\n        return paramCacheKey.split('/');\r\n    }\r\n    return paramCacheKey;\r\n}\r\nexport function urlSearchParamsToParsedUrlQuery(searchParams) {\r\n    // Converts a URLSearchParams object to the same type used by the server when\r\n    // creating search params props, i.e. the type returned by Node's\r\n    // \"querystring\" module.\r\n    const result = {};\r\n    for (const [key, value] of searchParams.entries()){\r\n        if (result[key] === undefined) {\r\n            result[key] = value;\r\n        } else if (Array.isArray(result[key])) {\r\n            result[key].push(value);\r\n        } else {\r\n            result[key] = [\r\n                result[key],\r\n                value\r\n            ];\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\n//# sourceMappingURL=route-params.js.map","export const HTTPAccessErrorStatus = {\n  NOT_FOUND: 404,\n  FORBIDDEN: 403,\n  UNAUTHORIZED: 401,\n}\n\nconst ALLOWED_CODES = new Set(Object.values(HTTPAccessErrorStatus))\n\nexport const HTTP_ERROR_FALLBACK_ERROR_CODE = 'NEXT_HTTP_ERROR_FALLBACK'\n\nexport type HTTPAccessFallbackError = Error & {\n  digest: `${typeof HTTP_ERROR_FALLBACK_ERROR_CODE};${string}`\n}\n\n/**\n * Checks an error to determine if it's an error generated by\n * the HTTP navigation APIs `notFound()`, `forbidden()` or `unauthorized()`.\n *\n * @param error the error that may reference a HTTP access error\n * @returns true if the error is a HTTP access error\n */\nexport function isHTTPAccessFallbackError(\n  error: unknown\n): error is HTTPAccessFallbackError {\n  if (\n    typeof error !== 'object' ||\n    error === null ||\n    !('digest' in error) ||\n    typeof error.digest !== 'string'\n  ) {\n    return false\n  }\n  const [prefix, httpStatus] = error.digest.split(';')\n\n  return (\n    prefix === HTTP_ERROR_FALLBACK_ERROR_CODE &&\n    ALLOWED_CODES.has(Number(httpStatus))\n  )\n}\n\nexport function getAccessFallbackHTTPStatus(\n  error: HTTPAccessFallbackError\n): number {\n  const httpStatus = error.digest.split(';')[1]\n  return Number(httpStatus)\n}\n\nexport function getAccessFallbackErrorTypeByStatus(\n  status: number\n): 'not-found' | 'forbidden' | 'unauthorized' | undefined {\n  switch (status) {\n    case 401:\n      return 'unauthorized'\n    case 403:\n      return 'forbidden'\n    case 404:\n      return 'not-found'\n    default:\n      return\n  }\n}\n","import { isHTTPAccessFallbackError } from './http-access-fallback/http-access-fallback';\r\nimport { isRedirectError } from './redirect-error';\r\n/**\r\n * Returns true if the error is a navigation signal error. These errors are\r\n * thrown by user code to perform navigation operations and interrupt the React\r\n * render.\r\n */ export function isNextRouterError(error) {\r\n    return isRedirectError(error) || isHTTPAccessFallbackError(error);\r\n}\r\n\r\n//# sourceMappingURL=is-next-router-error.js.map","export var RedirectStatusCode = /*#__PURE__*/ function(RedirectStatusCode) {\r\n    RedirectStatusCode[RedirectStatusCode[\"SeeOther\"] = 303] = \"SeeOther\";\r\n    RedirectStatusCode[RedirectStatusCode[\"TemporaryRedirect\"] = 307] = \"TemporaryRedirect\";\r\n    RedirectStatusCode[RedirectStatusCode[\"PermanentRedirect\"] = 308] = \"PermanentRedirect\";\r\n    return RedirectStatusCode;\r\n}({});\r\n\r\n//# sourceMappingURL=redirect-status-code.js.map","import { RedirectStatusCode } from './redirect-status-code';\r\nexport const REDIRECT_ERROR_CODE = 'NEXT_REDIRECT';\r\nexport var RedirectType = /*#__PURE__*/ function(RedirectType) {\r\n    RedirectType[\"push\"] = \"push\";\r\n    RedirectType[\"replace\"] = \"replace\";\r\n    return RedirectType;\r\n}({});\r\n/**\r\n * Checks an error to determine if it's an error generated by the\r\n * `redirect(url)` helper.\r\n *\r\n * @param error the error that may reference a redirect error\r\n * @returns true if the error is a redirect error\r\n */ export function isRedirectError(error) {\r\n    if (typeof error !== 'object' || error === null || !('digest' in error) || typeof error.digest !== 'string') {\r\n        return false;\r\n    }\r\n    const digest = error.digest.split(';');\r\n    const [errorCode, type] = digest;\r\n    const destination = digest.slice(2, -2).join(';');\r\n    const status = digest.at(-2);\r\n    const statusCode = Number(status);\r\n    return errorCode === REDIRECT_ERROR_CODE && (type === 'replace' || type === 'push') && typeof destination === 'string' && !isNaN(statusCode) && statusCode in RedirectStatusCode;\r\n}\r\n\r\n//# sourceMappingURL=redirect-error.js.map","export const METADATA_BOUNDARY_NAME = '__next_metadata_boundary__'\nexport const VIEWPORT_BOUNDARY_NAME = '__next_viewport_boundary__'\nexport const OUTLET_BOUNDARY_NAME = '__next_outlet_boundary__'\nexport const ROOT_LAYOUT_BOUNDARY_NAME = '__next_root_layout_boundary__'\n","export class InvariantError extends Error {\n  constructor(message: string, options?: ErrorOptions) {\n    super(\n      `Invariant: ${message.endsWith('.') ? message : message + '.'} This is a bug in Next.js.`,\n      options\n    )\n    this.name = 'InvariantError'\n  }\n}\n","// This has to be a shared module which is shared between client component error boundary and dynamic component\r\nconst BAILOUT_TO_CSR = 'BAILOUT_TO_CLIENT_SIDE_RENDERING';\r\n/** An error that should be thrown when we want to bail out to client-side rendering. */ export class BailoutToCSRError extends Error {\r\n    constructor(reason){\r\n        super(`Bail out to client-side rendering: ${reason}`), this.reason = reason, this.digest = BAILOUT_TO_CSR;\r\n    }\r\n}\r\n/** Checks if a passed argument is an error that is thrown if we want to bail out to client-side rendering. */ export function isBailoutToCSRError(err) {\r\n    if (typeof err !== 'object' || err === null || !('digest' in err)) {\r\n        return false;\r\n    }\r\n    return err.digest === BAILOUT_TO_CSR;\r\n}\r\n\r\n//# sourceMappingURL=bailout-to-csr.js.map","/**\r\n * The functions provided by this module are used to communicate certain properties\r\n * about the currently running code so that Next.js can make decisions on how to handle\r\n * the current execution in different rendering modes such as pre-rendering, resuming, and SSR.\r\n *\r\n * Today Next.js treats all code as potentially static. Certain APIs may only make sense when dynamically rendering.\r\n * Traditionally this meant deopting the entire render to dynamic however with PPR we can now deopt parts\r\n * of a React tree as dynamic while still keeping other parts static. There are really two different kinds of\r\n * Dynamic indications.\r\n *\r\n * The first is simply an intention to be dynamic. unstable_noStore is an example of this where\r\n * the currently executing code simply declares that the current scope is dynamic but if you use it\r\n * inside unstable_cache it can still be cached. This type of indication can be removed if we ever\r\n * make the default dynamic to begin with because the only way you would ever be static is inside\r\n * a cache scope which this indication does not affect.\r\n *\r\n * The second is an indication that a dynamic data source was read. This is a stronger form of dynamic\r\n * because it means that it is inappropriate to cache this at all. using a dynamic data source inside\r\n * unstable_cache should error. If you want to use some dynamic data inside unstable_cache you should\r\n * read that data outside the cache and pass it in as an argument to the cached function.\r\n */ // Once postpone is in stable we should switch to importing the postpone export directly\r\nimport React from 'react';\r\nimport { DynamicServerError } from '../../client/components/hooks-server-context';\r\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout';\r\nimport { getRuntimeStagePromise, throwForMissingRequestStore, workUnitAsyncStorage } from './work-unit-async-storage.external';\r\nimport { workAsyncStorage } from '../app-render/work-async-storage.external';\r\nimport { makeHangingPromise } from '../dynamic-rendering-utils';\r\nimport { METADATA_BOUNDARY_NAME, VIEWPORT_BOUNDARY_NAME, OUTLET_BOUNDARY_NAME, ROOT_LAYOUT_BOUNDARY_NAME } from '../../lib/framework/boundary-constants';\r\nimport { scheduleOnNextTick } from '../../lib/scheduler';\r\nimport { BailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr';\r\nimport { InvariantError } from '../../shared/lib/invariant-error';\r\nimport { RenderStage } from './staged-rendering';\r\nconst hasPostpone = typeof React.unstable_postpone === 'function';\r\nexport function createDynamicTrackingState(isDebugDynamicAccesses) {\r\n    return {\r\n        isDebugDynamicAccesses,\r\n        dynamicAccesses: [],\r\n        syncDynamicErrorWithStack: null\r\n    };\r\n}\r\nexport function createDynamicValidationState() {\r\n    return {\r\n        hasSuspenseAboveBody: false,\r\n        hasDynamicMetadata: false,\r\n        hasDynamicViewport: false,\r\n        hasAllowedDynamic: false,\r\n        dynamicErrors: []\r\n    };\r\n}\r\nexport function getFirstDynamicReason(trackingState) {\r\n    var _trackingState_dynamicAccesses_;\r\n    return (_trackingState_dynamicAccesses_ = trackingState.dynamicAccesses[0]) == null ? void 0 : _trackingState_dynamicAccesses_.expression;\r\n}\r\n/**\r\n * This function communicates that the current scope should be treated as dynamic.\r\n *\r\n * In most cases this function is a no-op but if called during\r\n * a PPR prerender it will postpone the current sub-tree and calling\r\n * it during a normal prerender will cause the entire prerender to abort\r\n */ export function markCurrentScopeAsDynamic(store, workUnitStore, expression) {\r\n    if (workUnitStore) {\r\n        switch(workUnitStore.type){\r\n            case 'cache':\r\n            case 'unstable-cache':\r\n                // Inside cache scopes, marking a scope as dynamic has no effect,\r\n                // because the outer cache scope creates a cache boundary. This is\r\n                // subtly different from reading a dynamic data source, which is\r\n                // forbidden inside a cache scope.\r\n                return;\r\n            case 'private-cache':\r\n                // A private cache scope is already dynamic by definition.\r\n                return;\r\n            case 'prerender-legacy':\r\n            case 'prerender-ppr':\r\n            case 'request':\r\n                break;\r\n            default:\r\n                workUnitStore;\r\n        }\r\n    }\r\n    // If we're forcing dynamic rendering or we're forcing static rendering, we\r\n    // don't need to do anything here because the entire page is already dynamic\r\n    // or it's static and it should not throw or postpone here.\r\n    if (store.forceDynamic || store.forceStatic) return;\r\n    if (store.dynamicShouldError) {\r\n        throw Object.defineProperty(new StaticGenBailoutError(`Route ${store.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), \"__NEXT_ERROR_CODE\", {\r\n            value: \"E553\",\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n    if (workUnitStore) {\r\n        switch(workUnitStore.type){\r\n            case 'prerender-ppr':\r\n                return postponeWithTracking(store.route, expression, workUnitStore.dynamicTracking);\r\n            case 'prerender-legacy':\r\n                workUnitStore.revalidate = 0;\r\n                // We aren't prerendering, but we are generating a static page. We need\r\n                // to bail out of static generation.\r\n                const err = Object.defineProperty(new DynamicServerError(`Route ${store.route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`), \"__NEXT_ERROR_CODE\", {\r\n                    value: \"E550\",\r\n                    enumerable: false,\r\n                    configurable: true\r\n                });\r\n                store.dynamicUsageDescription = expression;\r\n                store.dynamicUsageStack = err.stack;\r\n                throw err;\r\n            case 'request':\r\n                if (process.env.NODE_ENV !== 'production') {\r\n                    workUnitStore.usedDynamic = true;\r\n                }\r\n                break;\r\n            default:\r\n                workUnitStore;\r\n        }\r\n    }\r\n}\r\n/**\r\n * This function is meant to be used when prerendering without cacheComponents or PPR.\r\n * When called during a build it will cause Next.js to consider the route as dynamic.\r\n *\r\n * @internal\r\n */ export function throwToInterruptStaticGeneration(expression, store, prerenderStore) {\r\n    // We aren't prerendering but we are generating a static page. We need to bail out of static generation\r\n    const err = Object.defineProperty(new DynamicServerError(`Route ${store.route} couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`), \"__NEXT_ERROR_CODE\", {\r\n        value: \"E558\",\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    prerenderStore.revalidate = 0;\r\n    store.dynamicUsageDescription = expression;\r\n    store.dynamicUsageStack = err.stack;\r\n    throw err;\r\n}\r\n/**\r\n * This function should be used to track whether something dynamic happened even when\r\n * we are in a dynamic render. This is useful for Dev where all renders are dynamic but\r\n * we still track whether dynamic APIs were accessed for helpful messaging\r\n *\r\n * @internal\r\n */ export function trackDynamicDataInDynamicRender(workUnitStore) {\r\n    switch(workUnitStore.type){\r\n        case 'cache':\r\n        case 'unstable-cache':\r\n            // Inside cache scopes, marking a scope as dynamic has no effect,\r\n            // because the outer cache scope creates a cache boundary. This is\r\n            // subtly different from reading a dynamic data source, which is\r\n            // forbidden inside a cache scope.\r\n            return;\r\n        case 'private-cache':\r\n            // A private cache scope is already dynamic by definition.\r\n            return;\r\n        case 'prerender':\r\n        case 'prerender-runtime':\r\n        case 'prerender-legacy':\r\n        case 'prerender-ppr':\r\n        case 'prerender-client':\r\n            break;\r\n        case 'request':\r\n            if (process.env.NODE_ENV !== 'production') {\r\n                workUnitStore.usedDynamic = true;\r\n            }\r\n            break;\r\n        default:\r\n            workUnitStore;\r\n    }\r\n}\r\nfunction abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore) {\r\n    const reason = `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`;\r\n    const error = createPrerenderInterruptedError(reason);\r\n    prerenderStore.controller.abort(error);\r\n    const dynamicTracking = prerenderStore.dynamicTracking;\r\n    if (dynamicTracking) {\r\n        dynamicTracking.dynamicAccesses.push({\r\n            // When we aren't debugging, we don't need to create another error for the\r\n            // stack trace.\r\n            stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,\r\n            expression\r\n        });\r\n    }\r\n}\r\nexport function abortOnSynchronousPlatformIOAccess(route, expression, errorWithStack, prerenderStore) {\r\n    const dynamicTracking = prerenderStore.dynamicTracking;\r\n    abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore);\r\n    // It is important that we set this tracking value after aborting. Aborts are executed\r\n    // synchronously except for the case where you abort during render itself. By setting this\r\n    // value late we can use it to determine if any of the aborted tasks are the task that\r\n    // called the sync IO expression in the first place.\r\n    if (dynamicTracking) {\r\n        if (dynamicTracking.syncDynamicErrorWithStack === null) {\r\n            dynamicTracking.syncDynamicErrorWithStack = errorWithStack;\r\n        }\r\n    }\r\n}\r\nexport function trackSynchronousPlatformIOAccessInDev(requestStore) {\r\n    // We don't actually have a controller to abort but we do the semantic equivalent by\r\n    // advancing the request store out of the prerender stage\r\n    if (requestStore.stagedRendering) {\r\n        // TODO: error for sync IO in the runtime stage\r\n        // (which is not currently covered by the validation render in `spawnDynamicValidationInDev`)\r\n        requestStore.stagedRendering.advanceStage(RenderStage.Dynamic);\r\n    }\r\n}\r\n/**\r\n * use this function when prerendering with cacheComponents. If we are doing a\r\n * prospective prerender we don't actually abort because we want to discover\r\n * all caches for the shell. If this is the actual prerender we do abort.\r\n *\r\n * This function accepts a prerenderStore but the caller should ensure we're\r\n * actually running in cacheComponents mode.\r\n *\r\n * @internal\r\n */ export function abortAndThrowOnSynchronousRequestDataAccess(route, expression, errorWithStack, prerenderStore) {\r\n    const prerenderSignal = prerenderStore.controller.signal;\r\n    if (prerenderSignal.aborted === false) {\r\n        // TODO it would be better to move this aborted check into the callsite so we can avoid making\r\n        // the error object when it isn't relevant to the aborting of the prerender however\r\n        // since we need the throw semantics regardless of whether we abort it is easier to land\r\n        // this way. See how this was handled with `abortOnSynchronousPlatformIOAccess` for a closer\r\n        // to ideal implementation\r\n        abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore);\r\n        // It is important that we set this tracking value after aborting. Aborts are executed\r\n        // synchronously except for the case where you abort during render itself. By setting this\r\n        // value late we can use it to determine if any of the aborted tasks are the task that\r\n        // called the sync IO expression in the first place.\r\n        const dynamicTracking = prerenderStore.dynamicTracking;\r\n        if (dynamicTracking) {\r\n            if (dynamicTracking.syncDynamicErrorWithStack === null) {\r\n                dynamicTracking.syncDynamicErrorWithStack = errorWithStack;\r\n            }\r\n        }\r\n    }\r\n    throw createPrerenderInterruptedError(`Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`);\r\n}\r\nexport function Postpone({ reason, route }) {\r\n    const prerenderStore = workUnitAsyncStorage.getStore();\r\n    const dynamicTracking = prerenderStore && prerenderStore.type === 'prerender-ppr' ? prerenderStore.dynamicTracking : null;\r\n    postponeWithTracking(route, reason, dynamicTracking);\r\n}\r\nexport function postponeWithTracking(route, expression, dynamicTracking) {\r\n    assertPostpone();\r\n    if (dynamicTracking) {\r\n        dynamicTracking.dynamicAccesses.push({\r\n            // When we aren't debugging, we don't need to create another error for the\r\n            // stack trace.\r\n            stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,\r\n            expression\r\n        });\r\n    }\r\n    React.unstable_postpone(createPostponeReason(route, expression));\r\n}\r\nfunction createPostponeReason(route, expression) {\r\n    return `Route ${route} needs to bail out of prerendering at this point because it used ${expression}. ` + `React throws this special object to indicate where. It should not be caught by ` + `your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`;\r\n}\r\nexport function isDynamicPostpone(err) {\r\n    if (typeof err === 'object' && err !== null && typeof err.message === 'string') {\r\n        return isDynamicPostponeReason(err.message);\r\n    }\r\n    return false;\r\n}\r\nfunction isDynamicPostponeReason(reason) {\r\n    return reason.includes('needs to bail out of prerendering at this point because it used') && reason.includes('Learn more: https://nextjs.org/docs/messages/ppr-caught-error');\r\n}\r\nif (isDynamicPostponeReason(createPostponeReason('%%%', '^^^')) === false) {\r\n    throw Object.defineProperty(new Error('Invariant: isDynamicPostpone misidentified a postpone reason. This is a bug in Next.js'), \"__NEXT_ERROR_CODE\", {\r\n        value: \"E296\",\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n}\r\nconst NEXT_PRERENDER_INTERRUPTED = 'NEXT_PRERENDER_INTERRUPTED';\r\nfunction createPrerenderInterruptedError(message) {\r\n    const error = Object.defineProperty(new Error(message), \"__NEXT_ERROR_CODE\", {\r\n        value: \"E394\",\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    error.digest = NEXT_PRERENDER_INTERRUPTED;\r\n    return error;\r\n}\r\nexport function isPrerenderInterruptedError(error) {\r\n    return typeof error === 'object' && error !== null && error.digest === NEXT_PRERENDER_INTERRUPTED && 'name' in error && 'message' in error && error instanceof Error;\r\n}\r\nexport function accessedDynamicData(dynamicAccesses) {\r\n    return dynamicAccesses.length > 0;\r\n}\r\nexport function consumeDynamicAccess(serverDynamic, clientDynamic) {\r\n    // We mutate because we only call this once we are no longer writing\r\n    // to the dynamicTrackingState and it's more efficient than creating a new\r\n    // array.\r\n    serverDynamic.dynamicAccesses.push(...clientDynamic.dynamicAccesses);\r\n    return serverDynamic.dynamicAccesses;\r\n}\r\nexport function formatDynamicAPIAccesses(dynamicAccesses) {\r\n    return dynamicAccesses.filter((access)=>typeof access.stack === 'string' && access.stack.length > 0).map(({ expression, stack })=>{\r\n        stack = stack.split('\\n')// Remove the \"Error: \" prefix from the first line of the stack trace as\r\n        // well as the first 4 lines of the stack trace which is the distance\r\n        // from the user code and the `new Error().stack` call.\r\n        .slice(4).filter((line)=>{\r\n            // Exclude Next.js internals from the stack trace.\r\n            if (line.includes('node_modules/next/')) {\r\n                return false;\r\n            }\r\n            // Exclude anonymous functions from the stack trace.\r\n            if (line.includes(' (<anonymous>)')) {\r\n                return false;\r\n            }\r\n            // Exclude Node.js internals from the stack trace.\r\n            if (line.includes(' (node:')) {\r\n                return false;\r\n            }\r\n            return true;\r\n        }).join('\\n');\r\n        return `Dynamic API Usage Debug - ${expression}:\\n${stack}`;\r\n    });\r\n}\r\nfunction assertPostpone() {\r\n    if (!hasPostpone) {\r\n        throw Object.defineProperty(new Error(`Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js`), \"__NEXT_ERROR_CODE\", {\r\n            value: \"E224\",\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n}\r\n/**\r\n * This is a bit of a hack to allow us to abort a render using a Postpone instance instead of an Error which changes React's\r\n * abort semantics slightly.\r\n */ export function createRenderInBrowserAbortSignal() {\r\n    const controller = new AbortController();\r\n    controller.abort(Object.defineProperty(new BailoutToCSRError('Render in Browser'), \"__NEXT_ERROR_CODE\", {\r\n        value: \"E721\",\r\n        enumerable: false,\r\n        configurable: true\r\n    }));\r\n    return controller.signal;\r\n}\r\n/**\r\n * In a prerender, we may end up with hanging Promises as inputs due them\r\n * stalling on connection() or because they're loading dynamic data. In that\r\n * case we need to abort the encoding of arguments since they'll never complete.\r\n */ export function createHangingInputAbortSignal(workUnitStore) {\r\n    switch(workUnitStore.type){\r\n        case 'prerender':\r\n        case 'prerender-runtime':\r\n            const controller = new AbortController();\r\n            if (workUnitStore.cacheSignal) {\r\n                // If we have a cacheSignal it means we're in a prospective render. If\r\n                // the input we're waiting on is coming from another cache, we do want\r\n                // to wait for it so that we can resolve this cache entry too.\r\n                workUnitStore.cacheSignal.inputReady().then(()=>{\r\n                    controller.abort();\r\n                });\r\n            } else {\r\n                // Otherwise we're in the final render and we should already have all\r\n                // our caches filled.\r\n                // If the prerender uses stages, we have wait until the runtime stage,\r\n                // at which point all runtime inputs will be resolved.\r\n                // (otherwise, a runtime prerender might consider `cookies()` hanging\r\n                //  even though they'd resolve in the next task.)\r\n                //\r\n                // We might still be waiting on some microtasks so we\r\n                // wait one tick before giving up. When we give up, we still want to\r\n                // render the content of this cache as deeply as we can so that we can\r\n                // suspend as deeply as possible in the tree or not at all if we don't\r\n                // end up waiting for the input.\r\n                const runtimeStagePromise = getRuntimeStagePromise(workUnitStore);\r\n                if (runtimeStagePromise) {\r\n                    runtimeStagePromise.then(()=>scheduleOnNextTick(()=>controller.abort()));\r\n                } else {\r\n                    scheduleOnNextTick(()=>controller.abort());\r\n                }\r\n            }\r\n            return controller.signal;\r\n        case 'prerender-client':\r\n        case 'prerender-ppr':\r\n        case 'prerender-legacy':\r\n        case 'request':\r\n        case 'cache':\r\n        case 'private-cache':\r\n        case 'unstable-cache':\r\n            return undefined;\r\n        default:\r\n            workUnitStore;\r\n    }\r\n}\r\nexport function annotateDynamicAccess(expression, prerenderStore) {\r\n    const dynamicTracking = prerenderStore.dynamicTracking;\r\n    if (dynamicTracking) {\r\n        dynamicTracking.dynamicAccesses.push({\r\n            stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,\r\n            expression\r\n        });\r\n    }\r\n}\r\nexport function useDynamicRouteParams(expression) {\r\n    const workStore = workAsyncStorage.getStore();\r\n    const workUnitStore = workUnitAsyncStorage.getStore();\r\n    if (workStore && workUnitStore) {\r\n        switch(workUnitStore.type){\r\n            case 'prerender-client':\r\n            case 'prerender':\r\n                {\r\n                    const fallbackParams = workUnitStore.fallbackRouteParams;\r\n                    if (fallbackParams && fallbackParams.size > 0) {\r\n                        // We are in a prerender with cacheComponents semantics. We are going to\r\n                        // hang here and never resolve. This will cause the currently\r\n                        // rendering component to effectively be a dynamic hole.\r\n                        React.use(makeHangingPromise(workUnitStore.renderSignal, workStore.route, expression));\r\n                    }\r\n                    break;\r\n                }\r\n            case 'prerender-ppr':\r\n                {\r\n                    const fallbackParams = workUnitStore.fallbackRouteParams;\r\n                    if (fallbackParams && fallbackParams.size > 0) {\r\n                        return postponeWithTracking(workStore.route, expression, workUnitStore.dynamicTracking);\r\n                    }\r\n                    break;\r\n                }\r\n            case 'prerender-runtime':\r\n                throw Object.defineProperty(new InvariantError(`\\`${expression}\\` was called during a runtime prerender. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`), \"__NEXT_ERROR_CODE\", {\r\n                    value: \"E771\",\r\n                    enumerable: false,\r\n                    configurable: true\r\n                });\r\n            case 'cache':\r\n            case 'private-cache':\r\n                throw Object.defineProperty(new InvariantError(`\\`${expression}\\` was called inside a cache scope. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`), \"__NEXT_ERROR_CODE\", {\r\n                    value: \"E745\",\r\n                    enumerable: false,\r\n                    configurable: true\r\n                });\r\n            case 'prerender-legacy':\r\n            case 'request':\r\n            case 'unstable-cache':\r\n                break;\r\n            default:\r\n                workUnitStore;\r\n        }\r\n    }\r\n}\r\nexport function useDynamicSearchParams(expression) {\r\n    const workStore = workAsyncStorage.getStore();\r\n    const workUnitStore = workUnitAsyncStorage.getStore();\r\n    if (!workStore) {\r\n        // We assume pages router context and just return\r\n        return;\r\n    }\r\n    if (!workUnitStore) {\r\n        throwForMissingRequestStore(expression);\r\n    }\r\n    switch(workUnitStore.type){\r\n        case 'prerender-client':\r\n            {\r\n                React.use(makeHangingPromise(workUnitStore.renderSignal, workStore.route, expression));\r\n                break;\r\n            }\r\n        case 'prerender-legacy':\r\n        case 'prerender-ppr':\r\n            {\r\n                if (workStore.forceStatic) {\r\n                    return;\r\n                }\r\n                throw Object.defineProperty(new BailoutToCSRError(expression), \"__NEXT_ERROR_CODE\", {\r\n                    value: \"E394\",\r\n                    enumerable: false,\r\n                    configurable: true\r\n                });\r\n            }\r\n        case 'prerender':\r\n        case 'prerender-runtime':\r\n            throw Object.defineProperty(new InvariantError(`\\`${expression}\\` was called from a Server Component. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`), \"__NEXT_ERROR_CODE\", {\r\n                value: \"E795\",\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n        case 'cache':\r\n        case 'unstable-cache':\r\n        case 'private-cache':\r\n            throw Object.defineProperty(new InvariantError(`\\`${expression}\\` was called inside a cache scope. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`), \"__NEXT_ERROR_CODE\", {\r\n                value: \"E745\",\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n        case 'request':\r\n            return;\r\n        default:\r\n            workUnitStore;\r\n    }\r\n}\r\nconst hasSuspenseRegex = /\\n\\s+at Suspense \\(<anonymous>\\)/;\r\n// Common implicit body tags that React will treat as body when placed directly in html\r\nconst bodyAndImplicitTags = 'body|div|main|section|article|aside|header|footer|nav|form|p|span|h1|h2|h3|h4|h5|h6';\r\n// Detects when RootLayoutBoundary (our framework marker component) appears\r\n// after Suspense in the component stack, indicating the root layout is wrapped\r\n// within a Suspense boundary. Ensures no body/html/implicit-body components are in between.\r\n//\r\n// Example matches:\r\n//   at Suspense (<anonymous>)\r\n//   at __next_root_layout_boundary__ (<anonymous>)\r\n//\r\n// Or with other components in between (but not body/html/implicit-body):\r\n//   at Suspense (<anonymous>)\r\n//   at SomeComponent (<anonymous>)\r\n//   at __next_root_layout_boundary__ (<anonymous>)\r\nconst hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex = new RegExp(`\\\\n\\\\s+at Suspense \\\\(<anonymous>\\\\)(?:(?!\\\\n\\\\s+at (?:${bodyAndImplicitTags}) \\\\(<anonymous>\\\\))[\\\\s\\\\S])*?\\\\n\\\\s+at ${ROOT_LAYOUT_BOUNDARY_NAME} \\\\([^\\\\n]*\\\\)`);\r\nconst hasMetadataRegex = new RegExp(`\\\\n\\\\s+at ${METADATA_BOUNDARY_NAME}[\\\\n\\\\s]`);\r\nconst hasViewportRegex = new RegExp(`\\\\n\\\\s+at ${VIEWPORT_BOUNDARY_NAME}[\\\\n\\\\s]`);\r\nconst hasOutletRegex = new RegExp(`\\\\n\\\\s+at ${OUTLET_BOUNDARY_NAME}[\\\\n\\\\s]`);\r\nexport function trackAllowedDynamicAccess(workStore, componentStack, dynamicValidation, clientDynamic) {\r\n    if (hasOutletRegex.test(componentStack)) {\r\n        // We don't need to track that this is dynamic. It is only so when something else is also dynamic.\r\n        return;\r\n    } else if (hasMetadataRegex.test(componentStack)) {\r\n        dynamicValidation.hasDynamicMetadata = true;\r\n        return;\r\n    } else if (hasViewportRegex.test(componentStack)) {\r\n        dynamicValidation.hasDynamicViewport = true;\r\n        return;\r\n    } else if (hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex.test(componentStack)) {\r\n        // For Suspense within body, the prelude wouldn't be empty so it wouldn't violate the empty static shells rule.\r\n        // But if you have Suspense above body, the prelude is empty but we allow that because having Suspense\r\n        // is an explicit signal from the user that they acknowledge the empty shell and want dynamic rendering.\r\n        dynamicValidation.hasAllowedDynamic = true;\r\n        dynamicValidation.hasSuspenseAboveBody = true;\r\n        return;\r\n    } else if (hasSuspenseRegex.test(componentStack)) {\r\n        // this error had a Suspense boundary above it so we don't need to report it as a source\r\n        // of disallowed\r\n        dynamicValidation.hasAllowedDynamic = true;\r\n        return;\r\n    } else if (clientDynamic.syncDynamicErrorWithStack) {\r\n        // This task was the task that called the sync error.\r\n        dynamicValidation.dynamicErrors.push(clientDynamic.syncDynamicErrorWithStack);\r\n        return;\r\n    } else {\r\n        const message = `Route \"${workStore.route}\": Uncached data was accessed outside of ` + '<Suspense>. This delays the entire page from rendering, resulting in a ' + 'slow user experience. Learn more: ' + 'https://nextjs.org/docs/messages/blocking-route';\r\n        const error = createErrorWithComponentOrOwnerStack(message, componentStack);\r\n        dynamicValidation.dynamicErrors.push(error);\r\n        return;\r\n    }\r\n}\r\n/**\r\n * In dev mode, we prefer using the owner stack, otherwise the provided\r\n * component stack is used.\r\n */ function createErrorWithComponentOrOwnerStack(message, componentStack) {\r\n    const ownerStack = process.env.NODE_ENV !== 'production' && React.captureOwnerStack ? React.captureOwnerStack() : null;\r\n    const error = Object.defineProperty(new Error(message), \"__NEXT_ERROR_CODE\", {\r\n        value: \"E394\",\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    error.stack = error.name + ': ' + message + (ownerStack ?? componentStack);\r\n    return error;\r\n}\r\nexport var PreludeState = /*#__PURE__*/ function(PreludeState) {\r\n    PreludeState[PreludeState[\"Full\"] = 0] = \"Full\";\r\n    PreludeState[PreludeState[\"Empty\"] = 1] = \"Empty\";\r\n    PreludeState[PreludeState[\"Errored\"] = 2] = \"Errored\";\r\n    return PreludeState;\r\n}({});\r\nexport function logDisallowedDynamicError(workStore, error) {\r\n    console.error(error);\r\n    if (!workStore.dev) {\r\n        if (workStore.hasReadableErrorStacks) {\r\n            console.error(`To get a more detailed stack trace and pinpoint the issue, start the app in development mode by running \\`next dev\\`, then open \"${workStore.route}\" in your browser to investigate the error.`);\r\n        } else {\r\n            console.error(`To get a more detailed stack trace and pinpoint the issue, try one of the following:\r\n  - Start the app in development mode by running \\`next dev\\`, then open \"${workStore.route}\" in your browser to investigate the error.\r\n  - Rerun the production build with \\`next build --debug-prerender\\` to generate better stack traces.`);\r\n        }\r\n    }\r\n}\r\nexport function throwIfDisallowedDynamic(workStore, prelude, dynamicValidation, serverDynamic) {\r\n    if (serverDynamic.syncDynamicErrorWithStack) {\r\n        logDisallowedDynamicError(workStore, serverDynamic.syncDynamicErrorWithStack);\r\n        throw new StaticGenBailoutError();\r\n    }\r\n    if (prelude !== 0) {\r\n        if (dynamicValidation.hasSuspenseAboveBody) {\r\n            // This route has opted into allowing fully dynamic rendering\r\n            // by including a Suspense boundary above the body. In this case\r\n            // a lack of a shell is not considered disallowed so we simply return\r\n            return;\r\n        }\r\n        // We didn't have any sync bailouts but there may be user code which\r\n        // blocked the root. We would have captured these during the prerender\r\n        // and can log them here and then terminate the build/validating render\r\n        const dynamicErrors = dynamicValidation.dynamicErrors;\r\n        if (dynamicErrors.length > 0) {\r\n            for(let i = 0; i < dynamicErrors.length; i++){\r\n                logDisallowedDynamicError(workStore, dynamicErrors[i]);\r\n            }\r\n            throw new StaticGenBailoutError();\r\n        }\r\n        // If we got this far then the only other thing that could be blocking\r\n        // the root is dynamic Viewport. If this is dynamic then\r\n        // you need to opt into that by adding a Suspense boundary above the body\r\n        // to indicate your are ok with fully dynamic rendering.\r\n        if (dynamicValidation.hasDynamicViewport) {\r\n            console.error(`Route \"${workStore.route}\" has a \\`generateViewport\\` that depends on Request data (\\`cookies()\\`, etc...) or uncached external data (\\`fetch(...)\\`, etc...) without explicitly allowing fully dynamic rendering. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport`);\r\n            throw new StaticGenBailoutError();\r\n        }\r\n        if (prelude === 1) {\r\n            // If we ever get this far then we messed up the tracking of invalid dynamic.\r\n            // We still adhere to the constraint that you must produce a shell but invite the\r\n            // user to report this as a bug in Next.js.\r\n            console.error(`Route \"${workStore.route}\" did not produce a static shell and Next.js was unable to determine a reason. This is a bug in Next.js.`);\r\n            throw new StaticGenBailoutError();\r\n        }\r\n    } else {\r\n        if (dynamicValidation.hasAllowedDynamic === false && dynamicValidation.hasDynamicMetadata) {\r\n            console.error(`Route \"${workStore.route}\" has a \\`generateMetadata\\` that depends on Request data (\\`cookies()\\`, etc...) or uncached external data (\\`fetch(...)\\`, etc...) when the rest of the route does not. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-metadata`);\r\n            throw new StaticGenBailoutError();\r\n        }\r\n    }\r\n}\r\nexport function delayUntilRuntimeStage(prerenderStore, result) {\r\n    if (prerenderStore.runtimeStagePromise) {\r\n        return prerenderStore.runtimeStagePromise.then(()=>result);\r\n    }\r\n    return result;\r\n}\r\n\r\n//# sourceMappingURL=dynamic-rendering.js.map","const DYNAMIC_ERROR_CODE = 'DYNAMIC_SERVER_USAGE';\r\nexport class DynamicServerError extends Error {\r\n    constructor(description){\r\n        super(`Dynamic server usage: ${description}`), this.description = description, this.digest = DYNAMIC_ERROR_CODE;\r\n    }\r\n}\r\nexport function isDynamicServerError(err) {\r\n    if (typeof err !== 'object' || err === null || !('digest' in err) || typeof err.digest !== 'string') {\r\n        return false;\r\n    }\r\n    return err.digest === DYNAMIC_ERROR_CODE;\r\n}\r\n\r\n//# sourceMappingURL=hooks-server-context.js.map","const NEXT_STATIC_GEN_BAILOUT = 'NEXT_STATIC_GEN_BAILOUT';\r\nexport class StaticGenBailoutError extends Error {\r\n    constructor(...args){\r\n        super(...args), this.code = NEXT_STATIC_GEN_BAILOUT;\r\n    }\r\n}\r\nexport function isStaticGenBailoutError(error) {\r\n    if (typeof error !== 'object' || error === null || !('code' in error)) {\r\n        return false;\r\n    }\r\n    return error.code === NEXT_STATIC_GEN_BAILOUT;\r\n}\r\n\r\n//# sourceMappingURL=static-generation-bailout.js.map","export function createPromiseWithResolvers() {\r\n    // Shim of Stage 4 Promise.withResolvers proposal\r\n    let resolve;\r\n    let reject;\r\n    const promise = new Promise((res, rej)=>{\r\n        resolve = res;\r\n        reject = rej;\r\n    });\r\n    return {\r\n        resolve: resolve,\r\n        reject: reject,\r\n        promise\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=promise-with-resolvers.js.map","export function isHangingPromiseRejectionError(err) {\r\n    if (typeof err !== 'object' || err === null || !('digest' in err)) {\r\n        return false;\r\n    }\r\n    return err.digest === HANGING_PROMISE_REJECTION;\r\n}\r\nconst HANGING_PROMISE_REJECTION = 'HANGING_PROMISE_REJECTION';\r\nclass HangingPromiseRejectionError extends Error {\r\n    constructor(route, expression){\r\n        super(`During prerendering, ${expression} rejects when the prerender is complete. Typically these errors are handled by React but if you move ${expression} to a different context by using \\`setTimeout\\`, \\`after\\`, or similar functions you may observe this error and you should handle it in that context. This occurred at route \"${route}\".`), this.route = route, this.expression = expression, this.digest = HANGING_PROMISE_REJECTION;\r\n    }\r\n}\r\nconst abortListenersBySignal = new WeakMap();\r\n/**\r\n * This function constructs a promise that will never resolve. This is primarily\r\n * useful for cacheComponents where we use promise resolution timing to determine which\r\n * parts of a render can be included in a prerender.\r\n *\r\n * @internal\r\n */ export function makeHangingPromise(signal, route, expression) {\r\n    if (signal.aborted) {\r\n        return Promise.reject(new HangingPromiseRejectionError(route, expression));\r\n    } else {\r\n        const hangingPromise = new Promise((_, reject)=>{\r\n            const boundRejection = reject.bind(null, new HangingPromiseRejectionError(route, expression));\r\n            let currentListeners = abortListenersBySignal.get(signal);\r\n            if (currentListeners) {\r\n                currentListeners.push(boundRejection);\r\n            } else {\r\n                const listeners = [\r\n                    boundRejection\r\n                ];\r\n                abortListenersBySignal.set(signal, listeners);\r\n                signal.addEventListener('abort', ()=>{\r\n                    for(let i = 0; i < listeners.length; i++){\r\n                        listeners[i]();\r\n                    }\r\n                }, {\r\n                    once: true\r\n                });\r\n            }\r\n        });\r\n        // We are fine if no one actually awaits this promise. We shouldn't consider this an unhandled rejection so\r\n        // we attach a noop catch handler here to suppress this warning. If you actually await somewhere or construct\r\n        // your own promise out of it you'll need to ensure you handle the error when it rejects.\r\n        hangingPromise.catch(ignoreReject);\r\n        return hangingPromise;\r\n    }\r\n}\r\nfunction ignoreReject() {}\r\nexport function makeDevtoolsIOAwarePromise(underlying, requestStore, stage) {\r\n    if (requestStore.stagedRendering) {\r\n        // We resolve each stage in a timeout, so React DevTools will pick this up as IO.\r\n        return requestStore.stagedRendering.delayUntilStage(stage, undefined, underlying);\r\n    }\r\n    // in React DevTools if we resolve in a setTimeout we will observe\r\n    // the promise resolution as something that can suspend a boundary or root.\r\n    return new Promise((resolve)=>{\r\n        // Must use setTimeout to be considered IO React DevTools. setImmediate will not work.\r\n        setTimeout(()=>{\r\n            resolve(underlying);\r\n        }, 0);\r\n    });\r\n}\r\n\r\n//# sourceMappingURL=dynamic-rendering-utils.js.map","import { InvariantError } from '../../shared/lib/invariant-error';\r\nimport { createPromiseWithResolvers } from '../../shared/lib/promise-with-resolvers';\r\nexport var RenderStage = /*#__PURE__*/ function(RenderStage) {\r\n    RenderStage[RenderStage[\"Static\"] = 1] = \"Static\";\r\n    RenderStage[RenderStage[\"Runtime\"] = 2] = \"Runtime\";\r\n    RenderStage[RenderStage[\"Dynamic\"] = 3] = \"Dynamic\";\r\n    return RenderStage;\r\n}({});\r\nexport class StagedRenderingController {\r\n    constructor(abortSignal = null){\r\n        this.abortSignal = abortSignal;\r\n        this.currentStage = 1;\r\n        this.runtimeStagePromise = createPromiseWithResolvers();\r\n        this.dynamicStagePromise = createPromiseWithResolvers();\r\n        if (abortSignal) {\r\n            abortSignal.addEventListener('abort', ()=>{\r\n                const { reason } = abortSignal;\r\n                if (this.currentStage < 2) {\r\n                    this.runtimeStagePromise.promise.catch(ignoreReject) // avoid unhandled rejections\r\n                    ;\r\n                    this.runtimeStagePromise.reject(reason);\r\n                }\r\n                if (this.currentStage < 3) {\r\n                    this.dynamicStagePromise.promise.catch(ignoreReject) // avoid unhandled rejections\r\n                    ;\r\n                    this.dynamicStagePromise.reject(reason);\r\n                }\r\n            }, {\r\n                once: true\r\n            });\r\n        }\r\n    }\r\n    advanceStage(stage) {\r\n        // If we're already at the target stage or beyond, do nothing.\r\n        // (this can happen e.g. if sync IO advanced us to the dynamic stage)\r\n        if (this.currentStage >= stage) {\r\n            return;\r\n        }\r\n        this.currentStage = stage;\r\n        // Note that we might be going directly from Static to Dynamic,\r\n        // so we need to resolve the runtime stage as well.\r\n        if (stage >= 2) {\r\n            this.runtimeStagePromise.resolve();\r\n        }\r\n        if (stage >= 3) {\r\n            this.dynamicStagePromise.resolve();\r\n        }\r\n    }\r\n    getStagePromise(stage) {\r\n        switch(stage){\r\n            case 2:\r\n                {\r\n                    return this.runtimeStagePromise.promise;\r\n                }\r\n            case 3:\r\n                {\r\n                    return this.dynamicStagePromise.promise;\r\n                }\r\n            default:\r\n                {\r\n                    stage;\r\n                    throw Object.defineProperty(new InvariantError(`Invalid render stage: ${stage}`), \"__NEXT_ERROR_CODE\", {\r\n                        value: \"E881\",\r\n                        enumerable: false,\r\n                        configurable: true\r\n                    });\r\n                }\r\n        }\r\n    }\r\n    waitForStage(stage) {\r\n        return this.getStagePromise(stage);\r\n    }\r\n    delayUntilStage(stage, displayName, resolvedValue) {\r\n        const ioTriggerPromise = this.getStagePromise(stage);\r\n        const promise = makeDevtoolsIOPromiseFromIOTrigger(ioTriggerPromise, displayName, resolvedValue);\r\n        // Analogously to `makeHangingPromise`, we might reject this promise if the signal is invoked.\r\n        // (e.g. in the case where we don't want want the render to proceed to the dynamic stage and abort it).\r\n        // We shouldn't consider this an unhandled rejection, so we attach a noop catch handler here to suppress this warning.\r\n        if (this.abortSignal) {\r\n            promise.catch(ignoreReject);\r\n        }\r\n        return promise;\r\n    }\r\n}\r\nfunction ignoreReject() {}\r\n// TODO(restart-on-cache-miss): the layering of `delayUntilStage`,\r\n// `makeDevtoolsIOPromiseFromIOTrigger` and and `makeDevtoolsIOAwarePromise`\r\n// is confusing, we should clean it up.\r\nfunction makeDevtoolsIOPromiseFromIOTrigger(ioTrigger, displayName, resolvedValue) {\r\n    // If we create a `new Promise` and give it a displayName\r\n    // (with no userspace code above us in the stack)\r\n    // React Devtools will use it as the IO cause when determining \"suspended by\".\r\n    // In particular, it should shadow any inner IO that resolved/rejected the promise\r\n    // (in case of staged rendering, this will be the `setTimeout` that triggers the relevant stage)\r\n    const promise = new Promise((resolve, reject)=>{\r\n        ioTrigger.then(resolve.bind(null, resolvedValue), reject);\r\n    });\r\n    if (displayName !== undefined) {\r\n        // @ts-expect-error\r\n        promise.displayName = displayName;\r\n    }\r\n    return promise;\r\n}\r\n\r\n//# sourceMappingURL=staged-rendering.js.map","/**\r\n * Schedules a function to be called on the next tick after the other promises\r\n * have been resolved.\r\n *\r\n * @param cb the function to schedule\r\n */ export const scheduleOnNextTick = (cb)=>{\r\n    // We use Promise.resolve().then() here so that the operation is scheduled at\r\n    // the end of the promise job queue, we then add it to the next process tick\r\n    // to ensure it's evaluated afterwards.\r\n    //\r\n    // This was inspired by the implementation of the DataLoader interface: https://github.com/graphql/dataloader/blob/d336bd15282664e0be4b4a657cb796f09bafbc6b/src/index.js#L213-L255\r\n    //\r\n    Promise.resolve().then(()=>{\r\n        if (process.env.NEXT_RUNTIME === 'edge') {\r\n            setTimeout(cb, 0);\r\n        } else {\r\n            process.nextTick(cb);\r\n        }\r\n    });\r\n};\r\n/**\r\n * Schedules a function to be called using `setImmediate` or `setTimeout` if\r\n * `setImmediate` is not available (like in the Edge runtime).\r\n *\r\n * @param cb the function to schedule\r\n */ export const scheduleImmediate = (cb)=>{\r\n    if (process.env.NEXT_RUNTIME === 'edge') {\r\n        setTimeout(cb, 0);\r\n    } else {\r\n        setImmediate(cb);\r\n    }\r\n};\r\n/**\r\n * returns a promise than resolves in a future task. There is no guarantee that the task it resolves in\r\n * will be the next task but if you await it you can at least be sure that the current task is over and\r\n * most usefully that the entire microtask queue of the current task has been emptied.\r\n */ export function atLeastOneTask() {\r\n    return new Promise((resolve)=>scheduleImmediate(resolve));\r\n}\r\n/**\r\n * This utility function is extracted to make it easier to find places where we are doing\r\n * specific timing tricks to try to schedule work after React has rendered. This is especially\r\n * important at the moment because Next.js uses the edge builds of React which use setTimeout to\r\n * schedule work when you might expect that something like setImmediate would do the trick.\r\n *\r\n * Long term we should switch to the node versions of React rendering when possible and then\r\n * update this to use setImmediate rather than setTimeout\r\n */ export function waitAtLeastOneReactRenderTask() {\r\n    if (process.env.NEXT_RUNTIME === 'edge') {\r\n        return new Promise((r)=>setTimeout(r, 0));\r\n    } else {\r\n        return new Promise((r)=>setImmediate(r));\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=scheduler.js.map","const REACT_POSTPONE_TYPE = Symbol.for('react.postpone');\r\nexport function isPostpone(error) {\r\n    return typeof error === 'object' && error !== null && error.$$typeof === REACT_POSTPONE_TYPE;\r\n}\r\n\r\n//# sourceMappingURL=is-postpone.js.map","import { isHangingPromiseRejectionError } from '../../server/dynamic-rendering-utils';\r\nimport { isPostpone } from '../../server/lib/router-utils/is-postpone';\r\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr';\r\nimport { isNextRouterError } from './is-next-router-error';\r\nimport { isDynamicPostpone, isPrerenderInterruptedError } from '../../server/app-render/dynamic-rendering';\r\nimport { isDynamicServerError } from './hooks-server-context';\r\nexport function unstable_rethrow(error) {\r\n    if (isNextRouterError(error) || isBailoutToCSRError(error) || isDynamicServerError(error) || isDynamicPostpone(error) || isPostpone(error) || isHangingPromiseRejectionError(error) || isPrerenderInterruptedError(error)) {\r\n        throw error;\r\n    }\r\n    if (error instanceof Error && 'cause' in error) {\r\n        unstable_rethrow(error.cause);\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=unstable-rethrow.server.js.map","import { useContext } from 'react';\r\nimport { PathnameContext } from '../../shared/lib/hooks-client-context.shared-runtime';\r\n/**\r\n * This checks to see if the current render has any unknown route parameters that\r\n * would cause the pathname to be dynamic. It's used to trigger a different\r\n * render path in the error boundary.\r\n *\r\n * @returns true if there are any unknown route parameters, false otherwise\r\n */ function hasFallbackRouteParams() {\r\n    if (typeof window === 'undefined') {\r\n        // AsyncLocalStorage should not be included in the client bundle.\r\n        const { workUnitAsyncStorage } = require('../../server/app-render/work-unit-async-storage.external');\r\n        const workUnitStore = workUnitAsyncStorage.getStore();\r\n        if (!workUnitStore) return false;\r\n        switch(workUnitStore.type){\r\n            case 'prerender':\r\n            case 'prerender-client':\r\n            case 'prerender-ppr':\r\n                const fallbackParams = workUnitStore.fallbackRouteParams;\r\n                return fallbackParams ? fallbackParams.size > 0 : false;\r\n            case 'prerender-legacy':\r\n            case 'request':\r\n            case 'prerender-runtime':\r\n            case 'cache':\r\n            case 'private-cache':\r\n            case 'unstable-cache':\r\n                break;\r\n            default:\r\n                workUnitStore;\r\n        }\r\n        return false;\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * This returns a `null` value if there are any unknown route parameters, and\r\n * otherwise returns the pathname from the context. This is an alternative to\r\n * `usePathname` that is used in the error boundary to avoid rendering the\r\n * error boundary when there are unknown route parameters. This doesn't throw\r\n * when accessed with unknown route parameters.\r\n *\r\n * @returns\r\n *\r\n * @internal\r\n */ export function useUntrackedPathname() {\r\n    // If there are any unknown route parameters we would typically throw\r\n    // an error, but this internal method allows us to return a null value instead\r\n    // for components that do not propagate the pathname to the static shell (like\r\n    // the error boundary).\r\n    if (hasFallbackRouteParams()) {\r\n        return null;\r\n    }\r\n    // This shouldn't cause any issues related to conditional rendering because\r\n    // the environment will be consistent for the render.\r\n    // eslint-disable-next-line react-hooks/rules-of-hooks\r\n    return useContext(PathnameContext);\r\n}\r\n\r\n//# sourceMappingURL=navigation-untracked.js.map","let warnOnce = (_)=>{};\r\nif (process.env.NODE_ENV !== 'production') {\r\n    const warnings = new Set();\r\n    warnOnce = (msg)=>{\r\n        if (!warnings.has(msg)) {\r\n            console.warn(msg);\r\n        }\r\n        warnings.add(msg);\r\n    };\r\n}\r\nexport { warnOnce };\r\n\r\n//# sourceMappingURL=warn-once.js.map","'use client';\r\nimport { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from \"react/jsx-runtime\";\r\n/**\r\n * HTTPAccessFallbackBoundary is a boundary that catches errors and renders a\r\n * fallback component for HTTP errors.\r\n *\r\n * It receives the status code, and determine if it should render fallbacks for few HTTP 4xx errors.\r\n *\r\n * e.g. 404\r\n * 404 represents not found, and the fallback component pair contains the component and its styles.\r\n *\r\n */ import React, { useContext } from 'react';\r\nimport { useUntrackedPathname } from '../navigation-untracked';\r\nimport { HTTPAccessErrorStatus, getAccessFallbackHTTPStatus, getAccessFallbackErrorTypeByStatus, isHTTPAccessFallbackError } from './http-access-fallback';\r\nimport { warnOnce } from '../../../shared/lib/utils/warn-once';\r\nimport { MissingSlotContext } from '../../../shared/lib/app-router-context.shared-runtime';\r\nclass HTTPAccessFallbackErrorBoundary extends React.Component {\r\n    constructor(props){\r\n        super(props);\r\n        this.state = {\r\n            triggeredStatus: undefined,\r\n            previousPathname: props.pathname\r\n        };\r\n    }\r\n    componentDidCatch() {\r\n        if (process.env.NODE_ENV === 'development' && this.props.missingSlots && this.props.missingSlots.size > 0 && // A missing children slot is the typical not-found case, so no need to warn\r\n        !this.props.missingSlots.has('children')) {\r\n            let warningMessage = 'No default component was found for a parallel route rendered on this page. Falling back to nearest NotFound boundary.\\n' + 'Learn more: https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#defaultjs\\n\\n';\r\n            const formattedSlots = Array.from(this.props.missingSlots).sort((a, b)=>a.localeCompare(b)).map((slot)=>`@${slot}`).join(', ');\r\n            warningMessage += 'Missing slots: ' + formattedSlots;\r\n            warnOnce(warningMessage);\r\n        }\r\n    }\r\n    static getDerivedStateFromError(error) {\r\n        if (isHTTPAccessFallbackError(error)) {\r\n            const httpStatus = getAccessFallbackHTTPStatus(error);\r\n            return {\r\n                triggeredStatus: httpStatus\r\n            };\r\n        }\r\n        // Re-throw if error is not for 404\r\n        throw error;\r\n    }\r\n    static getDerivedStateFromProps(props, state) {\r\n        /**\r\n     * Handles reset of the error boundary when a navigation happens.\r\n     * Ensures the error boundary does not stay enabled when navigating to a new page.\r\n     * Approach of setState in render is safe as it checks the previous pathname and then overrides\r\n     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders\r\n     */ if (props.pathname !== state.previousPathname && state.triggeredStatus) {\r\n            return {\r\n                triggeredStatus: undefined,\r\n                previousPathname: props.pathname\r\n            };\r\n        }\r\n        return {\r\n            triggeredStatus: state.triggeredStatus,\r\n            previousPathname: props.pathname\r\n        };\r\n    }\r\n    render() {\r\n        const { notFound, forbidden, unauthorized, children } = this.props;\r\n        const { triggeredStatus } = this.state;\r\n        const errorComponents = {\r\n            [HTTPAccessErrorStatus.NOT_FOUND]: notFound,\r\n            [HTTPAccessErrorStatus.FORBIDDEN]: forbidden,\r\n            [HTTPAccessErrorStatus.UNAUTHORIZED]: unauthorized\r\n        };\r\n        if (triggeredStatus) {\r\n            const isNotFound = triggeredStatus === HTTPAccessErrorStatus.NOT_FOUND && notFound;\r\n            const isForbidden = triggeredStatus === HTTPAccessErrorStatus.FORBIDDEN && forbidden;\r\n            const isUnauthorized = triggeredStatus === HTTPAccessErrorStatus.UNAUTHORIZED && unauthorized;\r\n            // If there's no matched boundary in this layer, keep throwing the error by rendering the children\r\n            if (!(isNotFound || isForbidden || isUnauthorized)) {\r\n                return children;\r\n            }\r\n            return /*#__PURE__*/ _jsxs(_Fragment, {\r\n                children: [\r\n                    /*#__PURE__*/ _jsx(\"meta\", {\r\n                        name: \"robots\",\r\n                        content: \"noindex\"\r\n                    }),\r\n                    process.env.NODE_ENV === 'development' && /*#__PURE__*/ _jsx(\"meta\", {\r\n                        name: \"boundary-next-error\",\r\n                        content: getAccessFallbackErrorTypeByStatus(triggeredStatus)\r\n                    }),\r\n                    errorComponents[triggeredStatus]\r\n                ]\r\n            });\r\n        }\r\n        return children;\r\n    }\r\n}\r\nexport function HTTPAccessFallbackBoundary({ notFound, forbidden, unauthorized, children }) {\r\n    // When we're rendering the missing params shell, this will return null. This\r\n    // is because we won't be rendering any not found boundaries or error\r\n    // boundaries for the missing params shell. When this runs on the client\r\n    // (where these error can occur), we will get the correct pathname.\r\n    const pathname = useUntrackedPathname();\r\n    const missingSlots = useContext(MissingSlotContext);\r\n    const hasErrorFallback = !!(notFound || forbidden || unauthorized);\r\n    if (hasErrorFallback) {\r\n        return /*#__PURE__*/ _jsx(HTTPAccessFallbackErrorBoundary, {\r\n            pathname: pathname,\r\n            notFound: notFound,\r\n            forbidden: forbidden,\r\n            unauthorized: unauthorized,\r\n            missingSlots: missingSlots,\r\n            children: children\r\n        });\r\n    }\r\n    return /*#__PURE__*/ _jsx(_Fragment, {\r\n        children: children\r\n    });\r\n}\r\n\r\n//# sourceMappingURL=error-boundary.js.map","'use client';\r\nimport { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from \"react/jsx-runtime\";\r\nimport { ACTION_SERVER_PATCH } from './router-reducer/router-reducer-types';\r\nimport React, { Activity, useContext, use, startTransition, Suspense, useDeferredValue } from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport { LayoutRouterContext, GlobalLayoutRouterContext, TemplateContext } from '../../shared/lib/app-router-context.shared-runtime';\r\nimport { fetchServerResponse } from './router-reducer/fetch-server-response';\r\nimport { unresolvedThenable } from './unresolved-thenable';\r\nimport { ErrorBoundary } from './error-boundary';\r\nimport { matchSegment } from './match-segments';\r\nimport { disableSmoothScrollDuringRouteTransition } from '../../shared/lib/router/utils/disable-smooth-scroll';\r\nimport { RedirectBoundary } from './redirect-boundary';\r\nimport { HTTPAccessFallbackBoundary } from './http-access-fallback/error-boundary';\r\nimport { createRouterCacheKey } from './router-reducer/create-router-cache-key';\r\nimport { hasInterceptionRouteInCurrentTree } from './router-reducer/reducers/has-interception-route-in-current-tree';\r\nimport { dispatchAppRouterAction } from './use-action-queue';\r\nimport { useRouterBFCache } from './bfcache';\r\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths';\r\nimport { NavigationPromisesContext } from '../../shared/lib/hooks-client-context.shared-runtime';\r\nimport { getParamValueFromCacheKey } from '../route-params';\r\n/**\r\n * Add refetch marker to router state at the point of the current layout segment.\r\n * This ensures the response returned is not further down than the current layout segment.\r\n */ function walkAddRefetch(segmentPathToWalk, treeToRecreate) {\r\n    if (segmentPathToWalk) {\r\n        const [segment, parallelRouteKey] = segmentPathToWalk;\r\n        const isLast = segmentPathToWalk.length === 2;\r\n        if (matchSegment(treeToRecreate[0], segment)) {\r\n            if (treeToRecreate[1].hasOwnProperty(parallelRouteKey)) {\r\n                if (isLast) {\r\n                    const subTree = walkAddRefetch(undefined, treeToRecreate[1][parallelRouteKey]);\r\n                    return [\r\n                        treeToRecreate[0],\r\n                        {\r\n                            ...treeToRecreate[1],\r\n                            [parallelRouteKey]: [\r\n                                subTree[0],\r\n                                subTree[1],\r\n                                subTree[2],\r\n                                'refetch'\r\n                            ]\r\n                        }\r\n                    ];\r\n                }\r\n                return [\r\n                    treeToRecreate[0],\r\n                    {\r\n                        ...treeToRecreate[1],\r\n                        [parallelRouteKey]: walkAddRefetch(segmentPathToWalk.slice(2), treeToRecreate[1][parallelRouteKey])\r\n                    }\r\n                ];\r\n            }\r\n        }\r\n    }\r\n    return treeToRecreate;\r\n}\r\nconst __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;\r\n// TODO-APP: Replace with new React API for finding dom nodes without a `ref` when available\r\n/**\r\n * Wraps ReactDOM.findDOMNode with additional logic to hide React Strict Mode warning\r\n */ function findDOMNode(instance) {\r\n    // Tree-shake for server bundle\r\n    if (typeof window === 'undefined') return null;\r\n    // __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE.findDOMNode is null during module init.\r\n    // We need to lazily reference it.\r\n    const internal_reactDOMfindDOMNode = __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE.findDOMNode;\r\n    return internal_reactDOMfindDOMNode(instance);\r\n}\r\nconst rectProperties = [\r\n    'bottom',\r\n    'height',\r\n    'left',\r\n    'right',\r\n    'top',\r\n    'width',\r\n    'x',\r\n    'y'\r\n];\r\n/**\r\n * Check if a HTMLElement is hidden or fixed/sticky position\r\n */ function shouldSkipElement(element) {\r\n    // we ignore fixed or sticky positioned elements since they'll likely pass the \"in-viewport\" check\r\n    // and will result in a situation we bail on scroll because of something like a fixed nav,\r\n    // even though the actual page content is offscreen\r\n    if ([\r\n        'sticky',\r\n        'fixed'\r\n    ].includes(getComputedStyle(element).position)) {\r\n        return true;\r\n    }\r\n    // Uses `getBoundingClientRect` to check if the element is hidden instead of `offsetParent`\r\n    // because `offsetParent` doesn't consider document/body\r\n    const rect = element.getBoundingClientRect();\r\n    return rectProperties.every((item)=>rect[item] === 0);\r\n}\r\n/**\r\n * Check if the top corner of the HTMLElement is in the viewport.\r\n */ function topOfElementInViewport(element, viewportHeight) {\r\n    const rect = element.getBoundingClientRect();\r\n    return rect.top >= 0 && rect.top <= viewportHeight;\r\n}\r\n/**\r\n * Find the DOM node for a hash fragment.\r\n * If `top` the page has to scroll to the top of the page. This mirrors the browser's behavior.\r\n * If the hash fragment is an id, the page has to scroll to the element with that id.\r\n * If the hash fragment is a name, the page has to scroll to the first element with that name.\r\n */ function getHashFragmentDomNode(hashFragment) {\r\n    // If the hash fragment is `top` the page has to scroll to the top of the page.\r\n    if (hashFragment === 'top') {\r\n        return document.body;\r\n    }\r\n    // If the hash fragment is an id, the page has to scroll to the element with that id.\r\n    return document.getElementById(hashFragment) ?? // If the hash fragment is a name, the page has to scroll to the first element with that name.\r\n    document.getElementsByName(hashFragment)[0];\r\n}\r\nclass InnerScrollAndFocusHandler extends React.Component {\r\n    componentDidMount() {\r\n        this.handlePotentialScroll();\r\n    }\r\n    componentDidUpdate() {\r\n        // Because this property is overwritten in handlePotentialScroll it's fine to always run it when true as it'll be set to false for subsequent renders.\r\n        if (this.props.focusAndScrollRef.apply) {\r\n            this.handlePotentialScroll();\r\n        }\r\n    }\r\n    render() {\r\n        return this.props.children;\r\n    }\r\n    constructor(...args){\r\n        super(...args), this.handlePotentialScroll = ()=>{\r\n            // Handle scroll and focus, it's only applied once in the first useEffect that triggers that changed.\r\n            const { focusAndScrollRef, segmentPath } = this.props;\r\n            if (focusAndScrollRef.apply) {\r\n                // segmentPaths is an array of segment paths that should be scrolled to\r\n                // if the current segment path is not in the array, the scroll is not applied\r\n                // unless the array is empty, in which case the scroll is always applied\r\n                if (focusAndScrollRef.segmentPaths.length !== 0 && !focusAndScrollRef.segmentPaths.some((scrollRefSegmentPath)=>segmentPath.every((segment, index)=>matchSegment(segment, scrollRefSegmentPath[index])))) {\r\n                    return;\r\n                }\r\n                let domNode = null;\r\n                const hashFragment = focusAndScrollRef.hashFragment;\r\n                if (hashFragment) {\r\n                    domNode = getHashFragmentDomNode(hashFragment);\r\n                }\r\n                // `findDOMNode` is tricky because it returns just the first child if the component is a fragment.\r\n                // This already caused a bug where the first child was a <link/> in head.\r\n                if (!domNode) {\r\n                    domNode = findDOMNode(this);\r\n                }\r\n                // If there is no DOM node this layout-router level is skipped. It'll be handled higher-up in the tree.\r\n                if (!(domNode instanceof Element)) {\r\n                    return;\r\n                }\r\n                // Verify if the element is a HTMLElement and if we want to consider it for scroll behavior.\r\n                // If the element is skipped, try to select the next sibling and try again.\r\n                while(!(domNode instanceof HTMLElement) || shouldSkipElement(domNode)){\r\n                    if (process.env.NODE_ENV !== 'production') {\r\n                        if (domNode.parentElement?.localName === 'head') {\r\n                        // TODO: We enter this state when metadata was rendered as part of the page or via Next.js.\r\n                        // This is always a bug in Next.js and caused by React hoisting metadata.\r\n                        // We need to replace `findDOMNode` in favor of Fragment Refs (when available) so that we can skip over metadata.\r\n                        }\r\n                    }\r\n                    // No siblings found that match the criteria are found, so handle scroll higher up in the tree instead.\r\n                    if (domNode.nextElementSibling === null) {\r\n                        return;\r\n                    }\r\n                    domNode = domNode.nextElementSibling;\r\n                }\r\n                // State is mutated to ensure that the focus and scroll is applied only once.\r\n                focusAndScrollRef.apply = false;\r\n                focusAndScrollRef.hashFragment = null;\r\n                focusAndScrollRef.segmentPaths = [];\r\n                disableSmoothScrollDuringRouteTransition(()=>{\r\n                    // In case of hash scroll, we only need to scroll the element into view\r\n                    if (hashFragment) {\r\n                        ;\r\n                        domNode.scrollIntoView();\r\n                        return;\r\n                    }\r\n                    // Store the current viewport height because reading `clientHeight` causes a reflow,\r\n                    // and it won't change during this function.\r\n                    const htmlElement = document.documentElement;\r\n                    const viewportHeight = htmlElement.clientHeight;\r\n                    // If the element's top edge is already in the viewport, exit early.\r\n                    if (topOfElementInViewport(domNode, viewportHeight)) {\r\n                        return;\r\n                    }\r\n                    // Otherwise, try scrolling go the top of the document to be backward compatible with pages\r\n                    // scrollIntoView() called on `<html/>` element scrolls horizontally on chrome and firefox (that shouldn't happen)\r\n                    // We could use it to scroll horizontally following RTL but that also seems to be broken - it will always scroll left\r\n                    // scrollLeft = 0 also seems to ignore RTL and manually checking for RTL is too much hassle so we will scroll just vertically\r\n                    htmlElement.scrollTop = 0;\r\n                    // Scroll to domNode if domNode is not in viewport when scrolled to top of document\r\n                    if (!topOfElementInViewport(domNode, viewportHeight)) {\r\n                        // Scroll into view doesn't scroll horizontally by default when not needed\r\n                        ;\r\n                        domNode.scrollIntoView();\r\n                    }\r\n                }, {\r\n                    // We will force layout by querying domNode position\r\n                    dontForceLayout: true,\r\n                    onlyHashChange: focusAndScrollRef.onlyHashChange\r\n                });\r\n                // Mutate after scrolling so that it can be read by `disableSmoothScrollDuringRouteTransition`\r\n                focusAndScrollRef.onlyHashChange = false;\r\n                // Set focus on the element\r\n                domNode.focus();\r\n            }\r\n        };\r\n    }\r\n}\r\nfunction ScrollAndFocusHandler({ segmentPath, children }) {\r\n    const context = useContext(GlobalLayoutRouterContext);\r\n    if (!context) {\r\n        throw Object.defineProperty(new Error('invariant global layout router not mounted'), \"__NEXT_ERROR_CODE\", {\r\n            value: \"E473\",\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n    return /*#__PURE__*/ _jsx(InnerScrollAndFocusHandler, {\r\n        segmentPath: segmentPath,\r\n        focusAndScrollRef: context.focusAndScrollRef,\r\n        children: children\r\n    });\r\n}\r\n/**\r\n * InnerLayoutRouter handles rendering the provided segment based on the cache.\r\n */ function InnerLayoutRouter({ tree, segmentPath, debugNameContext, cacheNode, params, url, isActive }) {\r\n    const context = useContext(GlobalLayoutRouterContext);\r\n    const parentNavPromises = useContext(NavigationPromisesContext);\r\n    if (!context) {\r\n        throw Object.defineProperty(new Error('invariant global layout router not mounted'), \"__NEXT_ERROR_CODE\", {\r\n            value: \"E473\",\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n    const { tree: fullTree } = context;\r\n    // `rsc` represents the renderable node for this segment.\r\n    // If this segment has a `prefetchRsc`, it's the statically prefetched data.\r\n    // We should use that on initial render instead of `rsc`. Then we'll switch\r\n    // to `rsc` when the dynamic response streams in.\r\n    //\r\n    // If no prefetch data is available, then we go straight to rendering `rsc`.\r\n    const resolvedPrefetchRsc = cacheNode.prefetchRsc !== null ? cacheNode.prefetchRsc : cacheNode.rsc;\r\n    // We use `useDeferredValue` to handle switching between the prefetched and\r\n    // final values. The second argument is returned on initial render, then it\r\n    // re-renders with the first argument.\r\n    const rsc = useDeferredValue(cacheNode.rsc, resolvedPrefetchRsc);\r\n    // `rsc` is either a React node or a promise for a React node, except we\r\n    // special case `null` to represent that this segment's data is missing. If\r\n    // it's a promise, we need to unwrap it so we can determine whether or not the\r\n    // data is missing.\r\n    const resolvedRsc = typeof rsc === 'object' && rsc !== null && typeof rsc.then === 'function' ? use(rsc) : rsc;\r\n    if (!resolvedRsc) {\r\n        // The data for this segment is not available, and there's no pending\r\n        // navigation that will be able to fulfill it. We need to fetch more from\r\n        // the server and patch the cache.\r\n        // Only fetch data for the active segment. Inactive segments (rendered\r\n        // offscreen for bfcache) should not trigger fetches.\r\n        if (isActive) {\r\n            // Check if there's already a pending request.\r\n            let lazyData = cacheNode.lazyData;\r\n            if (lazyData === null) {\r\n                /**\r\n         * Router state with refetch marker added\r\n         */ // TODO-APP: remove ''\r\n                const refetchTree = walkAddRefetch([\r\n                    '',\r\n                    ...segmentPath\r\n                ], fullTree);\r\n                const includeNextUrl = hasInterceptionRouteInCurrentTree(fullTree);\r\n                const navigatedAt = Date.now();\r\n                cacheNode.lazyData = lazyData = fetchServerResponse(new URL(url, location.origin), {\r\n                    flightRouterState: refetchTree,\r\n                    nextUrl: includeNextUrl ? // performing a dynamic request. This is because we update\r\n                    // the next-url after a navigation, but we want the same\r\n                    // interception route to be matched that used the last\r\n                    // next-url.\r\n                    context.previousNextUrl || context.nextUrl : null\r\n                }).then((serverResponse)=>{\r\n                    startTransition(()=>{\r\n                        dispatchAppRouterAction({\r\n                            type: ACTION_SERVER_PATCH,\r\n                            previousTree: fullTree,\r\n                            serverResponse,\r\n                            navigatedAt\r\n                        });\r\n                    });\r\n                    return serverResponse;\r\n                });\r\n                // Suspend while waiting for lazyData to resolve\r\n                use(lazyData);\r\n            }\r\n        }\r\n        // Suspend infinitely as `changeByServerResponse` will cause a different part of the tree to be rendered.\r\n        // A falsey `resolvedRsc` indicates missing data -- we should not commit that branch, and we need to wait for the data to arrive.\r\n        use(unresolvedThenable);\r\n    }\r\n    // If we get to this point, then we know we have something we can render.\r\n    let content = resolvedRsc;\r\n    // In dev, we create a NavigationPromisesContext containing the instrumented promises that provide\r\n    // `useSelectedLayoutSegment` and `useSelectedLayoutSegments`.\r\n    // Promises are cached outside of render to survive suspense retries.\r\n    let navigationPromises = null;\r\n    if (process.env.NODE_ENV !== 'production') {\r\n        const { createNestedLayoutNavigationPromises } = require('./navigation-devtools');\r\n        navigationPromises = createNestedLayoutNavigationPromises(tree, parentNavPromises);\r\n    }\r\n    if (navigationPromises) {\r\n        content = /*#__PURE__*/ _jsx(NavigationPromisesContext.Provider, {\r\n            value: navigationPromises,\r\n            children: resolvedRsc\r\n        });\r\n    }\r\n    const subtree = // The layout router context narrows down tree and childNodes at each level.\r\n    /*#__PURE__*/ _jsx(LayoutRouterContext.Provider, {\r\n        value: {\r\n            parentTree: tree,\r\n            parentCacheNode: cacheNode,\r\n            parentSegmentPath: segmentPath,\r\n            parentParams: params,\r\n            debugNameContext: debugNameContext,\r\n            // TODO-APP: overriding of url for parallel routes\r\n            url: url,\r\n            isActive: isActive\r\n        },\r\n        children: content\r\n    });\r\n    // Ensure root layout is not wrapped in a div as the root layout renders `<html>`\r\n    return subtree;\r\n}\r\n/**\r\n * Renders suspense boundary with the provided \"loading\" property as the fallback.\r\n * If no loading property is provided it renders the children without a suspense boundary.\r\n */ function LoadingBoundary({ name, loading, children }) {\r\n    // If loading is a promise, unwrap it. This happens in cases where we haven't\r\n    // yet received the loading data from the server  which includes whether or\r\n    // not this layout has a loading component at all.\r\n    //\r\n    // It's OK to suspend here instead of inside the fallback because this\r\n    // promise will resolve simultaneously with the data for the segment itself.\r\n    // So it will never suspend for longer than it would have if we didn't use\r\n    // a Suspense fallback at all.\r\n    let loadingModuleData;\r\n    if (typeof loading === 'object' && loading !== null && typeof loading.then === 'function') {\r\n        const promiseForLoading = loading;\r\n        loadingModuleData = use(promiseForLoading);\r\n    } else {\r\n        loadingModuleData = loading;\r\n    }\r\n    if (loadingModuleData) {\r\n        const loadingRsc = loadingModuleData[0];\r\n        const loadingStyles = loadingModuleData[1];\r\n        const loadingScripts = loadingModuleData[2];\r\n        return /*#__PURE__*/ _jsx(Suspense, {\r\n            name: name,\r\n            fallback: /*#__PURE__*/ _jsxs(_Fragment, {\r\n                children: [\r\n                    loadingStyles,\r\n                    loadingScripts,\r\n                    loadingRsc\r\n                ]\r\n            }),\r\n            children: children\r\n        });\r\n    }\r\n    return /*#__PURE__*/ _jsx(_Fragment, {\r\n        children: children\r\n    });\r\n}\r\n/**\r\n * OuterLayoutRouter handles the current segment as well as <Offscreen> rendering of other segments.\r\n * It can be rendered next to each other with a different `parallelRouterKey`, allowing for Parallel routes.\r\n */ export default function OuterLayoutRouter({ parallelRouterKey, error, errorStyles, errorScripts, templateStyles, templateScripts, template, notFound, forbidden, unauthorized, segmentViewBoundaries }) {\r\n    const context = useContext(LayoutRouterContext);\r\n    if (!context) {\r\n        throw Object.defineProperty(new Error('invariant expected layout router to be mounted'), \"__NEXT_ERROR_CODE\", {\r\n            value: \"E56\",\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n    const { parentTree, parentCacheNode, parentSegmentPath, parentParams, url, isActive, debugNameContext } = context;\r\n    // Get the CacheNode for this segment by reading it from the parent segment's\r\n    // child map.\r\n    const parentParallelRoutes = parentCacheNode.parallelRoutes;\r\n    let segmentMap = parentParallelRoutes.get(parallelRouterKey);\r\n    // If the parallel router cache node does not exist yet, create it.\r\n    // This writes to the cache when there is no item in the cache yet. It never *overwrites* existing cache items which is why it's safe in concurrent mode.\r\n    if (!segmentMap) {\r\n        segmentMap = new Map();\r\n        parentParallelRoutes.set(parallelRouterKey, segmentMap);\r\n    }\r\n    const parentTreeSegment = parentTree[0];\r\n    const segmentPath = parentSegmentPath === null ? // path. This has led to a bunch of special cases scattered throughout\r\n    // the code. We should clean this up.\r\n    [\r\n        parallelRouterKey\r\n    ] : parentSegmentPath.concat([\r\n        parentTreeSegment,\r\n        parallelRouterKey\r\n    ]);\r\n    // The \"state\" key of a segment is the one passed to React  it represents the\r\n    // identity of the UI tree. Whenever the state key changes, the tree is\r\n    // recreated and the state is reset. In the App Router model, search params do\r\n    // not cause state to be lost, so two segments with the same segment path but\r\n    // different search params should have the same state key.\r\n    //\r\n    // The \"cache\" key of a segment, however, *does* include the search params, if\r\n    // it's possible that the segment accessed the search params on the server.\r\n    // (This only applies to page segments; layout segments cannot access search\r\n    // params on the server.)\r\n    const activeTree = parentTree[1][parallelRouterKey];\r\n    const activeSegment = activeTree[0];\r\n    const activeStateKey = createRouterCacheKey(activeSegment, true) // no search params\r\n    ;\r\n    // At each level of the route tree, not only do we render the currently\r\n    // active segment  we also render the last N segments that were active at\r\n    // this level inside a hidden <Activity> boundary, to preserve their state\r\n    // if or when the user navigates to them again.\r\n    //\r\n    // bfcacheEntry is a linked list of FlightRouterStates.\r\n    let bfcacheEntry = useRouterBFCache(activeTree, activeStateKey);\r\n    let children = [];\r\n    do {\r\n        const tree = bfcacheEntry.tree;\r\n        const stateKey = bfcacheEntry.stateKey;\r\n        const segment = tree[0];\r\n        const cacheKey = createRouterCacheKey(segment);\r\n        // Read segment path from the parallel router cache node.\r\n        let cacheNode = segmentMap.get(cacheKey);\r\n        if (cacheNode === undefined) {\r\n            // When data is not available during rendering client-side we need to fetch\r\n            // it from the server.\r\n            const newLazyCacheNode = {\r\n                lazyData: null,\r\n                rsc: null,\r\n                prefetchRsc: null,\r\n                head: null,\r\n                prefetchHead: null,\r\n                parallelRoutes: new Map(),\r\n                loading: null,\r\n                navigatedAt: -1\r\n            };\r\n            // Flight data fetch kicked off during render and put into the cache.\r\n            cacheNode = newLazyCacheNode;\r\n            segmentMap.set(cacheKey, newLazyCacheNode);\r\n        }\r\n        /*\r\n    - Error boundary\r\n      - Only renders error boundary if error component is provided.\r\n      - Rendered for each segment to ensure they have their own error state.\r\n      - When gracefully degrade for bots, skip rendering error boundary.\r\n    - Loading boundary\r\n      - Only renders suspense boundary if loading components is provided.\r\n      - Rendered for each segment to ensure they have their own loading state.\r\n      - Passed to the router during rendering to ensure it can be immediately rendered when suspending on a Flight fetch.\r\n  */ let segmentBoundaryTriggerNode = null;\r\n        let segmentViewStateNode = null;\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            const { SegmentBoundaryTriggerNode, SegmentViewStateNode } = require('../../next-devtools/userspace/app/segment-explorer-node');\r\n            const pagePrefix = normalizeAppPath(url);\r\n            segmentViewStateNode = /*#__PURE__*/ _jsx(SegmentViewStateNode, {\r\n                page: pagePrefix\r\n            }, pagePrefix);\r\n            segmentBoundaryTriggerNode = /*#__PURE__*/ _jsx(_Fragment, {\r\n                children: /*#__PURE__*/ _jsx(SegmentBoundaryTriggerNode, {})\r\n            });\r\n        }\r\n        let params = parentParams;\r\n        if (Array.isArray(segment)) {\r\n            // This segment contains a route param. Accumulate these as we traverse\r\n            // down the router tree. The result represents the set of params that\r\n            // the layout/page components are permitted to access below this point.\r\n            const paramName = segment[0];\r\n            const paramCacheKey = segment[1];\r\n            const paramType = segment[2];\r\n            const paramValue = getParamValueFromCacheKey(paramCacheKey, paramType);\r\n            if (paramValue !== null) {\r\n                params = {\r\n                    ...parentParams,\r\n                    [paramName]: paramValue\r\n                };\r\n            }\r\n        }\r\n        const debugName = getBoundaryDebugNameFromSegment(segment);\r\n        // `debugNameContext` represents the nearest non-\"virtual\" parent segment.\r\n        // `getBoundaryDebugNameFromSegment` returns undefined for virtual segments.\r\n        // So if `debugName` is undefined, the context is passed through unchanged.\r\n        const childDebugNameContext = debugName ?? debugNameContext;\r\n        // In practical terms, clicking this name in the Suspense DevTools\r\n        // should select the child slots of that layout.\r\n        //\r\n        // So the name we apply to the Activity boundary is actually based on\r\n        // the nearest parent segments.\r\n        //\r\n        // We skip over \"virtual\" parents, i.e. ones inserted by Next.js that\r\n        // don't correspond to application-defined code.\r\n        const isVirtual = debugName === undefined;\r\n        const debugNameToDisplay = isVirtual ? undefined : debugNameContext;\r\n        // TODO: The loading module data for a segment is stored on the parent, then\r\n        // applied to each of that parent segment's parallel route slots. In the\r\n        // simple case where there's only one parallel route (the `children` slot),\r\n        // this is no different from if the loading module data where stored on the\r\n        // child directly. But I'm not sure this actually makes sense when there are\r\n        // multiple parallel routes. It's not a huge issue because you always have\r\n        // the option to define a narrower loading boundary for a particular slot. But\r\n        // this sort of smells like an implementation accident to me.\r\n        const loadingModuleData = parentCacheNode.loading;\r\n        let child = /*#__PURE__*/ _jsxs(TemplateContext.Provider, {\r\n            value: /*#__PURE__*/ _jsxs(ScrollAndFocusHandler, {\r\n                segmentPath: segmentPath,\r\n                children: [\r\n                    /*#__PURE__*/ _jsx(ErrorBoundary, {\r\n                        errorComponent: error,\r\n                        errorStyles: errorStyles,\r\n                        errorScripts: errorScripts,\r\n                        children: /*#__PURE__*/ _jsx(LoadingBoundary, {\r\n                            name: debugNameToDisplay,\r\n                            loading: loadingModuleData,\r\n                            children: /*#__PURE__*/ _jsx(HTTPAccessFallbackBoundary, {\r\n                                notFound: notFound,\r\n                                forbidden: forbidden,\r\n                                unauthorized: unauthorized,\r\n                                children: /*#__PURE__*/ _jsxs(RedirectBoundary, {\r\n                                    children: [\r\n                                        /*#__PURE__*/ _jsx(InnerLayoutRouter, {\r\n                                            url: url,\r\n                                            tree: tree,\r\n                                            params: params,\r\n                                            cacheNode: cacheNode,\r\n                                            segmentPath: segmentPath,\r\n                                            debugNameContext: childDebugNameContext,\r\n                                            isActive: isActive && stateKey === activeStateKey\r\n                                        }),\r\n                                        segmentBoundaryTriggerNode\r\n                                    ]\r\n                                })\r\n                            })\r\n                        })\r\n                    }),\r\n                    segmentViewStateNode\r\n                ]\r\n            }),\r\n            children: [\r\n                templateStyles,\r\n                templateScripts,\r\n                template\r\n            ]\r\n        }, stateKey);\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            const { SegmentStateProvider } = require('../../next-devtools/userspace/app/segment-explorer-node');\r\n            child = /*#__PURE__*/ _jsxs(SegmentStateProvider, {\r\n                children: [\r\n                    child,\r\n                    segmentViewBoundaries\r\n                ]\r\n            }, stateKey);\r\n        }\r\n        if (process.env.__NEXT_CACHE_COMPONENTS) {\r\n            child = /*#__PURE__*/ _jsx(Activity, {\r\n                name: debugNameToDisplay,\r\n                mode: stateKey === activeStateKey ? 'visible' : 'hidden',\r\n                children: child\r\n            }, stateKey);\r\n        }\r\n        children.push(child);\r\n        bfcacheEntry = bfcacheEntry.next;\r\n    }while (bfcacheEntry !== null);\r\n    return children;\r\n}\r\nfunction getBoundaryDebugNameFromSegment(segment) {\r\n    if (segment === '/') {\r\n        // Reached the root\r\n        return '/';\r\n    }\r\n    if (typeof segment === 'string') {\r\n        if (isVirtualLayout(segment)) {\r\n            return undefined;\r\n        } else {\r\n            return segment + '/';\r\n        }\r\n    }\r\n    const paramCacheKey = segment[1];\r\n    return paramCacheKey + '/';\r\n}\r\nfunction isVirtualLayout(segment) {\r\n    return(// This is inserted by the loader. We should consider encoding these\r\n    // in a more special way instead of checking the name, to distinguish them\r\n    // from app-defined groups.\r\n    segment === '(slot)');\r\n}\r\n\r\n//# sourceMappingURL=layout-router.js.map","'use client';\r\nimport { jsx as _jsx } from \"react/jsx-runtime\";\r\nimport React, { useEffect } from 'react';\r\nimport { useRouter } from './navigation';\r\nimport { getRedirectTypeFromError, getURLFromRedirectError } from './redirect';\r\nimport { RedirectType, isRedirectError } from './redirect-error';\r\nfunction HandleRedirect({ redirect, reset, redirectType }) {\r\n    const router = useRouter();\r\n    useEffect(()=>{\r\n        React.startTransition(()=>{\r\n            if (redirectType === RedirectType.push) {\r\n                router.push(redirect, {});\r\n            } else {\r\n                router.replace(redirect, {});\r\n            }\r\n            reset();\r\n        });\r\n    }, [\r\n        redirect,\r\n        redirectType,\r\n        reset,\r\n        router\r\n    ]);\r\n    return null;\r\n}\r\nexport class RedirectErrorBoundary extends React.Component {\r\n    constructor(props){\r\n        super(props);\r\n        this.state = {\r\n            redirect: null,\r\n            redirectType: null\r\n        };\r\n    }\r\n    static getDerivedStateFromError(error) {\r\n        if (isRedirectError(error)) {\r\n            const url = getURLFromRedirectError(error);\r\n            const redirectType = getRedirectTypeFromError(error);\r\n            return {\r\n                redirect: url,\r\n                redirectType\r\n            };\r\n        }\r\n        // Re-throw if error is not for redirect\r\n        throw error;\r\n    }\r\n    // Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific to the `@types/react` version.\r\n    render() {\r\n        const { redirect, redirectType } = this.state;\r\n        if (redirect !== null && redirectType !== null) {\r\n            return /*#__PURE__*/ _jsx(HandleRedirect, {\r\n                redirect: redirect,\r\n                redirectType: redirectType,\r\n                reset: ()=>this.setState({\r\n                        redirect: null\r\n                    })\r\n            });\r\n        }\r\n        return this.props.children;\r\n    }\r\n}\r\nexport function RedirectBoundary({ children }) {\r\n    const router = useRouter();\r\n    return /*#__PURE__*/ _jsx(RedirectErrorBoundary, {\r\n        router: router,\r\n        children: children\r\n    });\r\n}\r\n\r\n//# sourceMappingURL=redirect-boundary.js.map","import { PAGE_SEGMENT_KEY } from '../shared/lib/segment';\r\nimport { getCacheKeyForDynamicParam, parseDynamicParamFromURLPart, doesStaticSegmentAppearInURL, getRenderedPathname, getRenderedSearch } from './route-params';\r\nimport { createHrefFromUrl } from './components/router-reducer/create-href-from-url';\r\n// TODO: We should only have to export `normalizeFlightData`, however because the initial flight data\r\n// that gets passed to `createInitialRouterState` doesn't conform to the `FlightDataPath` type (it's missing the root segment)\r\n// we're currently exporting it so we can use it directly. This should be fixed as part of the unification of\r\n// the different ways we express `FlightSegmentPath`.\r\nexport function getFlightDataPartsFromPath(flightDataPath) {\r\n    // Pick the last 4 items from the `FlightDataPath` to get the [tree, seedData, viewport, isHeadPartial].\r\n    const flightDataPathLength = 4;\r\n    // tree, seedData, and head are *always* the last three items in the `FlightDataPath`.\r\n    const [tree, seedData, head, isHeadPartial] = flightDataPath.slice(-flightDataPathLength);\r\n    // The `FlightSegmentPath` is everything except the last three items. For a root render, it won't be present.\r\n    const segmentPath = flightDataPath.slice(0, -flightDataPathLength);\r\n    return {\r\n        // TODO: Unify these two segment path helpers. We are inconsistently pushing an empty segment (\"\")\r\n        // to the start of the segment path in some places which makes it hard to use solely the segment path.\r\n        // Look for \"// TODO-APP: remove ''\" in the codebase.\r\n        pathToSegment: segmentPath.slice(0, -1),\r\n        segmentPath,\r\n        // if the `FlightDataPath` corresponds with the root, there'll be no segment path,\r\n        // in which case we default to ''.\r\n        segment: segmentPath[segmentPath.length - 1] ?? '',\r\n        tree,\r\n        seedData,\r\n        head,\r\n        isHeadPartial,\r\n        isRootRender: flightDataPath.length === flightDataPathLength\r\n    };\r\n}\r\nexport function createInitialRSCPayloadFromFallbackPrerender(response, fallbackInitialRSCPayload) {\r\n    // This is a static fallback page. In order to hydrate the page, we need to\r\n    // parse the client params from the URL, but to account for the possibility\r\n    // that the page was rewritten, we need to check the response headers\r\n    // for x-nextjs-rewritten-path or x-nextjs-rewritten-query headers. Since\r\n    // we can't access the headers of the initial document response, the client\r\n    // performs a fetch request to the current location. Since it's possible that\r\n    // the fetch request will be dynamically rewritten to a different path than\r\n    // the initial document, this fetch request delivers _all_ the hydration data\r\n    // for the page; it was not inlined into the document, like it normally\r\n    // would be.\r\n    //\r\n    // TODO: Consider treating the case where fetch is rewritten to a different\r\n    // path from the document as a special deopt case. We should optimistically\r\n    // assume this won't happen, inline the data into the document, and perform\r\n    // a minimal request (like a HEAD or range request) to verify that the\r\n    // response matches. Tricky to get right because we need to account for\r\n    // all the different deployment environments we support, like output:\r\n    // \"export\" mode, where we currently don't assume that custom response\r\n    // headers are present.\r\n    // Patch the Flight data sent by the server with the correct params parsed\r\n    // from the URL + response object.\r\n    const renderedPathname = getRenderedPathname(response);\r\n    const renderedSearch = getRenderedSearch(response);\r\n    const canonicalUrl = createHrefFromUrl(new URL(location.href));\r\n    const originalFlightDataPath = fallbackInitialRSCPayload.f[0];\r\n    const originalFlightRouterState = originalFlightDataPath[0];\r\n    return {\r\n        b: fallbackInitialRSCPayload.b,\r\n        c: canonicalUrl.split('/'),\r\n        q: renderedSearch,\r\n        i: fallbackInitialRSCPayload.i,\r\n        f: [\r\n            [\r\n                fillInFallbackFlightRouterState(originalFlightRouterState, renderedPathname, renderedSearch),\r\n                originalFlightDataPath[1],\r\n                originalFlightDataPath[2],\r\n                originalFlightDataPath[2]\r\n            ]\r\n        ],\r\n        m: fallbackInitialRSCPayload.m,\r\n        G: fallbackInitialRSCPayload.G,\r\n        s: fallbackInitialRSCPayload.s,\r\n        S: fallbackInitialRSCPayload.S\r\n    };\r\n}\r\nfunction fillInFallbackFlightRouterState(flightRouterState, renderedPathname, renderedSearch) {\r\n    const pathnameParts = renderedPathname.split('/').filter((p)=>p !== '');\r\n    const index = 0;\r\n    return fillInFallbackFlightRouterStateImpl(flightRouterState, renderedSearch, pathnameParts, index);\r\n}\r\nfunction fillInFallbackFlightRouterStateImpl(flightRouterState, renderedSearch, pathnameParts, pathnamePartsIndex) {\r\n    const originalSegment = flightRouterState[0];\r\n    let newSegment;\r\n    let doesAppearInURL;\r\n    if (typeof originalSegment === 'string') {\r\n        newSegment = originalSegment;\r\n        doesAppearInURL = doesStaticSegmentAppearInURL(originalSegment);\r\n    } else {\r\n        const paramName = originalSegment[0];\r\n        const paramType = originalSegment[2];\r\n        const paramValue = parseDynamicParamFromURLPart(paramType, pathnameParts, pathnamePartsIndex);\r\n        const cacheKey = getCacheKeyForDynamicParam(paramValue, renderedSearch);\r\n        newSegment = [\r\n            paramName,\r\n            cacheKey,\r\n            paramType\r\n        ];\r\n        doesAppearInURL = true;\r\n    }\r\n    // Only increment the index if the segment appears in the URL. If it's a\r\n    // \"virtual\" segment, like a route group, it remains the same.\r\n    const childPathnamePartsIndex = doesAppearInURL ? pathnamePartsIndex + 1 : pathnamePartsIndex;\r\n    const children = flightRouterState[1];\r\n    const newChildren = {};\r\n    for(let key in children){\r\n        const childFlightRouterState = children[key];\r\n        newChildren[key] = fillInFallbackFlightRouterStateImpl(childFlightRouterState, renderedSearch, pathnameParts, childPathnamePartsIndex);\r\n    }\r\n    const newState = [\r\n        newSegment,\r\n        newChildren,\r\n        null,\r\n        flightRouterState[3],\r\n        flightRouterState[4]\r\n    ];\r\n    return newState;\r\n}\r\nexport function getNextFlightSegmentPath(flightSegmentPath) {\r\n    // Since `FlightSegmentPath` is a repeated tuple of `Segment` and `ParallelRouteKey`, we slice off two items\r\n    // to get the next segment path.\r\n    return flightSegmentPath.slice(2);\r\n}\r\nexport function normalizeFlightData(flightData) {\r\n    // FlightData can be a string when the server didn't respond with a proper flight response,\r\n    // or when a redirect happens, to signal to the client that it needs to perform an MPA navigation.\r\n    if (typeof flightData === 'string') {\r\n        return flightData;\r\n    }\r\n    return flightData.map((flightDataPath)=>getFlightDataPartsFromPath(flightDataPath));\r\n}\r\n/**\r\n * This function is used to prepare the flight router state for the request.\r\n * It removes markers that are not needed by the server, and are purely used\r\n * for stashing state on the client.\r\n * @param flightRouterState - The flight router state to prepare.\r\n * @param isHmrRefresh - Whether this is an HMR refresh request.\r\n * @returns The prepared flight router state.\r\n */ export function prepareFlightRouterStateForRequest(flightRouterState, isHmrRefresh) {\r\n    // HMR requests need the complete, unmodified state for proper functionality\r\n    if (isHmrRefresh) {\r\n        return encodeURIComponent(JSON.stringify(flightRouterState));\r\n    }\r\n    return encodeURIComponent(JSON.stringify(stripClientOnlyDataFromFlightRouterState(flightRouterState)));\r\n}\r\n/**\r\n * Recursively strips client-only data from FlightRouterState while preserving\r\n * server-needed information for proper rendering decisions.\r\n */ function stripClientOnlyDataFromFlightRouterState(flightRouterState) {\r\n    const [segment, parallelRoutes, _url, refreshMarker, isRootLayout, hasLoadingBoundary] = flightRouterState;\r\n    // __PAGE__ segments are always fetched from the server, so there's\r\n    // no need to send them up\r\n    const cleanedSegment = stripSearchParamsFromPageSegment(segment);\r\n    // Recursively process parallel routes\r\n    const cleanedParallelRoutes = {};\r\n    for (const [key, childState] of Object.entries(parallelRoutes)){\r\n        cleanedParallelRoutes[key] = stripClientOnlyDataFromFlightRouterState(childState);\r\n    }\r\n    const result = [\r\n        cleanedSegment,\r\n        cleanedParallelRoutes,\r\n        null,\r\n        shouldPreserveRefreshMarker(refreshMarker) ? refreshMarker : null\r\n    ];\r\n    // Append optional fields if present\r\n    if (isRootLayout !== undefined) {\r\n        result[4] = isRootLayout;\r\n    }\r\n    if (hasLoadingBoundary !== undefined) {\r\n        result[5] = hasLoadingBoundary;\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Strips search parameters from __PAGE__ segments to prevent sensitive\r\n * client-side data from being sent to the server.\r\n */ function stripSearchParamsFromPageSegment(segment) {\r\n    if (typeof segment === 'string' && segment.startsWith(PAGE_SEGMENT_KEY + '?')) {\r\n        return PAGE_SEGMENT_KEY;\r\n    }\r\n    return segment;\r\n}\r\n/**\r\n * Determines whether the refresh marker should be sent to the server\r\n * Client-only markers like 'refresh' are stripped, while server-needed markers\r\n * like 'refetch' and 'inside-shared-layout' are preserved.\r\n */ function shouldPreserveRefreshMarker(refreshMarker) {\r\n    return Boolean(refreshMarker && refreshMarker !== 'refresh');\r\n}\r\n\r\n//# sourceMappingURL=flight-data-helpers.js.map","// This gets assigned as a side-effect during app initialization. Because it\r\n// represents the build used to create the JS bundle, it should never change\r\n// after being set, so we store it in a global variable.\r\n//\r\n// When performing RSC requests, if the incoming data has a different build ID,\r\n// we perform an MPA navigation/refresh to load the updated build and ensure\r\n// that the client and server in sync.\r\n// Starts as an empty string. In practice, because setAppBuildId is called\r\n// during initialization before hydration starts, this will always get\r\n// reassigned to the actual build ID before it's ever needed by a navigation.\r\n// If for some reasons it didn't, due to a bug or race condition, then on\r\n// navigation the build comparision would fail and trigger an MPA navigation.\r\nlet globalBuildId = '';\r\nexport function setAppBuildId(buildId) {\r\n    globalBuildId = buildId;\r\n}\r\nexport function getAppBuildId() {\r\n    return globalBuildId;\r\n}\r\n\r\n//# sourceMappingURL=app-build-id.js.map","'use client';\r\nimport { computeCacheBustingSearchParam } from '../../../shared/lib/router/utils/cache-busting-search-param';\r\nimport { NEXT_ROUTER_PREFETCH_HEADER, NEXT_ROUTER_SEGMENT_PREFETCH_HEADER, NEXT_ROUTER_STATE_TREE_HEADER, NEXT_URL, NEXT_RSC_UNION_QUERY } from '../app-router-headers';\r\n/**\r\n * Mutates the provided URL by adding a cache-busting search parameter for CDNs that don't\r\n * support custom headers. This helps avoid caching conflicts by making each request unique.\r\n *\r\n * Rather than relying on the Vary header which some CDNs ignore, we append a search param\r\n * to create a unique URL that forces a fresh request.\r\n *\r\n * Example:\r\n * URL before: https://example.com/path?query=1\r\n * URL after: https://example.com/path?query=1&_rsc=abc123\r\n *\r\n * Note: This function mutates the input URL directly and does not return anything.\r\n *\r\n * TODO: Since we need to use a search param anyway, we could simplify by removing the custom\r\n * headers approach entirely and just use search params.\r\n */ export const setCacheBustingSearchParam = (url, headers)=>{\r\n    const uniqueCacheKey = computeCacheBustingSearchParam(headers[NEXT_ROUTER_PREFETCH_HEADER], headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER], headers[NEXT_ROUTER_STATE_TREE_HEADER], headers[NEXT_URL]);\r\n    setCacheBustingSearchParamWithHash(url, uniqueCacheKey);\r\n};\r\n/**\r\n * Sets a cache-busting search parameter on a URL using a provided hash value.\r\n *\r\n * This function performs the same logic as `setCacheBustingSearchParam` but accepts\r\n * a pre-computed hash instead of computing it from headers.\r\n *\r\n * Example:\r\n * URL before: https://example.com/path?query=1\r\n * hash: \"abc123\"\r\n * URL after: https://example.com/path?query=1&_rsc=abc123\r\n *\r\n * If the hash is null, we will set `_rsc` search param without a value.\r\n * Like this: https://example.com/path?query=1&_rsc\r\n *\r\n * Note: This function mutates the input URL directly and does not return anything.\r\n */ export const setCacheBustingSearchParamWithHash = (url, hash)=>{\r\n    /**\r\n   * Note that we intentionally do not use `url.searchParams.set` here:\r\n   *\r\n   * const url = new URL('https://example.com/search?q=custom%20spacing');\r\n   * url.searchParams.set('_rsc', 'abc123');\r\n   * console.log(url.toString()); // Outputs: https://example.com/search?q=custom+spacing&_rsc=abc123\r\n   *                                                                             ^ <--- this is causing confusion\r\n   * This is in fact intended based on https://url.spec.whatwg.org/#interface-urlsearchparams, but\r\n   * we want to preserve the %20 as %20 if that's what the user passed in, hence the custom\r\n   * logic below.\r\n   */ const existingSearch = url.search;\r\n    const rawQuery = existingSearch.startsWith('?') ? existingSearch.slice(1) : existingSearch;\r\n    // Always remove any existing cache busting param and add a fresh one to ensure\r\n    // we have the correct value based on current request headers\r\n    const pairs = rawQuery.split('&').filter((pair)=>pair && !pair.startsWith(`${NEXT_RSC_UNION_QUERY}=`));\r\n    if (hash.length > 0) {\r\n        pairs.push(`${NEXT_RSC_UNION_QUERY}=${hash}`);\r\n    } else {\r\n        pairs.push(`${NEXT_RSC_UNION_QUERY}`);\r\n    }\r\n    url.search = pairs.length ? `?${pairs.join('&')}` : '';\r\n};\r\n\r\n//# sourceMappingURL=set-cache-busting-search-param.js.map","'use client';\r\n// TODO: Explicitly import from client.browser\r\n// eslint-disable-next-line import/no-extraneous-dependencies\r\nimport { createFromReadableStream as createFromReadableStreamBrowser, createFromFetch as createFromFetchBrowser } from 'react-server-dom-webpack/client';\r\nimport { NEXT_ROUTER_PREFETCH_HEADER, NEXT_ROUTER_STATE_TREE_HEADER, NEXT_RSC_UNION_QUERY, NEXT_URL, RSC_HEADER, RSC_CONTENT_TYPE_HEADER, NEXT_HMR_REFRESH_HEADER, NEXT_DID_POSTPONE_HEADER, NEXT_ROUTER_STALE_TIME_HEADER, NEXT_HTML_REQUEST_ID_HEADER, NEXT_REQUEST_ID_HEADER } from '../app-router-headers';\r\nimport { callServer } from '../../app-call-server';\r\nimport { findSourceMapURL } from '../../app-find-source-map-url';\r\nimport { PrefetchKind } from './router-reducer-types';\r\nimport { normalizeFlightData, prepareFlightRouterStateForRequest } from '../../flight-data-helpers';\r\nimport { getAppBuildId } from '../../app-build-id';\r\nimport { setCacheBustingSearchParam } from './set-cache-busting-search-param';\r\nimport { getRenderedSearch, urlToUrlWithoutFlightMarker } from '../../route-params';\r\nconst createFromReadableStream = createFromReadableStreamBrowser;\r\nconst createFromFetch = createFromFetchBrowser;\r\nlet createDebugChannel;\r\nif (process.env.NODE_ENV !== 'production' && process.env.__NEXT_REACT_DEBUG_CHANNEL) {\r\n    createDebugChannel = require('../../dev/debug-channel').createDebugChannel;\r\n}\r\nfunction doMpaNavigation(url) {\r\n    return urlToUrlWithoutFlightMarker(new URL(url, location.origin)).toString();\r\n}\r\nlet abortController = new AbortController();\r\nif (typeof window !== 'undefined') {\r\n    // Abort any in-flight requests when the page is unloaded, e.g. due to\r\n    // reloading the page or performing hard navigations. This allows us to ignore\r\n    // what would otherwise be a thrown TypeError when the browser cancels the\r\n    // requests.\r\n    window.addEventListener('pagehide', ()=>{\r\n        abortController.abort();\r\n    });\r\n    // Use a fresh AbortController instance on pageshow, e.g. when navigating back\r\n    // and the JavaScript execution context is restored by the browser.\r\n    window.addEventListener('pageshow', ()=>{\r\n        abortController = new AbortController();\r\n    });\r\n}\r\n/**\r\n * Fetch the flight data for the provided url. Takes in the current router state\r\n * to decide what to render server-side.\r\n */ export async function fetchServerResponse(url, options) {\r\n    const { flightRouterState, nextUrl, prefetchKind } = options;\r\n    const headers = {\r\n        // Enable flight response\r\n        [RSC_HEADER]: '1',\r\n        // Provide the current router state\r\n        [NEXT_ROUTER_STATE_TREE_HEADER]: prepareFlightRouterStateForRequest(flightRouterState, options.isHmrRefresh)\r\n    };\r\n    /**\r\n   * Three cases:\r\n   * - `prefetchKind` is `undefined`, it means it's a normal navigation, so we want to prefetch the page data fully\r\n   * - `prefetchKind` is `full` - we want to prefetch the whole page so same as above\r\n   * - `prefetchKind` is `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully\r\n   */ if (prefetchKind === PrefetchKind.AUTO) {\r\n        headers[NEXT_ROUTER_PREFETCH_HEADER] = '1';\r\n    }\r\n    if (process.env.NODE_ENV === 'development' && options.isHmrRefresh) {\r\n        headers[NEXT_HMR_REFRESH_HEADER] = '1';\r\n    }\r\n    if (nextUrl) {\r\n        headers[NEXT_URL] = nextUrl;\r\n    }\r\n    // In static export mode, we need to modify the URL to request the .txt file,\r\n    // but we should preserve the original URL for the canonical URL and error handling.\r\n    const originalUrl = url;\r\n    try {\r\n        // When creating a \"temporary\" prefetch (the \"on-demand\" prefetch that gets created on navigation, if one doesn't exist)\r\n        // we send the request with a \"high\" priority as it's in response to a user interaction that could be blocking a transition.\r\n        // Otherwise, all other prefetches are sent with a \"low\" priority.\r\n        // We use \"auto\" for in all other cases to match the existing default, as this function is shared outside of prefetching.\r\n        const fetchPriority = prefetchKind ? prefetchKind === PrefetchKind.TEMPORARY ? 'high' : 'low' : 'auto';\r\n        if (process.env.NODE_ENV === 'production') {\r\n            if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\r\n                // In \"output: export\" mode, we can't rely on headers to distinguish\r\n                // between HTML and RSC requests. Instead, we append an extra prefix\r\n                // to the request.\r\n                url = new URL(url);\r\n                if (url.pathname.endsWith('/')) {\r\n                    url.pathname += 'index.txt';\r\n                } else {\r\n                    url.pathname += '.txt';\r\n                }\r\n            }\r\n        }\r\n        // Typically, during a navigation, we decode the response using Flight's\r\n        // `createFromFetch` API, which accepts a `fetch` promise.\r\n        // TODO: Remove this check once the old PPR flag is removed\r\n        const isLegacyPPR = process.env.__NEXT_PPR && !process.env.__NEXT_CACHE_COMPONENTS;\r\n        const shouldImmediatelyDecode = !isLegacyPPR;\r\n        const res = await createFetch(url, headers, fetchPriority, shouldImmediatelyDecode, abortController.signal);\r\n        const responseUrl = urlToUrlWithoutFlightMarker(new URL(res.url));\r\n        const canonicalUrl = res.redirected ? responseUrl : originalUrl;\r\n        const contentType = res.headers.get('content-type') || '';\r\n        const interception = !!res.headers.get('vary')?.includes(NEXT_URL);\r\n        const postponed = !!res.headers.get(NEXT_DID_POSTPONE_HEADER);\r\n        const staleTimeHeaderSeconds = res.headers.get(NEXT_ROUTER_STALE_TIME_HEADER);\r\n        const staleTime = staleTimeHeaderSeconds !== null ? parseInt(staleTimeHeaderSeconds, 10) * 1000 : -1;\r\n        let isFlightResponse = contentType.startsWith(RSC_CONTENT_TYPE_HEADER);\r\n        if (process.env.NODE_ENV === 'production') {\r\n            if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\r\n                if (!isFlightResponse) {\r\n                    isFlightResponse = contentType.startsWith('text/plain');\r\n                }\r\n            }\r\n        }\r\n        // If fetch returns something different than flight response handle it like a mpa navigation\r\n        // If the fetch was not 200, we also handle it like a mpa navigation\r\n        if (!isFlightResponse || !res.ok || !res.body) {\r\n            // in case the original URL came with a hash, preserve it before redirecting to the new URL\r\n            if (url.hash) {\r\n                responseUrl.hash = url.hash;\r\n            }\r\n            return doMpaNavigation(responseUrl.toString());\r\n        }\r\n        // We may navigate to a page that requires a different Webpack runtime.\r\n        // In prod, every page will have the same Webpack runtime.\r\n        // In dev, the Webpack runtime is minimal for each page.\r\n        // We need to ensure the Webpack runtime is updated before executing client-side JS of the new page.\r\n        // TODO: This needs to happen in the Flight Client.\r\n        // Or Webpack needs to include the runtime update in the Flight response as\r\n        // a blocking script.\r\n        if (process.env.NODE_ENV !== 'production' && !process.env.TURBOPACK) {\r\n            await require('../../dev/hot-reloader/app/hot-reloader-app').waitForWebpackRuntimeHotUpdate();\r\n        }\r\n        let flightResponsePromise = res.flightResponse;\r\n        if (flightResponsePromise === null) {\r\n            // Typically, `createFetch` would have already started decoding the\r\n            // Flight response. If it hasn't, though, we need to decode it now.\r\n            // TODO: This should only be reachable if legacy PPR is enabled (i.e. PPR\r\n            // without Cache Components). Remove this branch once legacy PPR\r\n            // is deleted.\r\n            const flightStream = postponed ? createUnclosingPrefetchStream(res.body) : res.body;\r\n            flightResponsePromise = createFromNextReadableStream(flightStream, headers);\r\n        }\r\n        const flightResponse = await flightResponsePromise;\r\n        if (getAppBuildId() !== flightResponse.b) {\r\n            return doMpaNavigation(res.url);\r\n        }\r\n        const normalizedFlightData = normalizeFlightData(flightResponse.f);\r\n        if (typeof normalizedFlightData === 'string') {\r\n            return doMpaNavigation(normalizedFlightData);\r\n        }\r\n        return {\r\n            flightData: normalizedFlightData,\r\n            canonicalUrl: canonicalUrl,\r\n            renderedSearch: getRenderedSearch(res),\r\n            couldBeIntercepted: interception,\r\n            prerendered: flightResponse.S,\r\n            postponed,\r\n            staleTime,\r\n            debugInfo: flightResponsePromise._debugInfo ?? null\r\n        };\r\n    } catch (err) {\r\n        if (!abortController.signal.aborted) {\r\n            console.error(`Failed to fetch RSC payload for ${originalUrl}. Falling back to browser navigation.`, err);\r\n        }\r\n        // If fetch fails handle it like a mpa navigation\r\n        // TODO-APP: Add a test for the case where a CORS request fails, e.g. external url redirect coming from the response.\r\n        // See https://github.com/vercel/next.js/issues/43605#issuecomment-1451617521 for a reproduction.\r\n        return originalUrl.toString();\r\n    }\r\n}\r\nexport async function createFetch(url, headers, fetchPriority, shouldImmediatelyDecode, signal) {\r\n    // TODO: In output: \"export\" mode, the headers do nothing. Omit them (and the\r\n    // cache busting search param) from the request so they're\r\n    // maximally cacheable.\r\n    if (process.env.__NEXT_TEST_MODE && fetchPriority !== null) {\r\n        headers['Next-Test-Fetch-Priority'] = fetchPriority;\r\n    }\r\n    if (process.env.NEXT_DEPLOYMENT_ID) {\r\n        headers['x-deployment-id'] = process.env.NEXT_DEPLOYMENT_ID;\r\n    }\r\n    if (process.env.NODE_ENV !== 'production') {\r\n        if (self.__next_r) {\r\n            headers[NEXT_HTML_REQUEST_ID_HEADER] = self.__next_r;\r\n        }\r\n        // Create a new request ID for the server action request. The server uses\r\n        // this to tag debug information sent via WebSocket to the client, which\r\n        // then routes those chunks to the debug channel associated with this ID.\r\n        headers[NEXT_REQUEST_ID_HEADER] = crypto.getRandomValues(new Uint32Array(1))[0].toString(16);\r\n    }\r\n    const fetchOptions = {\r\n        // Backwards compat for older browsers. `same-origin` is the default in modern browsers.\r\n        credentials: 'same-origin',\r\n        headers,\r\n        priority: fetchPriority || undefined,\r\n        signal\r\n    };\r\n    // `fetchUrl` is slightly different from `url` because we add a cache-busting\r\n    // search param to it. This should not leak outside of this function, so we\r\n    // track them separately.\r\n    let fetchUrl = new URL(url);\r\n    setCacheBustingSearchParam(fetchUrl, headers);\r\n    let fetchPromise = fetch(fetchUrl, fetchOptions);\r\n    // Immediately pass the fetch promise to the Flight client so that the debug\r\n    // info includes the latency from the client to the server. The internal timer\r\n    // in React starts as soon as `createFromFetch` is called.\r\n    //\r\n    // The only case where we don't do this is during a prefetch, because we have\r\n    // to do some extra processing of the response stream (see\r\n    // `createUnclosingPrefetchStream`). But this is fine, because a top-level\r\n    // prefetch response never blocks a navigation; if it hasn't already been\r\n    // written into the cache by the time the navigation happens, the router will\r\n    // go straight to a dynamic request.\r\n    let flightResponsePromise = shouldImmediatelyDecode ? createFromNextFetch(fetchPromise, headers) : null;\r\n    let browserResponse = await fetchPromise;\r\n    // If the server responds with a redirect (e.g. 307), and the redirected\r\n    // location does not contain the cache busting search param set in the\r\n    // original request, the response is likely invalid  when following the\r\n    // redirect, the browser forwards the request headers, but since the cache\r\n    // busting search param is missing, the server will reject the request due to\r\n    // a mismatch.\r\n    //\r\n    // Ideally, we would be able to intercept the redirect response and perform it\r\n    // manually, instead of letting the browser automatically follow it, but this\r\n    // is not allowed by the fetch API.\r\n    //\r\n    // So instead, we must \"replay\" the redirect by fetching the new location\r\n    // again, but this time we'll append the cache busting search param to prevent\r\n    // a mismatch.\r\n    //\r\n    // TODO: We can optimize Next.js's built-in middleware APIs by returning a\r\n    // custom status code, to prevent the browser from automatically following it.\r\n    //\r\n    // This does not affect Server Action-based redirects; those are encoded\r\n    // differently, as part of the Flight body. It only affects redirects that\r\n    // occur in a middleware or a third-party proxy.\r\n    let redirected = browserResponse.redirected;\r\n    if (process.env.__NEXT_CLIENT_VALIDATE_RSC_REQUEST_HEADERS) {\r\n        // This is to prevent a redirect loop. Same limit used by Chrome.\r\n        const MAX_REDIRECTS = 20;\r\n        for(let n = 0; n < MAX_REDIRECTS; n++){\r\n            if (!browserResponse.redirected) {\r\n                break;\r\n            }\r\n            const responseUrl = new URL(browserResponse.url, fetchUrl);\r\n            if (responseUrl.origin !== fetchUrl.origin) {\r\n                break;\r\n            }\r\n            if (responseUrl.searchParams.get(NEXT_RSC_UNION_QUERY) === fetchUrl.searchParams.get(NEXT_RSC_UNION_QUERY)) {\r\n                break;\r\n            }\r\n            // The RSC request was redirected. Assume the response is invalid.\r\n            //\r\n            // Append the cache busting search param to the redirected URL and\r\n            // fetch again.\r\n            // TODO: We should abort the previous request.\r\n            fetchUrl = new URL(responseUrl);\r\n            setCacheBustingSearchParam(fetchUrl, headers);\r\n            fetchPromise = fetch(fetchUrl, fetchOptions);\r\n            flightResponsePromise = shouldImmediatelyDecode ? createFromNextFetch(fetchPromise, headers) : null;\r\n            browserResponse = await fetchPromise;\r\n            // We just performed a manual redirect, so this is now true.\r\n            redirected = true;\r\n        }\r\n    }\r\n    // Remove the cache busting search param from the response URL, to prevent it\r\n    // from leaking outside of this function.\r\n    const responseUrl = new URL(browserResponse.url, fetchUrl);\r\n    responseUrl.searchParams.delete(NEXT_RSC_UNION_QUERY);\r\n    const rscResponse = {\r\n        url: responseUrl.href,\r\n        // This is true if any redirects occurred, either automatically by the\r\n        // browser, or manually by us. So it's different from\r\n        // `browserResponse.redirected`, which only tells us whether the browser\r\n        // followed a redirect, and only for the last response in the chain.\r\n        redirected,\r\n        // These can be copied from the last browser response we received. We\r\n        // intentionally only expose the subset of fields that are actually used\r\n        // elsewhere in the codebase.\r\n        ok: browserResponse.ok,\r\n        headers: browserResponse.headers,\r\n        body: browserResponse.body,\r\n        status: browserResponse.status,\r\n        // This is the exact promise returned by `createFromFetch`. It contains\r\n        // debug information that we need to transfer to any derived promises that\r\n        // are later rendered by React.\r\n        flightResponse: flightResponsePromise\r\n    };\r\n    return rscResponse;\r\n}\r\nexport function createFromNextReadableStream(flightStream, requestHeaders) {\r\n    return createFromReadableStream(flightStream, {\r\n        callServer,\r\n        findSourceMapURL,\r\n        debugChannel: createDebugChannel && createDebugChannel(requestHeaders)\r\n    });\r\n}\r\nfunction createFromNextFetch(promiseForResponse, requestHeaders) {\r\n    return createFromFetch(promiseForResponse, {\r\n        callServer,\r\n        findSourceMapURL,\r\n        debugChannel: createDebugChannel && createDebugChannel(requestHeaders)\r\n    });\r\n}\r\nfunction createUnclosingPrefetchStream(originalFlightStream) {\r\n    // When PPR is enabled, prefetch streams may contain references that never\r\n    // resolve, because that's how we encode dynamic data access. In the decoded\r\n    // object returned by the Flight client, these are reified into hanging\r\n    // promises that suspend during render, which is effectively what we want.\r\n    // The UI resolves when it switches to the dynamic data stream\r\n    // (via useDeferredValue(dynamic, static)).\r\n    //\r\n    // However, the Flight implementation currently errors if the server closes\r\n    // the response before all the references are resolved. As a cheat to work\r\n    // around this, we wrap the original stream in a new stream that never closes,\r\n    // and therefore doesn't error.\r\n    const reader = originalFlightStream.getReader();\r\n    return new ReadableStream({\r\n        async pull (controller) {\r\n            while(true){\r\n                const { done, value } = await reader.read();\r\n                if (!done) {\r\n                    // Pass to the target stream and keep consuming the Flight response\r\n                    // from the server.\r\n                    controller.enqueue(value);\r\n                    continue;\r\n                }\r\n                // The server stream has closed. Exit, but intentionally do not close\r\n                // the target stream.\r\n                return;\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\n//# sourceMappingURL=fetch-server-response.js.map","const workAsyncStorage = typeof window === 'undefined' ? require('../../server/app-render/work-async-storage.external').workAsyncStorage : undefined;\r\n// if we are revalidating we want to re-throw the error so the\r\n// function crashes so we can maintain our previous cache\r\n// instead of caching the error page\r\nexport function HandleISRError({ error }) {\r\n    if (workAsyncStorage) {\r\n        const store = workAsyncStorage.getStore();\r\n        if (store?.isStaticGeneration) {\r\n            if (error) {\r\n                console.error(error);\r\n            }\r\n            throw error;\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\n//# sourceMappingURL=handle-isr-error.js.map","'use client';\r\nimport { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from \"react/jsx-runtime\";\r\nimport React from 'react';\r\nimport { useUntrackedPathname } from './navigation-untracked';\r\nimport { isNextRouterError } from './is-next-router-error';\r\nimport { handleHardNavError } from './nav-failure-handler';\r\nimport { HandleISRError } from './handle-isr-error';\r\nimport { isBot } from '../../shared/lib/router/utils/is-bot';\r\nconst isBotUserAgent = typeof window !== 'undefined' && isBot(window.navigator.userAgent);\r\nexport class ErrorBoundaryHandler extends React.Component {\r\n    constructor(props){\r\n        super(props), this.reset = ()=>{\r\n            this.setState({\r\n                error: null\r\n            });\r\n        };\r\n        this.state = {\r\n            error: null,\r\n            previousPathname: this.props.pathname\r\n        };\r\n    }\r\n    static getDerivedStateFromError(error) {\r\n        if (isNextRouterError(error)) {\r\n            // Re-throw if an expected internal Next.js router error occurs\r\n            // this means it should be handled by a different boundary (such as a NotFound boundary in a parent segment)\r\n            throw error;\r\n        }\r\n        return {\r\n            error\r\n        };\r\n    }\r\n    static getDerivedStateFromProps(props, state) {\r\n        const { error } = state;\r\n        // if we encounter an error while\r\n        // a navigation is pending we shouldn't render\r\n        // the error boundary and instead should fallback\r\n        // to a hard navigation to attempt recovering\r\n        if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {\r\n            if (error && handleHardNavError(error)) {\r\n                // clear error so we don't render anything\r\n                return {\r\n                    error: null,\r\n                    previousPathname: props.pathname\r\n                };\r\n            }\r\n        }\r\n        /**\r\n     * Handles reset of the error boundary when a navigation happens.\r\n     * Ensures the error boundary does not stay enabled when navigating to a new page.\r\n     * Approach of setState in render is safe as it checks the previous pathname and then overrides\r\n     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders\r\n     */ if (props.pathname !== state.previousPathname && state.error) {\r\n            return {\r\n                error: null,\r\n                previousPathname: props.pathname\r\n            };\r\n        }\r\n        return {\r\n            error: state.error,\r\n            previousPathname: props.pathname\r\n        };\r\n    }\r\n    // Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific to the `@types/react` version.\r\n    render() {\r\n        //When it's bot request, segment level error boundary will keep rendering the children,\r\n        // the final error will be caught by the root error boundary and determine wether need to apply graceful degrade.\r\n        if (this.state.error && !isBotUserAgent) {\r\n            return /*#__PURE__*/ _jsxs(_Fragment, {\r\n                children: [\r\n                    /*#__PURE__*/ _jsx(HandleISRError, {\r\n                        error: this.state.error\r\n                    }),\r\n                    this.props.errorStyles,\r\n                    this.props.errorScripts,\r\n                    /*#__PURE__*/ _jsx(this.props.errorComponent, {\r\n                        error: this.state.error,\r\n                        reset: this.reset\r\n                    })\r\n                ]\r\n            });\r\n        }\r\n        return this.props.children;\r\n    }\r\n}\r\n/**\r\n * Handles errors through `getDerivedStateFromError`.\r\n * Renders the provided error component and provides a way to `reset` the error boundary state.\r\n */ /**\r\n * Renders error boundary with the provided \"errorComponent\" property as the fallback.\r\n * If no \"errorComponent\" property is provided it renders the children without an error boundary.\r\n */ export function ErrorBoundary({ errorComponent, errorStyles, errorScripts, children }) {\r\n    // When we're rendering the missing params shell, this will return null. This\r\n    // is because we won't be rendering any not found boundaries or error\r\n    // boundaries for the missing params shell. When this runs on the client\r\n    // (where these errors can occur), we will get the correct pathname.\r\n    const pathname = useUntrackedPathname();\r\n    if (errorComponent) {\r\n        return /*#__PURE__*/ _jsx(ErrorBoundaryHandler, {\r\n            pathname: pathname,\r\n            errorComponent: errorComponent,\r\n            errorStyles: errorStyles,\r\n            errorScripts: errorScripts,\r\n            children: children\r\n        });\r\n    }\r\n    return /*#__PURE__*/ _jsx(_Fragment, {\r\n        children: children\r\n    });\r\n}\r\n\r\n//# sourceMappingURL=error-boundary.js.map","import { warnOnce } from '../../utils/warn-once';\r\n/**\r\n * Run function with `scroll-behavior: auto` applied to `<html/>`.\r\n * This css change will be reverted after the function finishes.\r\n */ export function disableSmoothScrollDuringRouteTransition(fn, options = {}) {\r\n    // if only the hash is changed, we don't need to disable smooth scrolling\r\n    // we only care to prevent smooth scrolling when navigating to a new page to avoid jarring UX\r\n    if (options.onlyHashChange) {\r\n        fn();\r\n        return;\r\n    }\r\n    const htmlElement = document.documentElement;\r\n    const hasDataAttribute = htmlElement.dataset.scrollBehavior === 'smooth';\r\n    if (!hasDataAttribute) {\r\n        // Warn if smooth scrolling is detected but no data attribute is present\r\n        if (process.env.NODE_ENV === 'development' && getComputedStyle(htmlElement).scrollBehavior === 'smooth') {\r\n            warnOnce('Detected `scroll-behavior: smooth` on the `<html>` element. To disable smooth scrolling during route transitions, ' + 'add `data-scroll-behavior=\"smooth\"` to your <html> element. ' + 'Learn more: https://nextjs.org/docs/messages/missing-data-scroll-behavior');\r\n        }\r\n        // No smooth scrolling configured, run directly without style manipulation\r\n        fn();\r\n        return;\r\n    }\r\n    // Proceed with temporarily disabling smooth scrolling\r\n    const existing = htmlElement.style.scrollBehavior;\r\n    htmlElement.style.scrollBehavior = 'auto';\r\n    if (!options.dontForceLayout) {\r\n        // In Chrome-based browsers we need to force reflow before calling `scrollTo`.\r\n        // Otherwise it will not pickup the change in scrollBehavior\r\n        // More info here: https://github.com/vercel/next.js/issues/40719#issuecomment-1336248042\r\n        htmlElement.getClientRects();\r\n    }\r\n    fn();\r\n    htmlElement.style.scrollBehavior = existing;\r\n}\r\n\r\n//# sourceMappingURL=disable-smooth-scroll.js.map","/**\r\n * ReadonlyURLSearchParams implementation shared between client and server.\r\n * This file is intentionally not marked as 'use client' or 'use server'\r\n * so it can be imported by both environments.\r\n */ /** @internal */ class ReadonlyURLSearchParamsError extends Error {\r\n    constructor(){\r\n        super('Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams');\r\n    }\r\n}\r\n/**\r\n * A read-only version of URLSearchParams that throws errors when mutation methods are called.\r\n * This ensures that the URLSearchParams returned by useSearchParams() cannot be mutated.\r\n */ export class ReadonlyURLSearchParams extends URLSearchParams {\r\n    /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */ append() {\r\n        throw new ReadonlyURLSearchParamsError();\r\n    }\r\n    /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */ delete() {\r\n        throw new ReadonlyURLSearchParamsError();\r\n    }\r\n    /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */ set() {\r\n        throw new ReadonlyURLSearchParamsError();\r\n    }\r\n    /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */ sort() {\r\n        throw new ReadonlyURLSearchParamsError();\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=readonly-url-search-params.js.map","import { RedirectStatusCode } from './redirect-status-code';\r\nimport { RedirectType, isRedirectError, REDIRECT_ERROR_CODE } from './redirect-error';\r\nconst actionAsyncStorage = typeof window === 'undefined' ? require('../../server/app-render/action-async-storage.external').actionAsyncStorage : undefined;\r\nexport function getRedirectError(url, type, statusCode = RedirectStatusCode.TemporaryRedirect) {\r\n    const error = Object.defineProperty(new Error(REDIRECT_ERROR_CODE), \"__NEXT_ERROR_CODE\", {\r\n        value: \"E394\",\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    error.digest = `${REDIRECT_ERROR_CODE};${type};${url};${statusCode};`;\r\n    return error;\r\n}\r\n/**\r\n * This function allows you to redirect the user to another URL. It can be used in\r\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\r\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\r\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\r\n *\r\n * - In a Server Component, this will insert a meta tag to redirect the user to the target page.\r\n * - In a Route Handler or Server Action, it will serve a 307/303 to the caller.\r\n * - In a Server Action, type defaults to 'push' and 'replace' elsewhere.\r\n *\r\n * Read more: [Next.js Docs: `redirect`](https://nextjs.org/docs/app/api-reference/functions/redirect)\r\n */ export function redirect(/** The URL to redirect to */ url, type) {\r\n    type ??= actionAsyncStorage?.getStore()?.isAction ? RedirectType.push : RedirectType.replace;\r\n    throw getRedirectError(url, type, RedirectStatusCode.TemporaryRedirect);\r\n}\r\n/**\r\n * This function allows you to redirect the user to another URL. It can be used in\r\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\r\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\r\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\r\n *\r\n * - In a Server Component, this will insert a meta tag to redirect the user to the target page.\r\n * - In a Route Handler or Server Action, it will serve a 308/303 to the caller.\r\n *\r\n * Read more: [Next.js Docs: `redirect`](https://nextjs.org/docs/app/api-reference/functions/redirect)\r\n */ export function permanentRedirect(/** The URL to redirect to */ url, type = RedirectType.replace) {\r\n    throw getRedirectError(url, type, RedirectStatusCode.PermanentRedirect);\r\n}\r\nexport function getURLFromRedirectError(error) {\r\n    if (!isRedirectError(error)) return null;\r\n    // Slices off the beginning of the digest that contains the code and the\r\n    // separating ';'.\r\n    return error.digest.split(';').slice(2, -2).join(';');\r\n}\r\nexport function getRedirectTypeFromError(error) {\r\n    if (!isRedirectError(error)) {\r\n        throw Object.defineProperty(new Error('Not a redirect error'), \"__NEXT_ERROR_CODE\", {\r\n            value: \"E260\",\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n    return error.digest.split(';', 2)[1];\r\n}\r\nexport function getRedirectStatusCodeFromError(error) {\r\n    if (!isRedirectError(error)) {\r\n        throw Object.defineProperty(new Error('Not a redirect error'), \"__NEXT_ERROR_CODE\", {\r\n            value: \"E260\",\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n    return Number(error.digest.split(';').at(-2));\r\n}\r\n\r\n//# sourceMappingURL=redirect.js.map","import { HTTP_ERROR_FALLBACK_ERROR_CODE } from './http-access-fallback/http-access-fallback';\r\n/**\r\n * This function allows you to render the [not-found.js file](https://nextjs.org/docs/app/api-reference/file-conventions/not-found)\r\n * within a route segment as well as inject a tag.\r\n *\r\n * `notFound()` can be used in\r\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\r\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\r\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\r\n *\r\n * - In a Server Component, this will insert a `<meta name=\"robots\" content=\"noindex\" />` meta tag and set the status code to 404.\r\n * - In a Route Handler or Server Action, it will serve a 404 to the caller.\r\n *\r\n * Read more: [Next.js Docs: `notFound`](https://nextjs.org/docs/app/api-reference/functions/not-found)\r\n */ const DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};404`;\r\nexport function notFound() {\r\n    const error = Object.defineProperty(new Error(DIGEST), \"__NEXT_ERROR_CODE\", {\r\n        value: \"E394\",\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    error.digest = DIGEST;\r\n    throw error;\r\n}\r\n\r\n//# sourceMappingURL=not-found.js.map","const basePath = process.env.__NEXT_ROUTER_BASEPATH || '';\r\nconst pathname = `${basePath}/__nextjs_source-map`;\r\nexport const findSourceMapURL = process.env.NODE_ENV === 'development' ? function findSourceMapURL(filename) {\r\n    if (filename === '') {\r\n        return null;\r\n    }\r\n    if (filename.startsWith(document.location.origin) && filename.includes('/_next/static')) {\r\n        // This is a request for a client chunk. This can only happen when\r\n        // using Turbopack. In this case, since we control how those source\r\n        // maps are generated, we can safely assume that the sourceMappingURL\r\n        // is relative to the filename, with an added `.map` extension. The\r\n        // browser can just request this file, and it gets served through the\r\n        // normal dev server, without the need to route this through\r\n        // the `/__nextjs_source-map` dev middleware.\r\n        return `${filename}.map`;\r\n    }\r\n    const url = new URL(pathname, document.location.origin);\r\n    url.searchParams.set('filename', filename);\r\n    return url.href;\r\n} : undefined;\r\n\r\n//# sourceMappingURL=app-find-source-map-url.js.map","export function createHrefFromUrl(url, includeHash = true) {\r\n    return url.pathname + url.search + (includeHash ? url.hash : '');\r\n}\r\n\r\n//# sourceMappingURL=create-href-from-url.js.map","export const matchSegment = (existingSegment, segment)=>{\r\n    // segment is either Array or string\r\n    if (typeof existingSegment === 'string') {\r\n        if (typeof segment === 'string') {\r\n            // Common case: segment is just a string\r\n            return existingSegment === segment;\r\n        }\r\n        return false;\r\n    }\r\n    if (typeof segment === 'string') {\r\n        return false;\r\n    }\r\n    return existingSegment[0] === segment[0] && existingSegment[1] === segment[1];\r\n};\r\n\r\n//# sourceMappingURL=match-segments.js.map","export const ACTION_REFRESH = 'refresh';\r\nexport const ACTION_NAVIGATE = 'navigate';\r\nexport const ACTION_RESTORE = 'restore';\r\nexport const ACTION_SERVER_PATCH = 'server-patch';\r\nexport const ACTION_HMR_REFRESH = 'hmr-refresh';\r\nexport const ACTION_SERVER_ACTION = 'server-action';\r\n/**\r\n * PrefetchKind defines the type of prefetching that should be done.\r\n * - `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully.\r\n * - `full` - prefetch the page data fully.\r\n * - `temporary` - a temporary prefetch entry is added to the cache, this is used when prefetch={false} is used in next/link or when you push a route programmatically.\r\n */ export var PrefetchKind = /*#__PURE__*/ function(PrefetchKind) {\r\n    PrefetchKind[\"AUTO\"] = \"auto\";\r\n    PrefetchKind[\"FULL\"] = \"full\";\r\n    PrefetchKind[\"TEMPORARY\"] = \"temporary\";\r\n    return PrefetchKind;\r\n}({});\r\n\r\n//# sourceMappingURL=router-reducer-types.js.map","export class UnrecognizedActionError extends Error {\r\n    constructor(...args){\r\n        super(...args);\r\n        this.name = 'UnrecognizedActionError';\r\n    }\r\n}\r\n/**\r\n * Check whether a server action call failed because the server action was not recognized by the server.\r\n * This can happen if the client and the server are not from the same deployment.\r\n *\r\n * Example usage:\r\n * ```ts\r\n * try {\r\n *   await myServerAction();\r\n * } catch (err) {\r\n *   if (unstable_isUnrecognizedActionError(err)) {\r\n *     // The client is from a different deployment than the server.\r\n *     // Reloading the page will fix this mismatch.\r\n *     window.alert(\"Please refresh the page and try again\");\r\n *     return;\r\n *   }\r\n * }\r\n * ```\r\n * */ export function unstable_isUnrecognizedActionError(error) {\r\n    return !!(error && typeof error === 'object' && error instanceof UnrecognizedActionError);\r\n}\r\n\r\n//# sourceMappingURL=unrecognized-action-error.js.map","import { HTML_LIMITED_BOT_UA_RE } from './html-bots';\r\n// Bot crawler that will spin up a headless browser and execute JS.\r\n// Only the main Googlebot search crawler executes JavaScript, not other Google crawlers.\r\n// x-ref: https://developers.google.com/search/docs/crawling-indexing/google-common-crawlers\r\n// This regex specifically matches \"Googlebot\" but NOT \"Mediapartners-Google\", \"AdsBot-Google\", etc.\r\nconst HEADLESS_BROWSER_BOT_UA_RE = /Googlebot(?!-)|Googlebot$/i;\r\nexport const HTML_LIMITED_BOT_UA_RE_STRING = HTML_LIMITED_BOT_UA_RE.source;\r\nexport { HTML_LIMITED_BOT_UA_RE };\r\nfunction isDomBotUA(userAgent) {\r\n    return HEADLESS_BROWSER_BOT_UA_RE.test(userAgent);\r\n}\r\nfunction isHtmlLimitedBotUA(userAgent) {\r\n    return HTML_LIMITED_BOT_UA_RE.test(userAgent);\r\n}\r\nexport function isBot(userAgent) {\r\n    return isDomBotUA(userAgent) || isHtmlLimitedBotUA(userAgent);\r\n}\r\nexport function getBotType(userAgent) {\r\n    if (isDomBotUA(userAgent)) {\r\n        return 'dom';\r\n    }\r\n    if (isHtmlLimitedBotUA(userAgent)) {\r\n        return 'html';\r\n    }\r\n    return undefined;\r\n}\r\n\r\n//# sourceMappingURL=is-bot.js.map","import { HTTP_ERROR_FALLBACK_ERROR_CODE } from './http-access-fallback/http-access-fallback';\r\n// TODO: Add `forbidden` docs\r\n/**\r\n * @experimental\r\n * This function allows you to render the [forbidden.js file](https://nextjs.org/docs/app/api-reference/file-conventions/forbidden)\r\n * within a route segment as well as inject a tag.\r\n *\r\n * `forbidden()` can be used in\r\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\r\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\r\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\r\n *\r\n * Read more: [Next.js Docs: `forbidden`](https://nextjs.org/docs/app/api-reference/functions/forbidden)\r\n */ const DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};403`;\r\nexport function forbidden() {\r\n    if (!process.env.__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS) {\r\n        throw Object.defineProperty(new Error(`\\`forbidden()\\` is experimental and only allowed to be enabled when \\`experimental.authInterrupts\\` is enabled.`), \"__NEXT_ERROR_CODE\", {\r\n            value: \"E488\",\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n    const error = Object.defineProperty(new Error(DIGEST), \"__NEXT_ERROR_CODE\", {\r\n        value: \"E394\",\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    error.digest = DIGEST;\r\n    throw error;\r\n}\r\n\r\n//# sourceMappingURL=forbidden.js.map","import { HTTP_ERROR_FALLBACK_ERROR_CODE } from './http-access-fallback/http-access-fallback';\r\n// TODO: Add `unauthorized` docs\r\n/**\r\n * @experimental\r\n * This function allows you to render the [unauthorized.js file](https://nextjs.org/docs/app/api-reference/file-conventions/unauthorized)\r\n * within a route segment as well as inject a tag.\r\n *\r\n * `unauthorized()` can be used in\r\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\r\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\r\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\r\n *\r\n *\r\n * Read more: [Next.js Docs: `unauthorized`](https://nextjs.org/docs/app/api-reference/functions/unauthorized)\r\n */ const DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};401`;\r\nexport function unauthorized() {\r\n    if (!process.env.__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS) {\r\n        throw Object.defineProperty(new Error(`\\`unauthorized()\\` is experimental and only allowed to be used when \\`experimental.authInterrupts\\` is enabled.`), \"__NEXT_ERROR_CODE\", {\r\n            value: \"E411\",\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n    const error = Object.defineProperty(new Error(DIGEST), \"__NEXT_ERROR_CODE\", {\r\n        value: \"E394\",\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    error.digest = DIGEST;\r\n    throw error;\r\n}\r\n\r\n//# sourceMappingURL=unauthorized.js.map","import { useState } from 'react';\r\n// When the flag is disabled, only track the currently active tree\r\nconst MAX_BF_CACHE_ENTRIES = process.env.__NEXT_CACHE_COMPONENTS ? 3 : 1;\r\n/**\r\n * Keeps track of the most recent N trees (FlightRouterStates) that were active\r\n * at a certain segment level. E.g. for a segment \"/a/b/[param]\", this hook\r\n * tracks the last N param values that the router rendered for N.\r\n *\r\n * The result of this hook precisely determines the number and order of\r\n * trees that are rendered in parallel at their segment level.\r\n *\r\n * The purpose of this cache is to we can preserve the React and DOM state of\r\n * some number of inactive trees, by rendering them in an <Activity> boundary.\r\n * That means it would not make sense for the the lifetime of the cache to be\r\n * any longer than the lifetime of the React tree; e.g. if the hook were\r\n * unmounted, then the React tree would be, too. So, we use React state to\r\n * manage it.\r\n *\r\n * Note that we don't store the RSC data for the cache entries in this hook \r\n * the data for inactive segments is stored in the parent CacheNode, which\r\n * *does* have a longer lifetime than the React tree. This hook only determines\r\n * which of those trees should have their *state* preserved, by <Activity>.\r\n */ export function useRouterBFCache(activeTree, activeStateKey) {\r\n    // The currently active entry. The entries form a linked list, sorted in\r\n    // order of most recently active. This allows us to reuse parts of the list\r\n    // without cloning, unless there's a reordering or removal.\r\n    // TODO: Once we start tracking back/forward history at each route level,\r\n    // we should use the history order instead. In other words, when traversing\r\n    // to an existing entry as a result of a popstate event, we should maintain\r\n    // the existing order instead of moving it to the front of the list. I think\r\n    // an initial implementation of this could be to pass an incrementing id\r\n    // to history.pushState/replaceState, then use that here for ordering.\r\n    const [prevActiveEntry, setPrevActiveEntry] = useState(()=>{\r\n        const initialEntry = {\r\n            tree: activeTree,\r\n            stateKey: activeStateKey,\r\n            next: null\r\n        };\r\n        return initialEntry;\r\n    });\r\n    if (prevActiveEntry.tree === activeTree) {\r\n        // Fast path. The active tree hasn't changed, so we can reuse the\r\n        // existing state.\r\n        return prevActiveEntry;\r\n    }\r\n    // The route tree changed. Note that this doesn't mean that the tree changed\r\n    // *at this level*  the change may be due to a child route. Either way, we\r\n    // need to either add or update the router tree in the bfcache.\r\n    //\r\n    // The rest of the code looks more complicated than it actually is because we\r\n    // can't mutate the state in place; we have to copy-on-write.\r\n    // Create a new entry for the active cache key. This is the head of the new\r\n    // linked list.\r\n    const newActiveEntry = {\r\n        tree: activeTree,\r\n        stateKey: activeStateKey,\r\n        next: null\r\n    };\r\n    // We need to append the old list onto the new list. If the head of the new\r\n    // list was already present in the cache, then we'll need to clone everything\r\n    // that came before it. Then we can reuse the rest.\r\n    let n = 1;\r\n    let oldEntry = prevActiveEntry;\r\n    let clonedEntry = newActiveEntry;\r\n    while(oldEntry !== null && n < MAX_BF_CACHE_ENTRIES){\r\n        if (oldEntry.stateKey === activeStateKey) {\r\n            // Fast path. This entry in the old list that corresponds to the key that\r\n            // is now active. We've already placed a clone of this entry at the front\r\n            // of the new list. We can reuse the rest of the old list without cloning.\r\n            // NOTE: We don't need to worry about eviction in this case because we\r\n            // haven't increased the size of the cache, and we assume the max size\r\n            // is constant across renders. If we were to change it to a dynamic limit,\r\n            // then the implementation would need to account for that.\r\n            clonedEntry.next = oldEntry.next;\r\n            break;\r\n        } else {\r\n            // Clone the entry and append it to the list.\r\n            n++;\r\n            const entry = {\r\n                tree: oldEntry.tree,\r\n                stateKey: oldEntry.stateKey,\r\n                next: null\r\n            };\r\n            clonedEntry.next = entry;\r\n            clonedEntry = entry;\r\n        }\r\n        oldEntry = oldEntry.next;\r\n    }\r\n    setPrevActiveEntry(newActiveEntry);\r\n    return newActiveEntry;\r\n}\r\n\r\n//# sourceMappingURL=bfcache.js.map","import { hexHash } from '../../hash';\r\nexport function computeCacheBustingSearchParam(prefetchHeader, segmentPrefetchHeader, stateTreeHeader, nextUrlHeader) {\r\n    if ((prefetchHeader === undefined || prefetchHeader === '0') && segmentPrefetchHeader === undefined && stateTreeHeader === undefined && nextUrlHeader === undefined) {\r\n        return '';\r\n    }\r\n    return hexHash([\r\n        prefetchHeader || '0',\r\n        segmentPrefetchHeader || '0',\r\n        stateTreeHeader || '0',\r\n        nextUrlHeader || '0'\r\n    ].join(','));\r\n}\r\n\r\n//# sourceMappingURL=cache-busting-search-param.js.map","import { ReadonlyURLSearchParams } from './readonly-url-search-params';\r\nexport function unstable_isUnrecognizedActionError() {\r\n    throw Object.defineProperty(new Error('`unstable_isUnrecognizedActionError` can only be used on the client.'), \"__NEXT_ERROR_CODE\", {\r\n        value: \"E776\",\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n}\r\nexport { redirect, permanentRedirect } from './redirect';\r\nexport { RedirectType } from './redirect-error';\r\nexport { notFound } from './not-found';\r\nexport { forbidden } from './forbidden';\r\nexport { unauthorized } from './unauthorized';\r\nexport { unstable_rethrow } from './unstable-rethrow';\r\nexport { ReadonlyURLSearchParams };\r\n\r\n//# sourceMappingURL=navigation.react-server.js.map","import { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment';\r\nexport function createRouterCacheKey(segment, withoutSearchParameters = false) {\r\n    // if the segment is an array, it means it's a dynamic segment\r\n    // for example, ['lang', 'en', 'd']. We need to convert it to a string to store it as a cache node key.\r\n    if (Array.isArray(segment)) {\r\n        return `${segment[0]}|${segment[1]}|${segment[2]}`;\r\n    }\r\n    // Page segments might have search parameters, ie __PAGE__?foo=bar\r\n    // When `withoutSearchParameters` is true, we only want to return the page segment\r\n    if (withoutSearchParameters && segment.startsWith(PAGE_SEGMENT_KEY)) {\r\n        return PAGE_SEGMENT_KEY;\r\n    }\r\n    return segment;\r\n}\r\n\r\n//# sourceMappingURL=create-router-cache-key.js.map","import { isInterceptionRouteAppPath } from '../../../../shared/lib/router/utils/interception-routes';\r\nexport function hasInterceptionRouteInCurrentTree([segment, parallelRoutes]) {\r\n    // If we have a dynamic segment, it's marked as an interception route by the presence of the `i` suffix.\r\n    if (Array.isArray(segment) && (segment[2] === 'di' || segment[2] === 'ci')) {\r\n        return true;\r\n    }\r\n    // If segment is not an array, apply the existing string-based check\r\n    if (typeof segment === 'string' && isInterceptionRouteAppPath(segment)) {\r\n        return true;\r\n    }\r\n    // Iterate through parallelRoutes if they exist\r\n    if (parallelRoutes) {\r\n        for(const key in parallelRoutes){\r\n            if (hasInterceptionRouteInCurrentTree(parallelRoutes[key])) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n//# sourceMappingURL=has-interception-route-in-current-tree.js.map","import React, { useContext, useMemo, use } from 'react';\r\nimport { AppRouterContext, LayoutRouterContext } from '../../shared/lib/app-router-context.shared-runtime';\r\nimport { SearchParamsContext, PathnameContext, PathParamsContext, NavigationPromisesContext } from '../../shared/lib/hooks-client-context.shared-runtime';\r\nimport { computeSelectedLayoutSegment, getSelectedLayoutSegmentPath } from '../../shared/lib/segment';\r\nimport { ReadonlyURLSearchParams } from './readonly-url-search-params';\r\nconst useDynamicRouteParams = typeof window === 'undefined' ? require('../../server/app-render/dynamic-rendering').useDynamicRouteParams : undefined;\r\nconst useDynamicSearchParams = typeof window === 'undefined' ? require('../../server/app-render/dynamic-rendering').useDynamicSearchParams : undefined;\r\n/**\r\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\r\n * that lets you *read* the current URL's search parameters.\r\n *\r\n * Learn more about [`URLSearchParams` on MDN](https://developer.mozilla.org/docs/Web/API/URLSearchParams)\r\n *\r\n * @example\r\n * ```ts\r\n * \"use client\"\r\n * import { useSearchParams } from 'next/navigation'\r\n *\r\n * export default function Page() {\r\n *   const searchParams = useSearchParams()\r\n *   searchParams.get('foo') // returns 'bar' when ?foo=bar\r\n *   // ...\r\n * }\r\n * ```\r\n *\r\n * Read more: [Next.js Docs: `useSearchParams`](https://nextjs.org/docs/app/api-reference/functions/use-search-params)\r\n */ // Client components API\r\nexport function useSearchParams() {\r\n    useDynamicSearchParams?.('useSearchParams()');\r\n    const searchParams = useContext(SearchParamsContext);\r\n    // In the case where this is `null`, the compat types added in\r\n    // `next-env.d.ts` will add a new overload that changes the return type to\r\n    // include `null`.\r\n    const readonlySearchParams = useMemo(()=>{\r\n        if (!searchParams) {\r\n            // When the router is not ready in pages, we won't have the search params\r\n            // available.\r\n            return null;\r\n        }\r\n        return new ReadonlyURLSearchParams(searchParams);\r\n    }, [\r\n        searchParams\r\n    ]);\r\n    // Instrument with Suspense DevTools (dev-only)\r\n    if (process.env.NODE_ENV !== 'production' && 'use' in React) {\r\n        const navigationPromises = use(NavigationPromisesContext);\r\n        if (navigationPromises) {\r\n            return use(navigationPromises.searchParams);\r\n        }\r\n    }\r\n    return readonlySearchParams;\r\n}\r\n/**\r\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\r\n * that lets you read the current URL's pathname.\r\n *\r\n * @example\r\n * ```ts\r\n * \"use client\"\r\n * import { usePathname } from 'next/navigation'\r\n *\r\n * export default function Page() {\r\n *  const pathname = usePathname() // returns \"/dashboard\" on /dashboard?foo=bar\r\n *  // ...\r\n * }\r\n * ```\r\n *\r\n * Read more: [Next.js Docs: `usePathname`](https://nextjs.org/docs/app/api-reference/functions/use-pathname)\r\n */ // Client components API\r\nexport function usePathname() {\r\n    useDynamicRouteParams?.('usePathname()');\r\n    // In the case where this is `null`, the compat types added in `next-env.d.ts`\r\n    // will add a new overload that changes the return type to include `null`.\r\n    const pathname = useContext(PathnameContext);\r\n    // Instrument with Suspense DevTools (dev-only)\r\n    if (process.env.NODE_ENV !== 'production' && 'use' in React) {\r\n        const navigationPromises = use(NavigationPromisesContext);\r\n        if (navigationPromises) {\r\n            return use(navigationPromises.pathname);\r\n        }\r\n    }\r\n    return pathname;\r\n}\r\n// Client components API\r\nexport { ServerInsertedHTMLContext, useServerInsertedHTML } from '../../shared/lib/server-inserted-html.shared-runtime';\r\n/**\r\n *\r\n * This hook allows you to programmatically change routes inside [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components).\r\n *\r\n * @example\r\n * ```ts\r\n * \"use client\"\r\n * import { useRouter } from 'next/navigation'\r\n *\r\n * export default function Page() {\r\n *  const router = useRouter()\r\n *  // ...\r\n *  router.push('/dashboard') // Navigate to /dashboard\r\n * }\r\n * ```\r\n *\r\n * Read more: [Next.js Docs: `useRouter`](https://nextjs.org/docs/app/api-reference/functions/use-router)\r\n */ // Client components API\r\nexport function useRouter() {\r\n    const router = useContext(AppRouterContext);\r\n    if (router === null) {\r\n        throw Object.defineProperty(new Error('invariant expected app router to be mounted'), \"__NEXT_ERROR_CODE\", {\r\n            value: \"E238\",\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n    return router;\r\n}\r\n/**\r\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\r\n * that lets you read a route's dynamic params filled in by the current URL.\r\n *\r\n * @example\r\n * ```ts\r\n * \"use client\"\r\n * import { useParams } from 'next/navigation'\r\n *\r\n * export default function Page() {\r\n *   // on /dashboard/[team] where pathname is /dashboard/nextjs\r\n *   const { team } = useParams() // team === \"nextjs\"\r\n * }\r\n * ```\r\n *\r\n * Read more: [Next.js Docs: `useParams`](https://nextjs.org/docs/app/api-reference/functions/use-params)\r\n */ // Client components API\r\nexport function useParams() {\r\n    useDynamicRouteParams?.('useParams()');\r\n    const params = useContext(PathParamsContext);\r\n    // Instrument with Suspense DevTools (dev-only)\r\n    if (process.env.NODE_ENV !== 'production' && 'use' in React) {\r\n        const navigationPromises = use(NavigationPromisesContext);\r\n        if (navigationPromises) {\r\n            return use(navigationPromises.params);\r\n        }\r\n    }\r\n    return params;\r\n}\r\n/**\r\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\r\n * that lets you read the active route segments **below** the Layout it is called from.\r\n *\r\n * @example\r\n * ```ts\r\n * 'use client'\r\n *\r\n * import { useSelectedLayoutSegments } from 'next/navigation'\r\n *\r\n * export default function ExampleClientComponent() {\r\n *   const segments = useSelectedLayoutSegments()\r\n *\r\n *   return (\r\n *     <ul>\r\n *       {segments.map((segment, index) => (\r\n *         <li key={index}>{segment}</li>\r\n *       ))}\r\n *     </ul>\r\n *   )\r\n * }\r\n * ```\r\n *\r\n * Read more: [Next.js Docs: `useSelectedLayoutSegments`](https://nextjs.org/docs/app/api-reference/functions/use-selected-layout-segments)\r\n */ // Client components API\r\nexport function useSelectedLayoutSegments(parallelRouteKey = 'children') {\r\n    useDynamicRouteParams?.('useSelectedLayoutSegments()');\r\n    const context = useContext(LayoutRouterContext);\r\n    // @ts-expect-error This only happens in `pages`. Type is overwritten in navigation.d.ts\r\n    if (!context) return null;\r\n    // Instrument with Suspense DevTools (dev-only)\r\n    if (process.env.NODE_ENV !== 'production' && 'use' in React) {\r\n        const navigationPromises = use(NavigationPromisesContext);\r\n        if (navigationPromises) {\r\n            const promise = navigationPromises.selectedLayoutSegmentsPromises?.get(parallelRouteKey);\r\n            if (promise) {\r\n                // We should always have a promise here, but if we don't, it's not worth erroring over.\r\n                // We just won't be able to instrument it, but can still provide the value.\r\n                return use(promise);\r\n            }\r\n        }\r\n    }\r\n    return getSelectedLayoutSegmentPath(context.parentTree, parallelRouteKey);\r\n}\r\n/**\r\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\r\n * that lets you read the active route segment **one level below** the Layout it is called from.\r\n *\r\n * @example\r\n * ```ts\r\n * 'use client'\r\n * import { useSelectedLayoutSegment } from 'next/navigation'\r\n *\r\n * export default function ExampleClientComponent() {\r\n *   const segment = useSelectedLayoutSegment()\r\n *\r\n *   return <p>Active segment: {segment}</p>\r\n * }\r\n * ```\r\n *\r\n * Read more: [Next.js Docs: `useSelectedLayoutSegment`](https://nextjs.org/docs/app/api-reference/functions/use-selected-layout-segment)\r\n */ // Client components API\r\nexport function useSelectedLayoutSegment(parallelRouteKey = 'children') {\r\n    useDynamicRouteParams?.('useSelectedLayoutSegment()');\r\n    const navigationPromises = useContext(NavigationPromisesContext);\r\n    const selectedLayoutSegments = useSelectedLayoutSegments(parallelRouteKey);\r\n    // Instrument with Suspense DevTools (dev-only)\r\n    if (process.env.NODE_ENV !== 'production' && navigationPromises && 'use' in React) {\r\n        const promise = navigationPromises.selectedLayoutSegmentPromises?.get(parallelRouteKey);\r\n        if (promise) {\r\n            // We should always have a promise here, but if we don't, it's not worth erroring over.\r\n            // We just won't be able to instrument it, but can still provide the value.\r\n            return use(promise);\r\n        }\r\n    }\r\n    return computeSelectedLayoutSegment(selectedLayoutSegments, parallelRouteKey);\r\n}\r\nexport { unstable_isUnrecognizedActionError } from './unrecognized-action-error';\r\n// Shared components APIs\r\nexport { notFound, forbidden, unauthorized, redirect, permanentRedirect, RedirectType, ReadonlyURLSearchParams, unstable_rethrow } from './navigation.react-server';\r\n\r\n//# sourceMappingURL=navigation.js.map","import React, { use, useMemo } from 'react';\r\nimport { isThenable } from '../../shared/lib/is-thenable';\r\n// The app router state lives outside of React, so we can import the dispatch\r\n// method directly wherever we need it, rather than passing it around via props\r\n// or context.\r\nlet dispatch = null;\r\nexport function dispatchAppRouterAction(action) {\r\n    if (dispatch === null) {\r\n        throw Object.defineProperty(new Error('Internal Next.js error: Router action dispatched before initialization.'), \"__NEXT_ERROR_CODE\", {\r\n            value: \"E668\",\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n    dispatch(action);\r\n}\r\nexport function useActionQueue(actionQueue) {\r\n    const [state, setState] = React.useState(actionQueue.state);\r\n    // Because of a known issue that requires to decode Flight streams inside the\r\n    // render phase, we have to be a bit clever and assign the dispatch method to\r\n    // a module-level variable upon initialization. The useState hook in this\r\n    // module only exists to synchronize state that lives outside of React.\r\n    // Ideally, what we'd do instead is pass the state as a prop to root.render;\r\n    // this is conceptually how we're modeling the app router state, despite the\r\n    // weird implementation details.\r\n    if (process.env.NODE_ENV !== 'production') {\r\n        const { useAppDevRenderingIndicator } = require('../../next-devtools/userspace/use-app-dev-rendering-indicator');\r\n        // eslint-disable-next-line react-hooks/rules-of-hooks\r\n        const appDevRenderingIndicator = useAppDevRenderingIndicator();\r\n        dispatch = (action)=>{\r\n            appDevRenderingIndicator(()=>{\r\n                actionQueue.dispatch(action, setState);\r\n            });\r\n        };\r\n    } else {\r\n        dispatch = (action)=>actionQueue.dispatch(action, setState);\r\n    }\r\n    // When navigating to a non-prefetched route, then App Router state will be\r\n    // blocked until the server responds. We need to transfer the `_debugInfo`\r\n    // from the underlying Flight response onto the top-level promise that is\r\n    // passed to React (via `use`) so that the latency is accurately represented\r\n    // in the React DevTools.\r\n    const stateWithDebugInfo = useMemo(()=>{\r\n        if (isThenable(state)) {\r\n            const debugInfo = [];\r\n            const promiseWithDebugInfo = Promise.resolve(state).then((asyncState)=>{\r\n                if (asyncState.debugInfo !== null) {\r\n                    debugInfo.push(...asyncState.debugInfo);\r\n                }\r\n                return asyncState;\r\n            });\r\n            promiseWithDebugInfo._debugInfo = debugInfo;\r\n            return promiseWithDebugInfo;\r\n        }\r\n        return state;\r\n    }, [\r\n        state\r\n    ]);\r\n    return isThenable(stateWithDebugInfo) ? use(stateWithDebugInfo) : stateWithDebugInfo;\r\n}\r\n\r\n//# sourceMappingURL=use-action-queue.js.map","import { useEffect } from 'react';\r\nimport { createHrefFromUrl } from './router-reducer/create-href-from-url';\r\nexport function handleHardNavError(error) {\r\n    if (error && typeof window !== 'undefined' && window.next.__pendingUrl && createHrefFromUrl(new URL(window.location.href)) !== createHrefFromUrl(window.next.__pendingUrl)) {\r\n        console.error(`Error occurred during navigation, falling back to hard navigation`, error);\r\n        window.location.href = window.next.__pendingUrl.toString();\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nexport function useNavFailureHandler() {\r\n    if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {\r\n        // this if is only for DCE of the feature flag not conditional\r\n        // eslint-disable-next-line react-hooks/rules-of-hooks\r\n        useEffect(()=>{\r\n            const uncaughtExceptionHandler = (evt)=>{\r\n                const error = 'reason' in evt ? evt.reason : evt.error;\r\n                // if we have an unhandled exception/rejection during\r\n                // a navigation we fall back to a hard navigation to\r\n                // attempt recovering to a good state\r\n                handleHardNavError(error);\r\n            };\r\n            window.addEventListener('unhandledrejection', uncaughtExceptionHandler);\r\n            window.addEventListener('error', uncaughtExceptionHandler);\r\n            return ()=>{\r\n                window.removeEventListener('error', uncaughtExceptionHandler);\r\n                window.removeEventListener('unhandledrejection', uncaughtExceptionHandler);\r\n            };\r\n        }, []);\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=nav-failure-handler.js.map","import { normalizeAppPath } from './app-paths';\r\n// order matters here, the first match will be used\r\nexport const INTERCEPTION_ROUTE_MARKERS = [\r\n    '(..)(..)',\r\n    '(.)',\r\n    '(..)',\r\n    '(...)'\r\n];\r\nexport function isInterceptionRouteAppPath(path) {\r\n    // TODO-APP: add more serious validation\r\n    return path.split('/').find((segment)=>INTERCEPTION_ROUTE_MARKERS.find((m)=>segment.startsWith(m))) !== undefined;\r\n}\r\nexport function extractInterceptionRouteInformation(path) {\r\n    let interceptingRoute;\r\n    let marker;\r\n    let interceptedRoute;\r\n    for (const segment of path.split('/')){\r\n        marker = INTERCEPTION_ROUTE_MARKERS.find((m)=>segment.startsWith(m));\r\n        if (marker) {\r\n            ;\r\n            [interceptingRoute, interceptedRoute] = path.split(marker, 2);\r\n            break;\r\n        }\r\n    }\r\n    if (!interceptingRoute || !marker || !interceptedRoute) {\r\n        throw Object.defineProperty(new Error(`Invalid interception route: ${path}. Must be in the format /<intercepting route>/(..|...|..)(..)/<intercepted route>`), \"__NEXT_ERROR_CODE\", {\r\n            value: \"E269\",\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n    interceptingRoute = normalizeAppPath(interceptingRoute) // normalize the path, e.g. /(blog)/feed -> /feed\r\n    ;\r\n    switch(marker){\r\n        case '(.)':\r\n            // (.) indicates that we should match with sibling routes, so we just need to append the intercepted route to the intercepting route\r\n            if (interceptingRoute === '/') {\r\n                interceptedRoute = `/${interceptedRoute}`;\r\n            } else {\r\n                interceptedRoute = interceptingRoute + '/' + interceptedRoute;\r\n            }\r\n            break;\r\n        case '(..)':\r\n            // (..) indicates that we should match at one level up, so we need to remove the last segment of the intercepting route\r\n            if (interceptingRoute === '/') {\r\n                throw Object.defineProperty(new Error(`Invalid interception route: ${path}. Cannot use (..) marker at the root level, use (.) instead.`), \"__NEXT_ERROR_CODE\", {\r\n                    value: \"E207\",\r\n                    enumerable: false,\r\n                    configurable: true\r\n                });\r\n            }\r\n            interceptedRoute = interceptingRoute.split('/').slice(0, -1).concat(interceptedRoute).join('/');\r\n            break;\r\n        case '(...)':\r\n            // (...) will match the route segment in the root directory, so we need to use the root directory to prepend the intercepted route\r\n            interceptedRoute = '/' + interceptedRoute;\r\n            break;\r\n        case '(..)(..)':\r\n            // (..)(..) indicates that we should match at two levels up, so we need to remove the last two segments of the intercepting route\r\n            const splitInterceptingRoute = interceptingRoute.split('/');\r\n            if (splitInterceptingRoute.length <= 2) {\r\n                throw Object.defineProperty(new Error(`Invalid interception route: ${path}. Cannot use (..)(..) marker at the root level or one level up.`), \"__NEXT_ERROR_CODE\", {\r\n                    value: \"E486\",\r\n                    enumerable: false,\r\n                    configurable: true\r\n                });\r\n            }\r\n            interceptedRoute = splitInterceptingRoute.slice(0, -2).concat(interceptedRoute).join('/');\r\n            break;\r\n        default:\r\n            throw Object.defineProperty(new Error('Invariant: unexpected marker'), \"__NEXT_ERROR_CODE\", {\r\n                value: \"E112\",\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n    }\r\n    return {\r\n        interceptingRoute,\r\n        interceptedRoute\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=interception-routes.js.map","/**\r\n * Create a \"Thenable\" that does not resolve. This is used to suspend indefinitely when data is not available yet.\r\n */ export const unresolvedThenable = {\r\n    then: ()=>{}\r\n};\r\n\r\n//# sourceMappingURL=unresolved-thenable.js.map","import { startTransition } from 'react';\r\nimport { ACTION_SERVER_ACTION } from './components/router-reducer/router-reducer-types';\r\nimport { dispatchAppRouterAction } from './components/use-action-queue';\r\nexport async function callServer(actionId, actionArgs) {\r\n    return new Promise((resolve, reject)=>{\r\n        startTransition(()=>{\r\n            dispatchAppRouterAction({\r\n                type: ACTION_SERVER_ACTION,\r\n                actionId,\r\n                actionArgs,\r\n                resolve,\r\n                reject\r\n            });\r\n        });\r\n    });\r\n}\r\n\r\n//# sourceMappingURL=app-call-server.js.map","/**\r\n * For a given page path, this function ensures that there is a leading slash.\r\n * If there is not a leading slash, one is added, otherwise it is noop.\r\n */ export function ensureLeadingSlash(path) {\r\n    return path.startsWith('/') ? path : `/${path}`;\r\n}\r\n\r\n//# sourceMappingURL=ensure-leading-slash.js.map","// This regex contains the bots that we need to do a blocking render for and can't safely stream the response\r\n// due to how they parse the DOM. For example, they might explicitly check for metadata in the `head` tag, so we can't stream metadata tags after the `head` was sent.\r\n// Note: The pattern [\\w-]+-Google captures all Google crawlers with \"-Google\" suffix (e.g., Mediapartners-Google, AdsBot-Google, Storebot-Google)\r\n// as well as crawlers starting with \"Google-\" (e.g., Google-PageRenderer, Google-InspectionTool)\r\nexport const HTML_LIMITED_BOT_UA_RE = /[\\w-]+-Google|Google-[\\w-]+|Chrome-Lighthouse|Slurp|DuckDuckBot|baiduspider|yandex|sogou|bitlybot|tumblr|vkShare|quora link preview|redditbot|ia_archiver|Bingbot|BingPreview|applebot|facebookexternalhit|facebookcatalog|Twitterbot|LinkedInBot|Slackbot|Discordbot|WhatsApp|SkypeUriPreview|Yeti|googleweblight/i;\r\n\r\n//# sourceMappingURL=html-bots.js.map","/**\r\n * Check to see if a value is Thenable.\r\n *\r\n * @param promise the maybe-thenable value\r\n * @returns true if the value is thenable\r\n */ export function isThenable(promise) {\r\n    return promise !== null && typeof promise === 'object' && 'then' in promise && typeof promise.then === 'function';\r\n}\r\n\r\n//# sourceMappingURL=is-thenable.js.map","/**\r\n * This function should be used to rethrow internal Next.js errors so that they can be handled by the framework.\r\n * When wrapping an API that uses errors to interrupt control flow, you should use this function before you do any error handling.\r\n * This function will rethrow the error if it is a Next.js error so it can be handled, otherwise it will do nothing.\r\n *\r\n * Read more: [Next.js Docs: `unstable_rethrow`](https://nextjs.org/docs/app/api-reference/functions/unstable_rethrow)\r\n */ export const unstable_rethrow = typeof window === 'undefined' ? require('./unstable-rethrow.server').unstable_rethrow : require('./unstable-rethrow.browser').unstable_rethrow;\r\n\r\n//# sourceMappingURL=unstable-rethrow.js.map","// http://www.cse.yorku.ca/~oz/hash.html\r\n// More specifically, 32-bit hash via djbxor\r\n// (ref: https://gist.github.com/eplawless/52813b1d8ad9af510d85?permalink_comment_id=3367765#gistcomment-3367765)\r\n// This is due to number type differences between rust for turbopack to js number types,\r\n// where rust does not have easy way to repreesnt js's 53-bit float number type for the matching\r\n// overflow behavior. This is more `correct` in terms of having canonical hash across different runtime / implementation\r\n// as can gaurantee determinstic output from 32bit hash.\r\nexport function djb2Hash(str) {\r\n    let hash = 5381;\r\n    for(let i = 0; i < str.length; i++){\r\n        const char = str.charCodeAt(i);\r\n        hash = (hash << 5) + hash + char & 0xffffffff;\r\n    }\r\n    return hash >>> 0;\r\n}\r\nexport function hexHash(str) {\r\n    return djb2Hash(str).toString(36).slice(0, 5);\r\n}\r\n\r\n//# sourceMappingURL=hash.js.map","import { ensureLeadingSlash } from '../../page-path/ensure-leading-slash';\r\nimport { isGroupSegment } from '../../segment';\r\n/**\r\n * Normalizes an app route so it represents the actual request path. Essentially\r\n * performing the following transformations:\r\n *\r\n * - `/(dashboard)/user/[id]/page` to `/user/[id]`\r\n * - `/(dashboard)/account/page` to `/account`\r\n * - `/user/[id]/page` to `/user/[id]`\r\n * - `/account/page` to `/account`\r\n * - `/page` to `/`\r\n * - `/(dashboard)/user/[id]/route` to `/user/[id]`\r\n * - `/(dashboard)/account/route` to `/account`\r\n * - `/user/[id]/route` to `/user/[id]`\r\n * - `/account/route` to `/account`\r\n * - `/route` to `/`\r\n * - `/` to `/`\r\n *\r\n * @param route the app route to normalize\r\n * @returns the normalized pathname\r\n */ export function normalizeAppPath(route) {\r\n    return ensureLeadingSlash(route.split('/').reduce((pathname, segment, index, segments)=>{\r\n        // Empty segments are ignored.\r\n        if (!segment) {\r\n            return pathname;\r\n        }\r\n        // Groups are ignored.\r\n        if (isGroupSegment(segment)) {\r\n            return pathname;\r\n        }\r\n        // Parallel segments are ignored.\r\n        if (segment[0] === '@') {\r\n            return pathname;\r\n        }\r\n        // The last segment (if it's a leaf) should be ignored.\r\n        if ((segment === 'page' || segment === 'route') && index === segments.length - 1) {\r\n            return pathname;\r\n        }\r\n        return `${pathname}/${segment}`;\r\n    }, ''));\r\n}\r\n/**\r\n * Strips the `.rsc` extension if it's in the pathname.\r\n * Since this function is used on full urls it checks `?` for searchParams handling.\r\n */ export function normalizeRscURL(url) {\r\n    return url.replace(/\\.rsc($|\\?)/, // $1 ensures `?` is preserved\r\n    '$1');\r\n}\r\n\r\n//# sourceMappingURL=app-paths.js.map","'use client'\n\nimport React, { useContext, type JSX } from 'react'\nimport { TemplateContext } from '../../shared/lib/app-router-context.shared-runtime'\n\nexport default function RenderFromTemplateContext(): JSX.Element {\n  const children = useContext(TemplateContext)\n  return <>{children}</>\n}\n","import * as React from 'react';\r\nconst errorRef = {\r\n    current: null\r\n};\r\n// React.cache is currently only available in canary/experimental React channels.\r\nconst cache = typeof React.cache === 'function' ? React.cache : (fn)=>fn;\r\n// When Cache Components is enabled, we record these as errors so that they\r\n// are captured by the dev overlay as it's more critical to fix these\r\n// when enabled.\r\nconst logErrorOrWarn = process.env.__NEXT_CACHE_COMPONENTS ? console.error : console.warn;\r\n// We don't want to dedupe across requests.\r\n// The developer might've just attempted to fix the warning so we should warn again if it still happens.\r\nconst flushCurrentErrorIfNew = cache(// eslint-disable-next-line @typescript-eslint/no-unused-vars -- cache key\r\n(key)=>{\r\n    try {\r\n        logErrorOrWarn(errorRef.current);\r\n    } finally{\r\n        errorRef.current = null;\r\n    }\r\n});\r\n/**\r\n * Creates a function that logs an error message that is deduped by the userland\r\n * callsite.\r\n * This requires no indirection between the call of this function and the userland\r\n * callsite i.e. there's only a single library frame above this.\r\n * Do not use on the Client where sourcemaps and ignore listing might be enabled.\r\n * Only use that for warnings need a fix independent of the callstack.\r\n *\r\n * @param getMessage\r\n * @returns\r\n */ export function createDedupedByCallsiteServerErrorLoggerDev(getMessage) {\r\n    return function logDedupedError(...args) {\r\n        const message = getMessage(...args);\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            var _stack;\r\n            const callStackFrames = (_stack = new Error().stack) == null ? void 0 : _stack.split('\\n');\r\n            if (callStackFrames === undefined || callStackFrames.length < 4) {\r\n                logErrorOrWarn(message);\r\n            } else {\r\n                // Error:\r\n                //   logDedupedError\r\n                //   asyncApiBeingAccessedSynchronously\r\n                //   <userland callsite>\r\n                // TODO: This breaks if sourcemaps with ignore lists are enabled.\r\n                const key = callStackFrames[4];\r\n                errorRef.current = message;\r\n                flushCurrentErrorIfNew(key);\r\n            }\r\n        } else {\r\n            logErrorOrWarn(message);\r\n        }\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=create-deduped-by-callsite-server-error-logger.js.map","// This regex will have fast negatives meaning valid identifiers may not pass\r\n// this test. However this is only used during static generation to provide hints\r\n// about why a page bailed out of some or all prerendering and we can use bracket notation\r\n// for example while `_` is a valid identifier it's ok to print `searchParams['_']`\r\n// even if this would have been fine too `searchParams._`\r\nconst isDefinitelyAValidIdentifier = /^[A-Za-z_$][A-Za-z0-9_$]*$/;\r\nexport function describeStringPropertyAccess(target, prop) {\r\n    if (isDefinitelyAValidIdentifier.test(prop)) {\r\n        return `\\`${target}.${prop}\\``;\r\n    }\r\n    return `\\`${target}[${JSON.stringify(prop)}]\\``;\r\n}\r\nexport function describeHasCheckingStringProperty(target, prop) {\r\n    const stringifiedProp = JSON.stringify(prop);\r\n    return `\\`Reflect.has(${target}, ${stringifiedProp})\\`, \\`${stringifiedProp} in ${target}\\`, or similar`;\r\n}\r\nexport const wellKnownProperties = new Set([\r\n    'hasOwnProperty',\r\n    'isPrototypeOf',\r\n    'propertyIsEnumerable',\r\n    'toString',\r\n    'valueOf',\r\n    'toLocaleString',\r\n    // Promise prototype\r\n    'then',\r\n    'catch',\r\n    'finally',\r\n    // React Promise extension\r\n    'status',\r\n    // 'value',\r\n    // 'error',\r\n    // React introspection\r\n    'displayName',\r\n    '_debugInfo',\r\n    // Common tested properties\r\n    'toJSON',\r\n    '$$typeof',\r\n    '__esModule'\r\n]);\r\n\r\n//# sourceMappingURL=reflect-utils.js.map","export class ReflectAdapter {\r\n    static get(target, prop, receiver) {\r\n        const value = Reflect.get(target, prop, receiver);\r\n        if (typeof value === 'function') {\r\n            return value.bind(target);\r\n        }\r\n        return value;\r\n    }\r\n    static set(target, prop, value, receiver) {\r\n        return Reflect.set(target, prop, value, receiver);\r\n    }\r\n    static has(target, prop) {\r\n        return Reflect.has(target, prop);\r\n    }\r\n    static deleteProperty(target, prop) {\r\n        return Reflect.deleteProperty(target, prop);\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=reflect.js.map","import { StaticGenBailoutError } from '../../client/components/static-generation-bailout';\r\nimport { afterTaskAsyncStorage } from '../app-render/after-task-async-storage.external';\r\nexport function throwWithStaticGenerationBailoutErrorWithDynamicError(route, expression) {\r\n    throw Object.defineProperty(new StaticGenBailoutError(`Route ${route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), \"__NEXT_ERROR_CODE\", {\r\n        value: \"E543\",\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n}\r\nexport function throwForSearchParamsAccessInUseCache(workStore, constructorOpt) {\r\n    const error = Object.defineProperty(new Error(`Route ${workStore.route} used \\`searchParams\\` inside \"use cache\". Accessing dynamic request data inside a cache scope is not supported. If you need some search params inside a cached function await \\`searchParams\\` outside of the cached function and pass only the required search params as arguments to the cached function. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`), \"__NEXT_ERROR_CODE\", {\r\n        value: \"E842\",\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Error.captureStackTrace(error, constructorOpt);\r\n    workStore.invalidDynamicUsageError ??= error;\r\n    throw error;\r\n}\r\nexport function isRequestAPICallableInsideAfter() {\r\n    const afterTaskStore = afterTaskAsyncStorage.getStore();\r\n    return (afterTaskStore == null ? void 0 : afterTaskStore.rootTaskSpawnPhase) === 'action';\r\n}\r\n\r\n//# sourceMappingURL=utils.js.map","import { ReflectAdapter } from '../web/spec-extension/adapters/reflect';\r\nimport { throwToInterruptStaticGeneration, postponeWithTracking, annotateDynamicAccess, delayUntilRuntimeStage } from '../app-render/dynamic-rendering';\r\nimport { workUnitAsyncStorage, throwInvariantForMissingStore } from '../app-render/work-unit-async-storage.external';\r\nimport { InvariantError } from '../../shared/lib/invariant-error';\r\nimport { makeDevtoolsIOAwarePromise, makeHangingPromise } from '../dynamic-rendering-utils';\r\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger';\r\nimport { describeStringPropertyAccess, describeHasCheckingStringProperty, wellKnownProperties } from '../../shared/lib/utils/reflect-utils';\r\nimport { throwWithStaticGenerationBailoutErrorWithDynamicError, throwForSearchParamsAccessInUseCache } from './utils';\r\nimport { RenderStage } from '../app-render/staged-rendering';\r\nexport function createSearchParamsFromClient(underlyingSearchParams, workStore) {\r\n    const workUnitStore = workUnitAsyncStorage.getStore();\r\n    if (workUnitStore) {\r\n        switch(workUnitStore.type){\r\n            case 'prerender':\r\n            case 'prerender-client':\r\n            case 'prerender-ppr':\r\n            case 'prerender-legacy':\r\n                return createStaticPrerenderSearchParams(workStore, workUnitStore);\r\n            case 'prerender-runtime':\r\n                throw Object.defineProperty(new InvariantError('createSearchParamsFromClient should not be called in a runtime prerender.'), \"__NEXT_ERROR_CODE\", {\r\n                    value: \"E769\",\r\n                    enumerable: false,\r\n                    configurable: true\r\n                });\r\n            case 'cache':\r\n            case 'private-cache':\r\n            case 'unstable-cache':\r\n                throw Object.defineProperty(new InvariantError('createSearchParamsFromClient should not be called in cache contexts.'), \"__NEXT_ERROR_CODE\", {\r\n                    value: \"E739\",\r\n                    enumerable: false,\r\n                    configurable: true\r\n                });\r\n            case 'request':\r\n                return createRenderSearchParams(underlyingSearchParams, workStore, workUnitStore);\r\n            default:\r\n                workUnitStore;\r\n        }\r\n    }\r\n    throwInvariantForMissingStore();\r\n}\r\n// generateMetadata always runs in RSC context so it is equivalent to a Server Page Component\r\nexport const createServerSearchParamsForMetadata = createServerSearchParamsForServerPage;\r\nexport function createServerSearchParamsForServerPage(underlyingSearchParams, workStore) {\r\n    const workUnitStore = workUnitAsyncStorage.getStore();\r\n    if (workUnitStore) {\r\n        switch(workUnitStore.type){\r\n            case 'prerender':\r\n            case 'prerender-client':\r\n            case 'prerender-ppr':\r\n            case 'prerender-legacy':\r\n                return createStaticPrerenderSearchParams(workStore, workUnitStore);\r\n            case 'cache':\r\n            case 'private-cache':\r\n            case 'unstable-cache':\r\n                throw Object.defineProperty(new InvariantError('createServerSearchParamsForServerPage should not be called in cache contexts.'), \"__NEXT_ERROR_CODE\", {\r\n                    value: \"E747\",\r\n                    enumerable: false,\r\n                    configurable: true\r\n                });\r\n            case 'prerender-runtime':\r\n                return createRuntimePrerenderSearchParams(underlyingSearchParams, workUnitStore);\r\n            case 'request':\r\n                return createRenderSearchParams(underlyingSearchParams, workStore, workUnitStore);\r\n            default:\r\n                workUnitStore;\r\n        }\r\n    }\r\n    throwInvariantForMissingStore();\r\n}\r\nexport function createPrerenderSearchParamsForClientPage(workStore) {\r\n    if (workStore.forceStatic) {\r\n        // When using forceStatic we override all other logic and always just return an empty\r\n        // dictionary object.\r\n        return Promise.resolve({});\r\n    }\r\n    const workUnitStore = workUnitAsyncStorage.getStore();\r\n    if (workUnitStore) {\r\n        switch(workUnitStore.type){\r\n            case 'prerender':\r\n            case 'prerender-client':\r\n                // We're prerendering in a mode that aborts (cacheComponents) and should stall\r\n                // the promise to ensure the RSC side is considered dynamic\r\n                return makeHangingPromise(workUnitStore.renderSignal, workStore.route, '`searchParams`');\r\n            case 'prerender-runtime':\r\n                throw Object.defineProperty(new InvariantError('createPrerenderSearchParamsForClientPage should not be called in a runtime prerender.'), \"__NEXT_ERROR_CODE\", {\r\n                    value: \"E768\",\r\n                    enumerable: false,\r\n                    configurable: true\r\n                });\r\n            case 'cache':\r\n            case 'private-cache':\r\n            case 'unstable-cache':\r\n                throw Object.defineProperty(new InvariantError('createPrerenderSearchParamsForClientPage should not be called in cache contexts.'), \"__NEXT_ERROR_CODE\", {\r\n                    value: \"E746\",\r\n                    enumerable: false,\r\n                    configurable: true\r\n                });\r\n            case 'prerender-ppr':\r\n            case 'prerender-legacy':\r\n            case 'request':\r\n                return Promise.resolve({});\r\n            default:\r\n                workUnitStore;\r\n        }\r\n    }\r\n    throwInvariantForMissingStore();\r\n}\r\nfunction createStaticPrerenderSearchParams(workStore, prerenderStore) {\r\n    if (workStore.forceStatic) {\r\n        // When using forceStatic we override all other logic and always just return an empty\r\n        // dictionary object.\r\n        return Promise.resolve({});\r\n    }\r\n    switch(prerenderStore.type){\r\n        case 'prerender':\r\n        case 'prerender-client':\r\n            // We are in a cacheComponents (PPR or otherwise) prerender\r\n            return makeHangingSearchParams(workStore, prerenderStore);\r\n        case 'prerender-ppr':\r\n        case 'prerender-legacy':\r\n            // We are in a legacy static generation and need to interrupt the\r\n            // prerender when search params are accessed.\r\n            return makeErroringSearchParams(workStore, prerenderStore);\r\n        default:\r\n            return prerenderStore;\r\n    }\r\n}\r\nfunction createRuntimePrerenderSearchParams(underlyingSearchParams, workUnitStore) {\r\n    return delayUntilRuntimeStage(workUnitStore, makeUntrackedSearchParams(underlyingSearchParams));\r\n}\r\nfunction createRenderSearchParams(underlyingSearchParams, workStore, requestStore) {\r\n    if (workStore.forceStatic) {\r\n        // When using forceStatic we override all other logic and always just return an empty\r\n        // dictionary object.\r\n        return Promise.resolve({});\r\n    } else {\r\n        if (process.env.NODE_ENV === 'development') {\r\n            // Semantically we only need the dev tracking when running in `next dev`\r\n            // but since you would never use next dev with production NODE_ENV we use this\r\n            // as a proxy so we can statically exclude this code from production builds.\r\n            return makeUntrackedSearchParamsWithDevWarnings(underlyingSearchParams, workStore, requestStore);\r\n        } else {\r\n            return makeUntrackedSearchParams(underlyingSearchParams);\r\n        }\r\n    }\r\n}\r\nconst CachedSearchParams = new WeakMap();\r\nconst CachedSearchParamsForUseCache = new WeakMap();\r\nfunction makeHangingSearchParams(workStore, prerenderStore) {\r\n    const cachedSearchParams = CachedSearchParams.get(prerenderStore);\r\n    if (cachedSearchParams) {\r\n        return cachedSearchParams;\r\n    }\r\n    const promise = makeHangingPromise(prerenderStore.renderSignal, workStore.route, '`searchParams`');\r\n    const proxiedPromise = new Proxy(promise, {\r\n        get (target, prop, receiver) {\r\n            if (Object.hasOwn(promise, prop)) {\r\n                // The promise has this property directly. we must return it.\r\n                // We know it isn't a dynamic access because it can only be something\r\n                // that was previously written to the promise and thus not an underlying searchParam value\r\n                return ReflectAdapter.get(target, prop, receiver);\r\n            }\r\n            switch(prop){\r\n                case 'then':\r\n                    {\r\n                        const expression = '`await searchParams`, `searchParams.then`, or similar';\r\n                        annotateDynamicAccess(expression, prerenderStore);\r\n                        return ReflectAdapter.get(target, prop, receiver);\r\n                    }\r\n                case 'status':\r\n                    {\r\n                        const expression = '`use(searchParams)`, `searchParams.status`, or similar';\r\n                        annotateDynamicAccess(expression, prerenderStore);\r\n                        return ReflectAdapter.get(target, prop, receiver);\r\n                    }\r\n                default:\r\n                    {\r\n                        return ReflectAdapter.get(target, prop, receiver);\r\n                    }\r\n            }\r\n        }\r\n    });\r\n    CachedSearchParams.set(prerenderStore, proxiedPromise);\r\n    return proxiedPromise;\r\n}\r\nfunction makeErroringSearchParams(workStore, prerenderStore) {\r\n    const cachedSearchParams = CachedSearchParams.get(workStore);\r\n    if (cachedSearchParams) {\r\n        return cachedSearchParams;\r\n    }\r\n    const underlyingSearchParams = {};\r\n    // For search params we don't construct a ReactPromise because we want to interrupt\r\n    // rendering on any property access that was not set from outside and so we only want\r\n    // to have properties like value and status if React sets them.\r\n    const promise = Promise.resolve(underlyingSearchParams);\r\n    const proxiedPromise = new Proxy(promise, {\r\n        get (target, prop, receiver) {\r\n            if (Object.hasOwn(promise, prop)) {\r\n                // The promise has this property directly. we must return it.\r\n                // We know it isn't a dynamic access because it can only be something\r\n                // that was previously written to the promise and thus not an underlying searchParam value\r\n                return ReflectAdapter.get(target, prop, receiver);\r\n            }\r\n            if (typeof prop === 'string' && prop === 'then') {\r\n                const expression = '`await searchParams`, `searchParams.then`, or similar';\r\n                if (workStore.dynamicShouldError) {\r\n                    throwWithStaticGenerationBailoutErrorWithDynamicError(workStore.route, expression);\r\n                } else if (prerenderStore.type === 'prerender-ppr') {\r\n                    // PPR Prerender (no cacheComponents)\r\n                    postponeWithTracking(workStore.route, expression, prerenderStore.dynamicTracking);\r\n                } else {\r\n                    // Legacy Prerender\r\n                    throwToInterruptStaticGeneration(expression, workStore, prerenderStore);\r\n                }\r\n            }\r\n            return ReflectAdapter.get(target, prop, receiver);\r\n        }\r\n    });\r\n    CachedSearchParams.set(workStore, proxiedPromise);\r\n    return proxiedPromise;\r\n}\r\n/**\r\n * This is a variation of `makeErroringSearchParams` that always throws an\r\n * error on access, because accessing searchParams inside of `\"use cache\"` is\r\n * not allowed.\r\n */ export function makeErroringSearchParamsForUseCache(workStore) {\r\n    const cachedSearchParams = CachedSearchParamsForUseCache.get(workStore);\r\n    if (cachedSearchParams) {\r\n        return cachedSearchParams;\r\n    }\r\n    const promise = Promise.resolve({});\r\n    const proxiedPromise = new Proxy(promise, {\r\n        get: function get(target, prop, receiver) {\r\n            if (Object.hasOwn(promise, prop)) {\r\n                // The promise has this property directly. we must return it. We know it\r\n                // isn't a dynamic access because it can only be something that was\r\n                // previously written to the promise and thus not an underlying\r\n                // searchParam value\r\n                return ReflectAdapter.get(target, prop, receiver);\r\n            }\r\n            if (typeof prop === 'string' && (prop === 'then' || !wellKnownProperties.has(prop))) {\r\n                throwForSearchParamsAccessInUseCache(workStore, get);\r\n            }\r\n            return ReflectAdapter.get(target, prop, receiver);\r\n        }\r\n    });\r\n    CachedSearchParamsForUseCache.set(workStore, proxiedPromise);\r\n    return proxiedPromise;\r\n}\r\nfunction makeUntrackedSearchParams(underlyingSearchParams) {\r\n    const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);\r\n    if (cachedSearchParams) {\r\n        return cachedSearchParams;\r\n    }\r\n    const promise = Promise.resolve(underlyingSearchParams);\r\n    CachedSearchParams.set(underlyingSearchParams, promise);\r\n    return promise;\r\n}\r\nfunction makeUntrackedSearchParamsWithDevWarnings(underlyingSearchParams, workStore, requestStore) {\r\n    if (requestStore.asyncApiPromises) {\r\n        // Do not cache the resulting promise. If we do, we'll only show the first \"awaited at\"\r\n        // across all segments that receive searchParams.\r\n        return makeUntrackedSearchParamsWithDevWarningsImpl(underlyingSearchParams, workStore, requestStore);\r\n    } else {\r\n        const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);\r\n        if (cachedSearchParams) {\r\n            return cachedSearchParams;\r\n        }\r\n        const promise = makeUntrackedSearchParamsWithDevWarningsImpl(underlyingSearchParams, workStore, requestStore);\r\n        CachedSearchParams.set(requestStore, promise);\r\n        return promise;\r\n    }\r\n}\r\nfunction makeUntrackedSearchParamsWithDevWarningsImpl(underlyingSearchParams, workStore, requestStore) {\r\n    const promiseInitialized = {\r\n        current: false\r\n    };\r\n    const proxiedUnderlying = instrumentSearchParamsObjectWithDevWarnings(underlyingSearchParams, workStore, promiseInitialized);\r\n    let promise;\r\n    if (requestStore.asyncApiPromises) {\r\n        // We wrap each instance of searchParams in a `new Promise()`.\r\n        // This is important when all awaits are in third party which would otherwise\r\n        // track all the way to the internal params.\r\n        const sharedSearchParamsParent = requestStore.asyncApiPromises.sharedSearchParamsParent;\r\n        promise = new Promise((resolve, reject)=>{\r\n            sharedSearchParamsParent.then(()=>resolve(proxiedUnderlying), reject);\r\n        });\r\n        // @ts-expect-error\r\n        promise.displayName = 'searchParams';\r\n    } else {\r\n        promise = makeDevtoolsIOAwarePromise(proxiedUnderlying, requestStore, RenderStage.Runtime);\r\n    }\r\n    promise.then(()=>{\r\n        promiseInitialized.current = true;\r\n    }, // If we're in staged rendering, this promise will reject if the render\r\n    // is aborted before it can reach the runtime stage.\r\n    // In that case, we have to prevent an unhandled rejection from the promise\r\n    // created by this `.then()` call.\r\n    // This does not affect the `promiseInitialized` logic above,\r\n    // because `proxiedUnderlying` will not be used to resolve the promise,\r\n    // so there's no risk of any of its properties being accessed and triggering\r\n    // an undesireable warning.\r\n    ignoreReject);\r\n    return instrumentSearchParamsPromiseWithDevWarnings(underlyingSearchParams, promise, workStore);\r\n}\r\nfunction ignoreReject() {}\r\nfunction instrumentSearchParamsObjectWithDevWarnings(underlyingSearchParams, workStore, promiseInitialized) {\r\n    // We have an unfortunate sequence of events that requires this initialization logic. We want to instrument the underlying\r\n    // searchParams object to detect if you are accessing values in dev. This is used for warnings and for things like the static prerender\r\n    // indicator. However when we pass this proxy to our Promise.resolve() below the VM checks if the resolved value is a promise by looking\r\n    // at the `.then` property. To our dynamic tracking logic this is indistinguishable from a `then` searchParam and so we would normally trigger\r\n    // dynamic tracking. However we know that this .then is not real dynamic access, it's just how thenables resolve in sequence. So we introduce\r\n    // this initialization concept so we omit the dynamic check until after we've constructed our resolved promise.\r\n    return new Proxy(underlyingSearchParams, {\r\n        get (target, prop, receiver) {\r\n            if (typeof prop === 'string' && promiseInitialized.current) {\r\n                if (workStore.dynamicShouldError) {\r\n                    const expression = describeStringPropertyAccess('searchParams', prop);\r\n                    throwWithStaticGenerationBailoutErrorWithDynamicError(workStore.route, expression);\r\n                }\r\n            }\r\n            return ReflectAdapter.get(target, prop, receiver);\r\n        },\r\n        has (target, prop) {\r\n            if (typeof prop === 'string') {\r\n                if (workStore.dynamicShouldError) {\r\n                    const expression = describeHasCheckingStringProperty('searchParams', prop);\r\n                    throwWithStaticGenerationBailoutErrorWithDynamicError(workStore.route, expression);\r\n                }\r\n            }\r\n            return Reflect.has(target, prop);\r\n        },\r\n        ownKeys (target) {\r\n            if (workStore.dynamicShouldError) {\r\n                const expression = '`{...searchParams}`, `Object.keys(searchParams)`, or similar';\r\n                throwWithStaticGenerationBailoutErrorWithDynamicError(workStore.route, expression);\r\n            }\r\n            return Reflect.ownKeys(target);\r\n        }\r\n    });\r\n}\r\nfunction instrumentSearchParamsPromiseWithDevWarnings(underlyingSearchParams, promise, workStore) {\r\n    // Track which properties we should warn for.\r\n    const proxiedProperties = new Set();\r\n    Object.keys(underlyingSearchParams).forEach((prop)=>{\r\n        if (wellKnownProperties.has(prop)) {\r\n        // These properties cannot be shadowed because they need to be the\r\n        // true underlying value for Promises to work correctly at runtime\r\n        } else {\r\n            proxiedProperties.add(prop);\r\n        }\r\n    });\r\n    return new Proxy(promise, {\r\n        get (target, prop, receiver) {\r\n            if (prop === 'then' && workStore.dynamicShouldError) {\r\n                const expression = '`searchParams.then`';\r\n                throwWithStaticGenerationBailoutErrorWithDynamicError(workStore.route, expression);\r\n            }\r\n            if (typeof prop === 'string') {\r\n                if (!wellKnownProperties.has(prop) && (proxiedProperties.has(prop) || // We are accessing a property that doesn't exist on the promise nor\r\n                // the underlying searchParams.\r\n                Reflect.has(target, prop) === false)) {\r\n                    const expression = describeStringPropertyAccess('searchParams', prop);\r\n                    warnForSyncAccess(workStore.route, expression);\r\n                }\r\n            }\r\n            return ReflectAdapter.get(target, prop, receiver);\r\n        },\r\n        set (target, prop, value, receiver) {\r\n            if (typeof prop === 'string') {\r\n                proxiedProperties.delete(prop);\r\n            }\r\n            return Reflect.set(target, prop, value, receiver);\r\n        },\r\n        has (target, prop) {\r\n            if (typeof prop === 'string') {\r\n                if (!wellKnownProperties.has(prop) && (proxiedProperties.has(prop) || // We are accessing a property that doesn't exist on the promise nor\r\n                // the underlying searchParams.\r\n                Reflect.has(target, prop) === false)) {\r\n                    const expression = describeHasCheckingStringProperty('searchParams', prop);\r\n                    warnForSyncAccess(workStore.route, expression);\r\n                }\r\n            }\r\n            return Reflect.has(target, prop);\r\n        },\r\n        ownKeys (target) {\r\n            const expression = '`Object.keys(searchParams)` or similar';\r\n            warnForSyncAccess(workStore.route, expression);\r\n            return Reflect.ownKeys(target);\r\n        }\r\n    });\r\n}\r\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(createSearchAccessError);\r\nfunction createSearchAccessError(route, expression) {\r\n    const prefix = route ? `Route \"${route}\" ` : 'This route ';\r\n    return Object.defineProperty(new Error(`${prefix}used ${expression}. ` + `\\`searchParams\\` is a Promise and must be unwrapped with \\`await\\` or \\`React.use()\\` before accessing its properties. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`), \"__NEXT_ERROR_CODE\", {\r\n        value: \"E848\",\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n}\r\n\r\n//# sourceMappingURL=search-params.js.map","import {\n  workAsyncStorage,\n  type WorkStore,\n} from '../app-render/work-async-storage.external'\nimport type { OpaqueFallbackRouteParams } from './fallback-params'\n\nimport { ReflectAdapter } from '../web/spec-extension/adapters/reflect'\nimport {\n  throwToInterruptStaticGeneration,\n  postponeWithTracking,\n  delayUntilRuntimeStage,\n} from '../app-render/dynamic-rendering'\n\nimport {\n  workUnitAsyncStorage,\n  type PrerenderStorePPR,\n  type PrerenderStoreLegacy,\n  type StaticPrerenderStoreModern,\n  type StaticPrerenderStore,\n  throwInvariantForMissingStore,\n  type PrerenderStoreModernRuntime,\n  type RequestStore,\n} from '../app-render/work-unit-async-storage.external'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport {\n  describeStringPropertyAccess,\n  wellKnownProperties,\n} from '../../shared/lib/utils/reflect-utils'\nimport {\n  makeDevtoolsIOAwarePromise,\n  makeHangingPromise,\n} from '../dynamic-rendering-utils'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\nimport { dynamicAccessAsyncStorage } from '../app-render/dynamic-access-async-storage.external'\nimport { RenderStage } from '../app-render/staged-rendering'\n\nexport type ParamValue = string | Array<string> | undefined\nexport type Params = Record<string, ParamValue>\n\nexport function createParamsFromClient(\n  underlyingParams: Params,\n  workStore: WorkStore\n): Promise<Params> {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createStaticPrerenderParams(\n          underlyingParams,\n          workStore,\n          workUnitStore\n        )\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        throw new InvariantError(\n          'createParamsFromClient should not be called in cache contexts.'\n        )\n      case 'prerender-runtime':\n        throw new InvariantError(\n          'createParamsFromClient should not be called in a runtime prerender.'\n        )\n      case 'request':\n        if (process.env.NODE_ENV === 'development') {\n          // Semantically we only need the dev tracking when running in `next dev`\n          // but since you would never use next dev with production NODE_ENV we use this\n          // as a proxy so we can statically exclude this code from production builds.\n          const devFallbackParams = workUnitStore.devFallbackParams\n          return createRenderParamsInDev(\n            underlyingParams,\n            devFallbackParams,\n            workStore,\n            workUnitStore\n          )\n        } else {\n          return createRenderParamsInProd(underlyingParams)\n        }\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  throwInvariantForMissingStore()\n}\n\n// generateMetadata always runs in RSC context so it is equivalent to a Server Page Component\nexport type CreateServerParamsForMetadata = typeof createServerParamsForMetadata\nexport const createServerParamsForMetadata = createServerParamsForServerSegment\n\n// routes always runs in RSC context so it is equivalent to a Server Page Component\nexport function createServerParamsForRoute(\n  underlyingParams: Params,\n  workStore: WorkStore\n): Promise<Params> {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createStaticPrerenderParams(\n          underlyingParams,\n          workStore,\n          workUnitStore\n        )\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        throw new InvariantError(\n          'createServerParamsForRoute should not be called in cache contexts.'\n        )\n      case 'prerender-runtime':\n        return createRuntimePrerenderParams(underlyingParams, workUnitStore)\n      case 'request':\n        if (process.env.NODE_ENV === 'development') {\n          // Semantically we only need the dev tracking when running in `next dev`\n          // but since you would never use next dev with production NODE_ENV we use this\n          // as a proxy so we can statically exclude this code from production builds.\n          const devFallbackParams = workUnitStore.devFallbackParams\n          return createRenderParamsInDev(\n            underlyingParams,\n            devFallbackParams,\n            workStore,\n            workUnitStore\n          )\n        } else {\n          return createRenderParamsInProd(underlyingParams)\n        }\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  throwInvariantForMissingStore()\n}\n\nexport function createServerParamsForServerSegment(\n  underlyingParams: Params,\n  workStore: WorkStore\n): Promise<Params> {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createStaticPrerenderParams(\n          underlyingParams,\n          workStore,\n          workUnitStore\n        )\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        throw new InvariantError(\n          'createServerParamsForServerSegment should not be called in cache contexts.'\n        )\n      case 'prerender-runtime':\n        return createRuntimePrerenderParams(underlyingParams, workUnitStore)\n      case 'request':\n        if (process.env.NODE_ENV === 'development') {\n          // Semantically we only need the dev tracking when running in `next dev`\n          // but since you would never use next dev with production NODE_ENV we use this\n          // as a proxy so we can statically exclude this code from production builds.\n          const devFallbackParams = workUnitStore.devFallbackParams\n          return createRenderParamsInDev(\n            underlyingParams,\n            devFallbackParams,\n            workStore,\n            workUnitStore\n          )\n        } else {\n          return createRenderParamsInProd(underlyingParams)\n        }\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  throwInvariantForMissingStore()\n}\n\nexport function createPrerenderParamsForClientSegment(\n  underlyingParams: Params\n): Promise<Params> {\n  const workStore = workAsyncStorage.getStore()\n  if (!workStore) {\n    throw new InvariantError(\n      'Missing workStore in createPrerenderParamsForClientSegment'\n    )\n  }\n\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n        const fallbackParams = workUnitStore.fallbackRouteParams\n        if (fallbackParams) {\n          for (let key in underlyingParams) {\n            if (fallbackParams.has(key)) {\n              // This params object has one or more fallback params, so we need\n              // to consider the awaiting of this params object \"dynamic\". Since\n              // we are in cacheComponents mode we encode this as a promise that never\n              // resolves.\n              return makeHangingPromise(\n                workUnitStore.renderSignal,\n                workStore.route,\n                '`params`'\n              )\n            }\n          }\n        }\n        break\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        throw new InvariantError(\n          'createPrerenderParamsForClientSegment should not be called in cache contexts.'\n        )\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n      case 'prerender-runtime':\n      case 'request':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  // We're prerendering in a mode that does not abort. We resolve the promise without\n  // any tracking because we're just transporting a value from server to client where the tracking\n  // will be applied.\n  return Promise.resolve(underlyingParams)\n}\n\nfunction createStaticPrerenderParams(\n  underlyingParams: Params,\n  workStore: WorkStore,\n  prerenderStore: StaticPrerenderStore\n): Promise<Params> {\n  switch (prerenderStore.type) {\n    case 'prerender':\n    case 'prerender-client': {\n      const fallbackParams = prerenderStore.fallbackRouteParams\n      if (fallbackParams) {\n        for (const key in underlyingParams) {\n          if (fallbackParams.has(key)) {\n            // This params object has one or more fallback params, so we need\n            // to consider the awaiting of this params object \"dynamic\". Since\n            // we are in cacheComponents mode we encode this as a promise that never\n            // resolves.\n            return makeHangingParams(\n              underlyingParams,\n              workStore,\n              prerenderStore\n            )\n          }\n        }\n      }\n      break\n    }\n    case 'prerender-ppr': {\n      const fallbackParams = prerenderStore.fallbackRouteParams\n      if (fallbackParams) {\n        for (const key in underlyingParams) {\n          if (fallbackParams.has(key)) {\n            return makeErroringParams(\n              underlyingParams,\n              fallbackParams,\n              workStore,\n              prerenderStore\n            )\n          }\n        }\n      }\n      break\n    }\n    case 'prerender-legacy':\n      break\n    default:\n      prerenderStore satisfies never\n  }\n\n  return makeUntrackedParams(underlyingParams)\n}\n\nfunction createRuntimePrerenderParams(\n  underlyingParams: Params,\n  workUnitStore: PrerenderStoreModernRuntime\n): Promise<Params> {\n  return delayUntilRuntimeStage(\n    workUnitStore,\n    makeUntrackedParams(underlyingParams)\n  )\n}\n\nfunction createRenderParamsInProd(underlyingParams: Params): Promise<Params> {\n  return makeUntrackedParams(underlyingParams)\n}\n\nfunction createRenderParamsInDev(\n  underlyingParams: Params,\n  devFallbackParams: OpaqueFallbackRouteParams | null | undefined,\n  workStore: WorkStore,\n  requestStore: RequestStore\n): Promise<Params> {\n  let hasFallbackParams = false\n  if (devFallbackParams) {\n    for (let key in underlyingParams) {\n      if (devFallbackParams.has(key)) {\n        hasFallbackParams = true\n        break\n      }\n    }\n  }\n\n  return makeDynamicallyTrackedParamsWithDevWarnings(\n    underlyingParams,\n    hasFallbackParams,\n    workStore,\n    requestStore\n  )\n}\n\ninterface CacheLifetime {}\nconst CachedParams = new WeakMap<CacheLifetime, Promise<Params>>()\n\nconst fallbackParamsProxyHandler: ProxyHandler<Promise<Params>> = {\n  get: function get(target, prop, receiver) {\n    if (prop === 'then' || prop === 'catch' || prop === 'finally') {\n      const originalMethod = ReflectAdapter.get(target, prop, receiver)\n\n      return {\n        [prop]: (...args: unknown[]) => {\n          const store = dynamicAccessAsyncStorage.getStore()\n\n          if (store) {\n            store.abortController.abort(\n              new Error(`Accessed fallback \\`params\\` during prerendering.`)\n            )\n          }\n\n          return new Proxy(\n            originalMethod.apply(target, args),\n            fallbackParamsProxyHandler\n          )\n        },\n      }[prop]\n    }\n\n    return ReflectAdapter.get(target, prop, receiver)\n  },\n}\n\nfunction makeHangingParams(\n  underlyingParams: Params,\n  workStore: WorkStore,\n  prerenderStore: StaticPrerenderStoreModern\n): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  const promise = new Proxy(\n    makeHangingPromise<Params>(\n      prerenderStore.renderSignal,\n      workStore.route,\n      '`params`'\n    ),\n    fallbackParamsProxyHandler\n  )\n\n  CachedParams.set(underlyingParams, promise)\n\n  return promise\n}\n\nfunction makeErroringParams(\n  underlyingParams: Params,\n  fallbackParams: OpaqueFallbackRouteParams,\n  workStore: WorkStore,\n  prerenderStore: PrerenderStorePPR | PrerenderStoreLegacy\n): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  const augmentedUnderlying = { ...underlyingParams }\n\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = Promise.resolve(augmentedUnderlying)\n  CachedParams.set(underlyingParams, promise)\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      if (fallbackParams.has(prop)) {\n        Object.defineProperty(augmentedUnderlying, prop, {\n          get() {\n            const expression = describeStringPropertyAccess('params', prop)\n            // In most dynamic APIs we also throw if `dynamic = \"error\"` however\n            // for params is only dynamic when we're generating a fallback shell\n            // and even when `dynamic = \"error\"` we still support generating dynamic\n            // fallback shells\n            // TODO remove this comment when cacheComponents is the default since there\n            // will be no `dynamic = \"error\"`\n            if (prerenderStore.type === 'prerender-ppr') {\n              // PPR Prerender (no cacheComponents)\n              postponeWithTracking(\n                workStore.route,\n                expression,\n                prerenderStore.dynamicTracking\n              )\n            } else {\n              // Legacy Prerender\n              throwToInterruptStaticGeneration(\n                expression,\n                workStore,\n                prerenderStore\n              )\n            }\n          },\n          enumerable: true,\n        })\n      }\n    }\n  })\n\n  return promise\n}\n\nfunction makeUntrackedParams(underlyingParams: Params): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  const promise = Promise.resolve(underlyingParams)\n  CachedParams.set(underlyingParams, promise)\n\n  return promise\n}\n\nfunction makeDynamicallyTrackedParamsWithDevWarnings(\n  underlyingParams: Params,\n  hasFallbackParams: boolean,\n  workStore: WorkStore,\n  requestStore: RequestStore\n): Promise<Params> {\n  if (requestStore.asyncApiPromises && hasFallbackParams) {\n    // We wrap each instance of params in a `new Promise()`, because deduping\n    // them across requests doesn't work anyway and this let us show each\n    // await a different set of values. This is important when all awaits\n    // are in third party which would otherwise track all the way to the\n    // internal params.\n    const sharedParamsParent = requestStore.asyncApiPromises.sharedParamsParent\n    const promise: Promise<Params> = new Promise((resolve, reject) => {\n      sharedParamsParent.then(() => resolve(underlyingParams), reject)\n    })\n    // @ts-expect-error\n    promise.displayName = 'params'\n    return instrumentParamsPromiseWithDevWarnings(\n      underlyingParams,\n      promise,\n      workStore\n    )\n  }\n\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = hasFallbackParams\n    ? makeDevtoolsIOAwarePromise(\n        underlyingParams,\n        requestStore,\n        RenderStage.Runtime\n      )\n    : // We don't want to force an environment transition when this params is not part of the fallback params set\n      Promise.resolve(underlyingParams)\n\n  const proxiedPromise = instrumentParamsPromiseWithDevWarnings(\n    underlyingParams,\n    promise,\n    workStore\n  )\n  CachedParams.set(underlyingParams, proxiedPromise)\n  return proxiedPromise\n}\n\nfunction instrumentParamsPromiseWithDevWarnings(\n  underlyingParams: Params,\n  promise: Promise<Params>,\n  workStore: WorkStore\n): Promise<Params> {\n  // Track which properties we should warn for.\n  const proxiedProperties = new Set<string>()\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      proxiedProperties.add(prop)\n    }\n  })\n\n  return new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (typeof prop === 'string') {\n        if (\n          // We are accessing a property that was proxied to the promise instance\n          proxiedProperties.has(prop)\n        ) {\n          const expression = describeStringPropertyAccess('params', prop)\n          warnForSyncAccess(workStore.route, expression)\n        }\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n    set(target, prop, value, receiver) {\n      if (typeof prop === 'string') {\n        proxiedProperties.delete(prop)\n      }\n      return ReflectAdapter.set(target, prop, value, receiver)\n    },\n    ownKeys(target) {\n      const expression = '`...params` or similar expression'\n      warnForSyncAccess(workStore.route, expression)\n      return Reflect.ownKeys(target)\n    },\n  })\n}\n\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n  createParamsAccessError\n)\n\nfunction createParamsAccessError(\n  route: string | undefined,\n  expression: string\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`params\\` is a Promise and must be unwrapped with \\`await\\` or \\`React.use()\\` before accessing its properties. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n","'use client'\n\nimport type { ParsedUrlQuery } from 'querystring'\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nimport type { Params } from '../../server/request/params'\nimport { LayoutRouterContext } from '../../shared/lib/app-router-context.shared-runtime'\nimport { use } from 'react'\nimport { urlSearchParamsToParsedUrlQuery } from '../route-params'\nimport { SearchParamsContext } from '../../shared/lib/hooks-client-context.shared-runtime'\n\n/**\n * When the Page is a client component we send the params and searchParams to this client wrapper\n * where they are turned into dynamically tracked values before being passed to the actual Page component.\n *\n * additionally we may send promises representing the params and searchParams. We don't ever use these passed\n * values but it can be necessary for the sender to send a Promise that doesn't resolve in certain situations.\n * It is up to the caller to decide if the promises are needed.\n */\nexport function ClientPageRoot({\n  Component,\n  serverProvidedParams,\n}: {\n  Component: React.ComponentType<any>\n  serverProvidedParams: null | {\n    searchParams: ParsedUrlQuery\n    params: Params\n    promises: Array<Promise<any>> | null\n  }\n}) {\n  let searchParams: ParsedUrlQuery\n  let params: Params\n  if (serverProvidedParams !== null) {\n    searchParams = serverProvidedParams.searchParams\n    params = serverProvidedParams.params\n  } else {\n    // When Cache Components is enabled, the server does not pass the params as\n    // props; they are parsed on the client and passed via context.\n    const layoutRouterContext = use(LayoutRouterContext)\n    params =\n      layoutRouterContext !== null ? layoutRouterContext.parentParams : {}\n\n    // This is an intentional behavior change: when Cache Components is enabled,\n    // client segments receive the \"canonical\" search params, not the\n    // rewritten ones. Users should either call useSearchParams directly or pass\n    // the rewritten ones in from a Server Component.\n    // TODO: Log a deprecation error when this object is accessed\n    searchParams = urlSearchParamsToParsedUrlQuery(use(SearchParamsContext)!)\n  }\n\n  if (typeof window === 'undefined') {\n    const { workAsyncStorage } =\n      require('../../server/app-render/work-async-storage.external') as typeof import('../../server/app-render/work-async-storage.external')\n\n    let clientSearchParams: Promise<ParsedUrlQuery>\n    let clientParams: Promise<Params>\n    // We are going to instrument the searchParams prop with tracking for the\n    // appropriate context. We wrap differently in prerendering vs rendering\n    const store = workAsyncStorage.getStore()\n    if (!store) {\n      throw new InvariantError(\n        'Expected workStore to exist when handling searchParams in a client Page.'\n      )\n    }\n\n    const { createSearchParamsFromClient } =\n      require('../../server/request/search-params') as typeof import('../../server/request/search-params')\n    clientSearchParams = createSearchParamsFromClient(searchParams, store)\n\n    const { createParamsFromClient } =\n      require('../../server/request/params') as typeof import('../../server/request/params')\n    clientParams = createParamsFromClient(params, store)\n\n    return <Component params={clientParams} searchParams={clientSearchParams} />\n  } else {\n    const { createRenderSearchParamsFromClient } =\n      require('../request/search-params.browser') as typeof import('../request/search-params.browser')\n    const clientSearchParams = createRenderSearchParamsFromClient(searchParams)\n    const { createRenderParamsFromClient } =\n      require('../request/params.browser') as typeof import('../request/params.browser')\n    const clientParams = createRenderParamsFromClient(params)\n\n    return <Component params={clientParams} searchParams={clientSearchParams} />\n  }\n}\n","'use client'\n\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nimport type { Params } from '../../server/request/params'\nimport { LayoutRouterContext } from '../../shared/lib/app-router-context.shared-runtime'\nimport { use } from 'react'\n\n/**\n * When the Page is a client component we send the params to this client wrapper\n * where they are turned into dynamically tracked values before being passed to the actual Segment component.\n *\n * additionally we may send a promise representing params. We don't ever use this passed\n * value but it can be necessary for the sender to send a Promise that doesn't resolve in certain situations\n * such as when cacheComponents is enabled. It is up to the caller to decide if the promises are needed.\n */\nexport function ClientSegmentRoot({\n  Component,\n  slots,\n  serverProvidedParams,\n}: {\n  Component: React.ComponentType<any>\n  slots: { [key: string]: React.ReactNode }\n  serverProvidedParams: null | {\n    params: Params\n    promises: Array<Promise<any>> | null\n  }\n}) {\n  let params: Params\n  if (serverProvidedParams !== null) {\n    params = serverProvidedParams.params\n  } else {\n    // When Cache Components is enabled, the server does not pass the params\n    // as props; they are parsed on the client and passed via context.\n    const layoutRouterContext = use(LayoutRouterContext)\n    params =\n      layoutRouterContext !== null ? layoutRouterContext.parentParams : {}\n  }\n\n  if (typeof window === 'undefined') {\n    const { workAsyncStorage } =\n      require('../../server/app-render/work-async-storage.external') as typeof import('../../server/app-render/work-async-storage.external')\n\n    let clientParams: Promise<Params>\n    // We are going to instrument the searchParams prop with tracking for the\n    // appropriate context. We wrap differently in prerendering vs rendering\n    const store = workAsyncStorage.getStore()\n    if (!store) {\n      throw new InvariantError(\n        'Expected workStore to exist when handling params in a client segment such as a Layout or Template.'\n      )\n    }\n\n    const { createParamsFromClient } =\n      require('../../server/request/params') as typeof import('../../server/request/params')\n    clientParams = createParamsFromClient(params, store)\n\n    return <Component {...slots} params={clientParams} />\n  } else {\n    const { createRenderParamsFromClient } =\n      require('../request/params.browser') as typeof import('../request/params.browser')\n    const clientParams = createRenderParamsFromClient(params)\n    return <Component {...slots} params={clientParams} />\n  }\n}\n","'use client'\n\n// This is a client component that only renders during SSR,\n// but will be replaced during streaming with an icon insertion script tag.\n// We don't want it to be presented anywhere so it's only visible during streaming,\n// right after the icon meta tags so that browser can pick it up as soon as it's rendered.\n// Note: we don't just emit the script here because we only need the script if it's not in the head,\n// and we need it to be hoistable alongside the other metadata but sync scripts are not hoistable.\nexport const IconMark = () => {\n  if (typeof window !== 'undefined') {\n    return null\n  }\n  return <meta name=\"nxt-icon\" />\n}\n","'use client'\n\nimport type { ReactNode } from 'react'\nimport {\n  METADATA_BOUNDARY_NAME,\n  VIEWPORT_BOUNDARY_NAME,\n  OUTLET_BOUNDARY_NAME,\n  ROOT_LAYOUT_BOUNDARY_NAME,\n} from './boundary-constants'\n\n// We use a namespace object to allow us to recover the name of the function\n// at runtime even when production bundling/minification is used.\nconst NameSpace = {\n  [METADATA_BOUNDARY_NAME]: function ({ children }: { children: ReactNode }) {\n    return children\n  },\n  [VIEWPORT_BOUNDARY_NAME]: function ({ children }: { children: ReactNode }) {\n    return children\n  },\n  [OUTLET_BOUNDARY_NAME]: function ({ children }: { children: ReactNode }) {\n    return children\n  },\n  [ROOT_LAYOUT_BOUNDARY_NAME]: function ({\n    children,\n  }: {\n    children: ReactNode\n  }) {\n    return children\n  },\n}\n\nexport const MetadataBoundary =\n  // We use slice(0) to trick the bundler into not inlining/minifying the function\n  // so it retains the name inferred from the namespace object\n  NameSpace[METADATA_BOUNDARY_NAME.slice(0) as typeof METADATA_BOUNDARY_NAME]\n\nexport const ViewportBoundary =\n  // We use slice(0) to trick the bundler into not inlining/minifying the function\n  // so it retains the name inferred from the namespace object\n  NameSpace[VIEWPORT_BOUNDARY_NAME.slice(0) as typeof VIEWPORT_BOUNDARY_NAME]\n\nexport const OutletBoundary =\n  // We use slice(0) to trick the bundler into not inlining/minifying the function\n  // so it retains the name inferred from the namespace object\n  NameSpace[OUTLET_BOUNDARY_NAME.slice(0) as typeof OUTLET_BOUNDARY_NAME]\n\nexport const RootLayoutBoundary =\n  // We use slice(0) to trick the bundler into not inlining/minifying the function\n  // so it retains the name inferred from the namespace object\n  NameSpace[\n    ROOT_LAYOUT_BOUNDARY_NAME.slice(0) as typeof ROOT_LAYOUT_BOUNDARY_NAME\n  ]\n"],"names":["HTTPAccessErrorStatus","NOT_FOUND","FORBIDDEN","UNAUTHORIZED","ALLOWED_CODES","Set","Object","values","HTTP_ERROR_FALLBACK_ERROR_CODE","isHTTPAccessFallbackError","error","digest","prefix","httpStatus","split","has","Number","getAccessFallbackHTTPStatus","getAccessFallbackErrorTypeByStatus","status","METADATA_BOUNDARY_NAME","VIEWPORT_BOUNDARY_NAME","OUTLET_BOUNDARY_NAME","ROOT_LAYOUT_BOUNDARY_NAME","InvariantError","Error","constructor","message","options","endsWith","name","React","useContext","TemplateContext","RenderFromTemplateContext","children","workAsyncStorage","ReflectAdapter","throwToInterruptStaticGeneration","postponeWithTracking","delayUntilRuntimeStage","workUnitAsyncStorage","throwInvariantForMissingStore","describeStringPropertyAccess","wellKnownProperties","makeDevtoolsIOAwarePromise","makeHangingPromise","createDedupedByCallsiteServerErrorLoggerDev","dynamicAccessAsyncStorage","RenderStage","createParamsFromClient","underlyingParams","workStore","workUnitStore","getStore","type","createStaticPrerenderParams","process","env","NODE_ENV","devFallbackParams","createRenderParamsInDev","createRenderParamsInProd","createServerParamsForMetadata","createServerParamsForServerSegment","createServerParamsForRoute","createRuntimePrerenderParams","createPrerenderParamsForClientSegment","fallbackParams","fallbackRouteParams","key","renderSignal","route","Promise","resolve","prerenderStore","makeHangingParams","makeErroringParams","makeUntrackedParams","requestStore","hasFallbackParams","makeDynamicallyTrackedParamsWithDevWarnings","CachedParams","WeakMap","fallbackParamsProxyHandler","get","target","prop","receiver","originalMethod","args","store","abortController","abort","Proxy","apply","cachedParams","promise","set","augmentedUnderlying","keys","forEach","defineProperty","expression","dynamicTracking","enumerable","asyncApiPromises","sharedParamsParent","reject","then","displayName","instrumentParamsPromiseWithDevWarnings","Runtime","proxiedPromise","proxiedProperties","add","warnForSyncAccess","value","delete","ownKeys","Reflect","createParamsAccessError","LayoutRouterContext","use","urlSearchParamsToParsedUrlQuery","SearchParamsContext","ClientPageRoot","Component","serverProvidedParams","searchParams","params","layoutRouterContext","parentParams","window","require","clientSearchParams","clientParams","createSearchParamsFromClient","createRenderSearchParamsFromClient","createRenderParamsFromClient","ClientSegmentRoot","slots","IconMark","meta","NameSpace","MetadataBoundary","slice","ViewportBoundary","OutletBoundary","RootLayoutBoundary"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70]}