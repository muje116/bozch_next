{"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/esm/build/templates/app-page.js?page=/_not-found/page"],"sourcesContent":["const __TURBOPACK__layout__$23$0__ = () => require(\"MODULE_0\");\n\nconst __TURBOPACK__not$2d$found__$23$1__ = () => require(\"MODULE_1\");\n\nconst __TURBOPACK__forbidden__$23$2__ = () => require(\"MODULE_2\");\n\nconst __TURBOPACK__unauthorized__$23$3__ = () => require(\"MODULE_3\");\n\nconst __TURBOPACK__page__$23$4__ = () => require(\"MODULE_4\");\n\nimport { AppPageRouteModule } from \"next/dist/esm/server/route-modules/app-page/module.compiled\" with {\r\n    'turbopack-transition': 'next-ssr'\r\n};\r\nimport { RouteKind } from \"next/dist/esm/server/route-kind\" with {\r\n    'turbopack-transition': 'next-server-utility'\r\n};\r\nimport { getRevalidateReason } from \"next/dist/esm/server/instrumentation/utils\";\r\nimport { getTracer, SpanKind } from \"next/dist/esm/server/lib/trace/tracer\";\r\nimport { addRequestMeta, getRequestMeta } from \"next/dist/esm/server/request-meta\";\r\nimport { BaseServerSpan } from \"next/dist/esm/server/lib/trace/constants\";\r\nimport { interopDefault } from \"next/dist/esm/server/app-render/interop-default\";\r\nimport { stripFlightHeaders } from \"next/dist/esm/server/app-render/strip-flight-headers\";\r\nimport { NodeNextRequest, NodeNextResponse } from \"next/dist/esm/server/base-http/node\";\r\nimport { checkIsAppPPREnabled } from \"next/dist/esm/server/lib/experimental/ppr\";\r\nimport { getFallbackRouteParams, createOpaqueFallbackRouteParams } from \"next/dist/esm/server/request/fallback-params\";\r\nimport { setReferenceManifestsSingleton } from \"next/dist/esm/server/app-render/encryption-utils\";\r\nimport { isHtmlBotRequest, shouldServeStreamingMetadata } from \"next/dist/esm/server/lib/streaming-metadata\";\r\nimport { createServerModuleMap } from \"next/dist/esm/server/app-render/action-utils\";\r\nimport { normalizeAppPath } from \"next/dist/esm/shared/lib/router/utils/app-paths\";\r\nimport { getIsPossibleServerAction } from \"next/dist/esm/server/lib/server-action-request-meta\";\r\nimport { RSC_HEADER, NEXT_ROUTER_PREFETCH_HEADER, NEXT_IS_PRERENDER_HEADER, NEXT_DID_POSTPONE_HEADER, RSC_CONTENT_TYPE_HEADER } from \"next/dist/esm/client/components/app-router-headers\";\r\nimport { getBotType, isBot } from \"next/dist/esm/shared/lib/router/utils/is-bot\";\r\nimport { CachedRouteKind, IncrementalCacheKind } from \"next/dist/esm/server/response-cache\";\r\nimport { FallbackMode, parseFallbackField } from \"next/dist/esm/lib/fallback\";\r\nimport RenderResult from \"next/dist/esm/server/render-result\";\r\nimport { CACHE_ONE_YEAR, HTML_CONTENT_TYPE_HEADER, NEXT_CACHE_TAGS_HEADER } from \"next/dist/esm/lib/constants\";\r\nimport { ENCODED_TAGS } from \"next/dist/esm/server/stream-utils/encoded-tags\";\r\nimport { sendRenderResult } from \"next/dist/esm/server/send-payload\";\r\nimport { NoFallbackError } from \"next/dist/esm/shared/lib/no-fallback-error.external\";\r\n// We inject the tree and pages here so that we can use them in the route\r\n// module.\r\nconst tree = [\"\", {\n\"children\": [\"/_not-found\", {\n\"children\": [\"__PAGE__\", {\n}, {\n  metadata: {  },  \"page\": [__TURBOPACK__page__$23$4__, \"[project]/node_modules/next/dist/client/components/builtin/not-found.js\"],\n}],\n}, {\n  metadata: {  },}],\n}, {\n  metadata: {  },  \"layout\": [__TURBOPACK__layout__$23$0__, \"[project]/app/layout.tsx\"],\n  \"not-found\": [__TURBOPACK__not$2d$found__$23$1__, \"[project]/node_modules/next/dist/client/components/builtin/not-found.js\"],\n  \"forbidden\": [__TURBOPACK__forbidden__$23$2__, \"[project]/node_modules/next/dist/client/components/builtin/forbidden.js\"],\n  \"unauthorized\": [__TURBOPACK__unauthorized__$23$3__, \"[project]/node_modules/next/dist/client/components/builtin/unauthorized.js\"],\n}]\r\nimport GlobalError from \"next/dist/client/components/builtin/global-error\" with {\r\n    'turbopack-transition': 'next-server-utility'\r\n};\r\nexport { GlobalError };\r\nconst __next_app_require__ = __turbopack_context__.r.bind(__turbopack_context__)\r\nconst __next_app_load_chunk__ = __turbopack_context__.l.bind(__turbopack_context__)\r\nexport const __next_app__ = {\r\n    require: __next_app_require__,\r\n    loadChunk: __next_app_load_chunk__\r\n};\r\nimport * as entryBase from \"next/dist/esm/server/app-render/entry-base\" with {\r\n    'turbopack-transition': 'next-server-utility'\r\n};\r\nimport { RedirectStatusCode } from \"next/dist/esm/client/components/redirect-status-code\";\r\nimport { InvariantError } from \"next/dist/esm/shared/lib/invariant-error\";\r\nimport { scheduleOnNextTick } from \"next/dist/esm/lib/scheduler\";\r\nimport { isInterceptionRouteAppPath } from \"next/dist/esm/shared/lib/router/utils/interception-routes\";\r\nexport * from \"next/dist/esm/server/app-render/entry-base\" with {\r\n    'turbopack-transition': 'next-server-utility'\r\n};\r\n// Create and export the route module that will be consumed.\r\nexport const routeModule = new AppPageRouteModule({\r\n    definition: {\r\n        kind: RouteKind.APP_PAGE,\r\n        page: \"/_not-found/page\",\r\n        pathname: \"/_not-found\",\r\n        // The following aren't used in production.\r\n        bundlePath: '',\r\n        filename: '',\r\n        appPaths: []\r\n    },\r\n    userland: {\r\n        loaderTree: tree\r\n    },\r\n    distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\r\n    relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || ''\r\n});\r\nexport async function handler(req, res, ctx) {\r\n    var _this;\r\n    if (routeModule.isDev) {\r\n        addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint());\r\n    }\r\n    let srcPage = \"/_not-found/page\";\r\n    // turbopack doesn't normalize `/index` in the page name\r\n    // so we need to to process dynamic routes properly\r\n    // TODO: fix turbopack providing differing value from webpack\r\n    if (process.env.TURBOPACK) {\r\n        srcPage = srcPage.replace(/\\/index$/, '') || '/';\r\n    } else if (srcPage === '/index') {\r\n        // we always normalize /index specifically\r\n        srcPage = '/';\r\n    }\r\n    const multiZoneDraftMode = process.env.__NEXT_MULTI_ZONE_DRAFT_MODE;\r\n    const isMinimalMode = Boolean(process.env.MINIMAL_MODE || getRequestMeta(req, 'minimalMode'));\r\n    const prepareResult = await routeModule.prepare(req, res, {\r\n        srcPage,\r\n        multiZoneDraftMode\r\n    });\r\n    if (!prepareResult) {\r\n        res.statusCode = 400;\r\n        res.end('Bad Request');\r\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\r\n        return null;\r\n    }\r\n    const { buildId, query, params, pageIsDynamic, buildManifest, nextFontManifest, reactLoadableManifest, serverActionsManifest, clientReferenceManifest, subresourceIntegrityManifest, prerenderManifest, isDraftMode, resolvedPathname, revalidateOnlyGenerated, routerServerContext, nextConfig, parsedUrl, interceptionRoutePatterns } = prepareResult;\r\n    const normalizedSrcPage = normalizeAppPath(srcPage);\r\n    let { isOnDemandRevalidate } = prepareResult;\r\n    // We use the resolvedPathname instead of the parsedUrl.pathname because it\r\n    // is not rewritten as resolvedPathname is. This will ensure that the correct\r\n    // prerender info is used instead of using the original pathname as the\r\n    // source. If however PPR is enabled and cacheComponents is disabled, we\r\n    // treat the pathname as dynamic. Currently, there's a bug in the PPR\r\n    // implementation that incorrectly leaves %%drp placeholders in the output of\r\n    // parallel routes. This is addressed with cacheComponents.\r\n    const prerenderInfo = nextConfig.experimental.ppr && !nextConfig.cacheComponents && isInterceptionRouteAppPath(resolvedPathname) ? null : routeModule.match(resolvedPathname, prerenderManifest);\r\n    const isPrerendered = !!prerenderManifest.routes[resolvedPathname];\r\n    const userAgent = req.headers['user-agent'] || '';\r\n    const botType = getBotType(userAgent);\r\n    const isHtmlBot = isHtmlBotRequest(req);\r\n    /**\r\n   * If true, this indicates that the request being made is for an app\r\n   * prefetch request.\r\n   */ const isPrefetchRSCRequest = getRequestMeta(req, 'isPrefetchRSCRequest') ?? req.headers[NEXT_ROUTER_PREFETCH_HEADER] === '1' // exclude runtime prefetches, which use '2'\r\n    ;\r\n    // NOTE: Don't delete headers[RSC] yet, it still needs to be used in renderToHTML later\r\n    const isRSCRequest = getRequestMeta(req, 'isRSCRequest') ?? Boolean(req.headers[RSC_HEADER]);\r\n    const isPossibleServerAction = getIsPossibleServerAction(req);\r\n    /**\r\n   * If the route being rendered is an app page, and the ppr feature has been\r\n   * enabled, then the given route _could_ support PPR.\r\n   */ const couldSupportPPR = checkIsAppPPREnabled(nextConfig.experimental.ppr);\r\n    // When enabled, this will allow the use of the `?__nextppronly` query to\r\n    // enable debugging of the static shell.\r\n    const hasDebugStaticShellQuery = process.env.__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING === '1' && typeof query.__nextppronly !== 'undefined' && couldSupportPPR;\r\n    // When enabled, this will allow the use of the `?__nextppronly` query\r\n    // to enable debugging of the fallback shell.\r\n    const hasDebugFallbackShellQuery = hasDebugStaticShellQuery && query.__nextppronly === 'fallback';\r\n    // This page supports PPR if it is marked as being `PARTIALLY_STATIC` in the\r\n    // prerender manifest and this is an app page.\r\n    const isRoutePPREnabled = couldSupportPPR && (((_this = prerenderManifest.routes[normalizedSrcPage] ?? prerenderManifest.dynamicRoutes[normalizedSrcPage]) == null ? void 0 : _this.renderingMode) === 'PARTIALLY_STATIC' || // Ideally we'd want to check the appConfig to see if this page has PPR\r\n    // enabled or not, but that would require plumbing the appConfig through\r\n    // to the server during development. We assume that the page supports it\r\n    // but only during development.\r\n    hasDebugStaticShellQuery && (routeModule.isDev === true || (routerServerContext == null ? void 0 : routerServerContext.experimentalTestProxy) === true));\r\n    const isDebugStaticShell = hasDebugStaticShellQuery && isRoutePPREnabled;\r\n    // We should enable debugging dynamic accesses when the static shell\r\n    // debugging has been enabled and we're also in development mode.\r\n    const isDebugDynamicAccesses = isDebugStaticShell && routeModule.isDev === true;\r\n    const isDebugFallbackShell = hasDebugFallbackShellQuery && isRoutePPREnabled;\r\n    // If we're in minimal mode, then try to get the postponed information from\r\n    // the request metadata. If available, use it for resuming the postponed\r\n    // render.\r\n    const minimalPostponed = isRoutePPREnabled ? getRequestMeta(req, 'postponed') : undefined;\r\n    // If PPR is enabled, and this is a RSC request (but not a prefetch), then\r\n    // we can use this fact to only generate the flight data for the request\r\n    // because we can't cache the HTML (as it's also dynamic).\r\n    const isDynamicRSCRequest = isRoutePPREnabled && isRSCRequest && !isPrefetchRSCRequest;\r\n    // Need to read this before it's stripped by stripFlightHeaders. We don't\r\n    // need to transfer it to the request meta because it's only read\r\n    // within this function; the static segment data should have already been\r\n    // generated, so we will always either return a static response or a 404.\r\n    const segmentPrefetchHeader = getRequestMeta(req, 'segmentPrefetchRSCRequest');\r\n    // TODO: investigate existing bug with shouldServeStreamingMetadata always\r\n    // being true for a revalidate due to modifying the base-server this.renderOpts\r\n    // when fixing this to correct logic it causes hydration issue since we set\r\n    // serveStreamingMetadata to true during export\r\n    const serveStreamingMetadata = isHtmlBot && isRoutePPREnabled ? false : !userAgent ? true : shouldServeStreamingMetadata(userAgent, nextConfig.htmlLimitedBots);\r\n    const isSSG = Boolean((prerenderInfo || isPrerendered || prerenderManifest.routes[normalizedSrcPage]) && // If this is a html bot request and PPR is enabled, then we don't want\r\n    // to serve a static response.\r\n    !(isHtmlBot && isRoutePPREnabled));\r\n    // When a page supports cacheComponents, we can support RDC for Navigations\r\n    const supportsRDCForNavigations = isRoutePPREnabled && nextConfig.cacheComponents === true;\r\n    // In development, we always want to generate dynamic HTML.\r\n    const supportsDynamicResponse = // If we're in development, we always support dynamic HTML, unless it's\r\n    // a data request, in which case we only produce static HTML.\r\n    routeModule.isDev === true || // If this is not SSG or does not have static paths, then it supports\r\n    // dynamic HTML.\r\n    !isSSG || // If this request has provided postponed data, it supports dynamic\r\n    // HTML.\r\n    typeof minimalPostponed === 'string' || // If this handler supports onCacheEntryV2, then we can only support\r\n    // dynamic responses if it's a dynamic RSC request and not in minimal mode. If it\r\n    // doesn't support it we must fallback to the default behavior.\r\n    (supportsRDCForNavigations && getRequestMeta(req, 'onCacheEntryV2') ? // which will generate the RDC for the route. When resuming a Dynamic\r\n    // RSC request, we'll pass the minimal postponed data to the render\r\n    // which will trigger the `supportsDynamicResponse` to be true.\r\n    isDynamicRSCRequest && !isMinimalMode : isDynamicRSCRequest);\r\n    // When html bots request PPR page, perform the full dynamic rendering.\r\n    const shouldWaitOnAllReady = isHtmlBot && isRoutePPREnabled;\r\n    let ssgCacheKey = null;\r\n    if (!isDraftMode && isSSG && !supportsDynamicResponse && !isPossibleServerAction && !minimalPostponed && !isDynamicRSCRequest) {\r\n        ssgCacheKey = resolvedPathname;\r\n    }\r\n    // the staticPathKey differs from ssgCacheKey since\r\n    // ssgCacheKey is null in dev since we're always in \"dynamic\"\r\n    // mode in dev to bypass the cache, but we still need to honor\r\n    // dynamicParams = false in dev mode\r\n    let staticPathKey = ssgCacheKey;\r\n    if (!staticPathKey && routeModule.isDev) {\r\n        staticPathKey = resolvedPathname;\r\n    }\r\n    // If this is a request for an app path that should be statically generated\r\n    // and we aren't in the edge runtime, strip the flight headers so it will\r\n    // generate the static response.\r\n    if (!routeModule.isDev && !isDraftMode && isSSG && isRSCRequest && !isDynamicRSCRequest) {\r\n        stripFlightHeaders(req.headers);\r\n    }\r\n    const ComponentMod = {\r\n        ...entryBase,\r\n        tree,\r\n        GlobalError,\r\n        handler,\r\n        routeModule,\r\n        __next_app__\r\n    };\r\n    // Before rendering (which initializes component tree modules), we have to\r\n    // set the reference manifests to our global store so Server Action's\r\n    // encryption util can access to them at the top level of the page module.\r\n    if (serverActionsManifest && clientReferenceManifest) {\r\n        setReferenceManifestsSingleton({\r\n            page: srcPage,\r\n            clientReferenceManifest,\r\n            serverActionsManifest,\r\n            serverModuleMap: createServerModuleMap({\r\n                serverActionsManifest\r\n            })\r\n        });\r\n    }\r\n    const method = req.method || 'GET';\r\n    const tracer = getTracer();\r\n    const activeSpan = tracer.getActiveScopeSpan();\r\n    const render404 = async ()=>{\r\n        // TODO: should route-module itself handle rendering the 404\r\n        if (routerServerContext == null ? void 0 : routerServerContext.render404) {\r\n            await routerServerContext.render404(req, res, parsedUrl, false);\r\n        } else {\r\n            res.end('This page could not be found');\r\n        }\r\n        return null;\r\n    };\r\n    try {\r\n        const varyHeader = routeModule.getVaryHeader(resolvedPathname, interceptionRoutePatterns);\r\n        res.setHeader('Vary', varyHeader);\r\n        const invokeRouteModule = async (span, context)=>{\r\n            const nextReq = new NodeNextRequest(req);\r\n            const nextRes = new NodeNextResponse(res);\r\n            return routeModule.render(nextReq, nextRes, context).finally(()=>{\r\n                if (!span) return;\r\n                span.setAttributes({\r\n                    'http.status_code': res.statusCode,\r\n                    'next.rsc': false\r\n                });\r\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\r\n                // We were unable to get attributes, probably OTEL is not enabled\r\n                if (!rootSpanAttributes) {\r\n                    return;\r\n                }\r\n                if (rootSpanAttributes.get('next.span_type') !== BaseServerSpan.handleRequest) {\r\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\r\n                    return;\r\n                }\r\n                const route = rootSpanAttributes.get('next.route');\r\n                if (route) {\r\n                    const name = `${method} ${route}`;\r\n                    span.setAttributes({\r\n                        'next.route': route,\r\n                        'http.route': route,\r\n                        'next.span_name': name\r\n                    });\r\n                    span.updateName(name);\r\n                } else {\r\n                    span.updateName(`${method} ${srcPage}`);\r\n                }\r\n            });\r\n        };\r\n        const incrementalCache = getRequestMeta(req, 'incrementalCache');\r\n        const doRender = async ({ span, postponed, fallbackRouteParams, forceStaticRender })=>{\r\n            const context = {\r\n                query,\r\n                params,\r\n                page: normalizedSrcPage,\r\n                sharedContext: {\r\n                    buildId\r\n                },\r\n                serverComponentsHmrCache: getRequestMeta(req, 'serverComponentsHmrCache'),\r\n                fallbackRouteParams,\r\n                renderOpts: {\r\n                    App: ()=>null,\r\n                    Document: ()=>null,\r\n                    pageConfig: {},\r\n                    ComponentMod,\r\n                    Component: interopDefault(ComponentMod),\r\n                    params,\r\n                    routeModule,\r\n                    page: srcPage,\r\n                    postponed,\r\n                    shouldWaitOnAllReady,\r\n                    serveStreamingMetadata,\r\n                    supportsDynamicResponse: typeof postponed === 'string' || supportsDynamicResponse,\r\n                    buildManifest,\r\n                    nextFontManifest,\r\n                    reactLoadableManifest,\r\n                    subresourceIntegrityManifest,\r\n                    serverActionsManifest,\r\n                    clientReferenceManifest,\r\n                    setCacheStatus: routerServerContext == null ? void 0 : routerServerContext.setCacheStatus,\r\n                    setIsrStatus: routerServerContext == null ? void 0 : routerServerContext.setIsrStatus,\r\n                    setReactDebugChannel: routerServerContext == null ? void 0 : routerServerContext.setReactDebugChannel,\r\n                    dir: process.env.NEXT_RUNTIME === 'nodejs' ? require('path').join(/* turbopackIgnore: true */ process.cwd(), routeModule.relativeProjectDir) : `${process.cwd()}/${routeModule.relativeProjectDir}`,\r\n                    isDraftMode,\r\n                    botType,\r\n                    isOnDemandRevalidate,\r\n                    isPossibleServerAction,\r\n                    assetPrefix: nextConfig.assetPrefix,\r\n                    nextConfigOutput: nextConfig.output,\r\n                    crossOrigin: nextConfig.crossOrigin,\r\n                    trailingSlash: nextConfig.trailingSlash,\r\n                    images: nextConfig.images,\r\n                    previewProps: prerenderManifest.preview,\r\n                    deploymentId: nextConfig.deploymentId,\r\n                    enableTainting: nextConfig.experimental.taint,\r\n                    htmlLimitedBots: nextConfig.htmlLimitedBots,\r\n                    reactMaxHeadersLength: nextConfig.reactMaxHeadersLength,\r\n                    multiZoneDraftMode,\r\n                    incrementalCache,\r\n                    cacheLifeProfiles: nextConfig.cacheLife,\r\n                    basePath: nextConfig.basePath,\r\n                    serverActions: nextConfig.experimental.serverActions,\r\n                    ...isDebugStaticShell || isDebugDynamicAccesses || isDebugFallbackShell ? {\r\n                        nextExport: true,\r\n                        supportsDynamicResponse: false,\r\n                        isStaticGeneration: true,\r\n                        isDebugDynamicAccesses: isDebugDynamicAccesses\r\n                    } : {},\r\n                    cacheComponents: Boolean(nextConfig.cacheComponents),\r\n                    experimental: {\r\n                        isRoutePPREnabled,\r\n                        expireTime: nextConfig.expireTime,\r\n                        staleTimes: nextConfig.experimental.staleTimes,\r\n                        clientSegmentCache: Boolean(nextConfig.experimental.clientSegmentCache),\r\n                        dynamicOnHover: Boolean(nextConfig.experimental.dynamicOnHover),\r\n                        inlineCss: Boolean(nextConfig.experimental.inlineCss),\r\n                        authInterrupts: Boolean(nextConfig.experimental.authInterrupts),\r\n                        clientTraceMetadata: nextConfig.experimental.clientTraceMetadata || [],\r\n                        clientParamParsingOrigins: nextConfig.experimental.clientParamParsingOrigins\r\n                    },\r\n                    waitUntil: ctx.waitUntil,\r\n                    onClose: (cb)=>{\r\n                        res.on('close', cb);\r\n                    },\r\n                    onAfterTaskError: ()=>{},\r\n                    onInstrumentationRequestError: (error, _request, errorContext)=>routeModule.onRequestError(req, error, errorContext, routerServerContext),\r\n                    err: getRequestMeta(req, 'invokeError'),\r\n                    dev: routeModule.isDev\r\n                }\r\n            };\r\n            if (isDebugStaticShell || isDebugDynamicAccesses) {\r\n                context.renderOpts.nextExport = true;\r\n                context.renderOpts.supportsDynamicResponse = false;\r\n                context.renderOpts.isDebugDynamicAccesses = isDebugDynamicAccesses;\r\n            }\r\n            // When we're revalidating in the background, we should not allow dynamic\r\n            // responses.\r\n            if (forceStaticRender) {\r\n                context.renderOpts.supportsDynamicResponse = false;\r\n            }\r\n            const result = await invokeRouteModule(span, context);\r\n            const { metadata } = result;\r\n            const { cacheControl, headers = {}, // Add any fetch tags that were on the page to the response headers.\r\n            fetchTags: cacheTags, fetchMetrics } = metadata;\r\n            if (cacheTags) {\r\n                headers[NEXT_CACHE_TAGS_HEADER] = cacheTags;\r\n            }\r\n            // Pull any fetch metrics from the render onto the request.\r\n            ;\r\n            req.fetchMetrics = fetchMetrics;\r\n            // we don't throw static to dynamic errors in dev as isSSG\r\n            // is a best guess in dev since we don't have the prerender pass\r\n            // to know whether the path is actually static or not\r\n            if (isSSG && (cacheControl == null ? void 0 : cacheControl.revalidate) === 0 && !routeModule.isDev && !isRoutePPREnabled) {\r\n                const staticBailoutInfo = metadata.staticBailoutInfo;\r\n                const err = Object.defineProperty(new Error(`Page changed from static to dynamic at runtime ${resolvedPathname}${(staticBailoutInfo == null ? void 0 : staticBailoutInfo.description) ? `, reason: ${staticBailoutInfo.description}` : ``}` + `\\nsee more here https://nextjs.org/docs/messages/app-static-to-dynamic-error`), \"__NEXT_ERROR_CODE\", {\r\n                    value: \"E132\",\r\n                    enumerable: false,\r\n                    configurable: true\r\n                });\r\n                if (staticBailoutInfo == null ? void 0 : staticBailoutInfo.stack) {\r\n                    const stack = staticBailoutInfo.stack;\r\n                    err.stack = err.message + stack.substring(stack.indexOf('\\n'));\r\n                }\r\n                throw err;\r\n            }\r\n            return {\r\n                value: {\r\n                    kind: CachedRouteKind.APP_PAGE,\r\n                    html: result,\r\n                    headers,\r\n                    rscData: metadata.flightData,\r\n                    postponed: metadata.postponed,\r\n                    status: metadata.statusCode,\r\n                    segmentData: metadata.segmentData\r\n                },\r\n                cacheControl\r\n            };\r\n        };\r\n        const responseGenerator = async ({ hasResolved, previousCacheEntry: previousIncrementalCacheEntry, isRevalidating, span, forceStaticRender = false })=>{\r\n            const isProduction = routeModule.isDev === false;\r\n            const didRespond = hasResolved || res.writableEnded;\r\n            // skip on-demand revalidate if cache is not present and\r\n            // revalidate-if-generated is set\r\n            if (isOnDemandRevalidate && revalidateOnlyGenerated && !previousIncrementalCacheEntry && !isMinimalMode) {\r\n                if (routerServerContext == null ? void 0 : routerServerContext.render404) {\r\n                    await routerServerContext.render404(req, res);\r\n                } else {\r\n                    res.statusCode = 404;\r\n                    res.end('This page could not be found');\r\n                }\r\n                return null;\r\n            }\r\n            let fallbackMode;\r\n            if (prerenderInfo) {\r\n                fallbackMode = parseFallbackField(prerenderInfo.fallback);\r\n            }\r\n            // When serving a HTML bot request, we want to serve a blocking render and\r\n            // not the prerendered page. This ensures that the correct content is served\r\n            // to the bot in the head.\r\n            if (fallbackMode === FallbackMode.PRERENDER && isBot(userAgent)) {\r\n                if (!isRoutePPREnabled || isHtmlBot) {\r\n                    fallbackMode = FallbackMode.BLOCKING_STATIC_RENDER;\r\n                }\r\n            }\r\n            if ((previousIncrementalCacheEntry == null ? void 0 : previousIncrementalCacheEntry.isStale) === -1) {\r\n                isOnDemandRevalidate = true;\r\n            }\r\n            // TODO: adapt for PPR\r\n            // only allow on-demand revalidate for fallback: true/blocking\r\n            // or for prerendered fallback: false paths\r\n            if (isOnDemandRevalidate && (fallbackMode !== FallbackMode.NOT_FOUND || previousIncrementalCacheEntry)) {\r\n                fallbackMode = FallbackMode.BLOCKING_STATIC_RENDER;\r\n            }\r\n            if (!isMinimalMode && fallbackMode !== FallbackMode.BLOCKING_STATIC_RENDER && staticPathKey && !didRespond && !isDraftMode && pageIsDynamic && (isProduction || !isPrerendered)) {\r\n                // if the page has dynamicParams: false and this pathname wasn't\r\n                // prerendered trigger the no fallback handling\r\n                if (// In development, fall through to render to handle missing\r\n                // getStaticPaths.\r\n                (isProduction || prerenderInfo) && // When fallback isn't present, abort this render so we 404\r\n                fallbackMode === FallbackMode.NOT_FOUND) {\r\n                    if (nextConfig.experimental.adapterPath) {\r\n                        return await render404();\r\n                    }\r\n                    throw new NoFallbackError();\r\n                }\r\n                // When cacheComponents is enabled, we can use the fallback\r\n                // response if the request is not a dynamic RSC request because the\r\n                // RSC data when this feature flag is enabled does not contain any\r\n                // param references. Without this feature flag enabled, the RSC data\r\n                // contains param references, and therefore we can't use the fallback.\r\n                if (isRoutePPREnabled && (nextConfig.cacheComponents ? !isDynamicRSCRequest : !isRSCRequest)) {\r\n                    const cacheKey = isProduction && typeof (prerenderInfo == null ? void 0 : prerenderInfo.fallback) === 'string' ? prerenderInfo.fallback : normalizedSrcPage;\r\n                    const fallbackRouteParams = // If we're in production and we have fallback route params, then we\r\n                    // can use the manifest fallback route params.\r\n                    isProduction && (prerenderInfo == null ? void 0 : prerenderInfo.fallbackRouteParams) ? createOpaqueFallbackRouteParams(prerenderInfo.fallbackRouteParams) : // have to manually generate the fallback route params.\r\n                    isDebugFallbackShell ? getFallbackRouteParams(normalizedSrcPage, routeModule) : null;\r\n                    // We use the response cache here to handle the revalidation and\r\n                    // management of the fallback shell.\r\n                    const fallbackResponse = await routeModule.handleResponse({\r\n                        cacheKey,\r\n                        req,\r\n                        nextConfig,\r\n                        routeKind: RouteKind.APP_PAGE,\r\n                        isFallback: true,\r\n                        prerenderManifest,\r\n                        isRoutePPREnabled,\r\n                        responseGenerator: async ()=>doRender({\r\n                                span,\r\n                                // We pass `undefined` as rendering a fallback isn't resumed\r\n                                // here.\r\n                                postponed: undefined,\r\n                                fallbackRouteParams,\r\n                                forceStaticRender: false\r\n                            }),\r\n                        waitUntil: ctx.waitUntil,\r\n                        isMinimalMode\r\n                    });\r\n                    // If the fallback response was set to null, then we should return null.\r\n                    if (fallbackResponse === null) return null;\r\n                    // Otherwise, if we did get a fallback response, we should return it.\r\n                    if (fallbackResponse) {\r\n                        // Remove the cache control from the response to prevent it from being\r\n                        // used in the surrounding cache.\r\n                        delete fallbackResponse.cacheControl;\r\n                        return fallbackResponse;\r\n                    }\r\n                }\r\n            }\r\n            // Only requests that aren't revalidating can be resumed. If we have the\r\n            // minimal postponed data, then we should resume the render with it.\r\n            let postponed = !isOnDemandRevalidate && !isRevalidating && minimalPostponed ? minimalPostponed : undefined;\r\n            // If this is a dynamic RSC request, we should use the postponed data from\r\n            // the static render (if available). This ensures that we can utilize the\r\n            // resume data cache (RDC) from the static render to ensure that the data\r\n            // is consistent between the static and dynamic renders.\r\n            if (// Only enable RDC for Navigations if the feature is enabled.\r\n            supportsRDCForNavigations && process.env.NEXT_RUNTIME !== 'edge' && !isMinimalMode && incrementalCache && isDynamicRSCRequest && // We don't typically trigger an on-demand revalidation for dynamic RSC\r\n            // requests, as we're typically revalidating the page in the background\r\n            // instead. However, if the cache entry is stale, we should trigger a\r\n            // background revalidation on dynamic RSC requests. This prevents us\r\n            // from entering an infinite loop of revalidations.\r\n            !forceStaticRender) {\r\n                const incrementalCacheEntry = await incrementalCache.get(resolvedPathname, {\r\n                    kind: IncrementalCacheKind.APP_PAGE,\r\n                    isRoutePPREnabled: true,\r\n                    isFallback: false\r\n                });\r\n                // If the cache entry is found, we should use the postponed data from\r\n                // the cache.\r\n                if (incrementalCacheEntry && incrementalCacheEntry.value && incrementalCacheEntry.value.kind === CachedRouteKind.APP_PAGE) {\r\n                    // CRITICAL: we're assigning the postponed data from the cache entry\r\n                    // here as we're using the RDC to resume the render.\r\n                    postponed = incrementalCacheEntry.value.postponed;\r\n                    // If the cache entry is stale, we should trigger a background\r\n                    // revalidation so that subsequent requests will get a fresh response.\r\n                    if (incrementalCacheEntry && // We want to trigger this flow if the cache entry is stale and if\r\n                    // the requested revalidation flow is either foreground or\r\n                    // background.\r\n                    (incrementalCacheEntry.isStale === -1 || incrementalCacheEntry.isStale === true)) {\r\n                        // We want to schedule this on the next tick to ensure that the\r\n                        // render is not blocked on it.\r\n                        scheduleOnNextTick(async ()=>{\r\n                            const responseCache = routeModule.getResponseCache(req);\r\n                            try {\r\n                                await responseCache.revalidate(resolvedPathname, incrementalCache, isRoutePPREnabled, false, (c)=>responseGenerator({\r\n                                        ...c,\r\n                                        // CRITICAL: we need to set this to true as we're\r\n                                        // revalidating in the background and typically this dynamic\r\n                                        // RSC request is not treated as static.\r\n                                        forceStaticRender: true\r\n                                    }), // CRITICAL: we need to pass null here because passing the\r\n                                // previous cache entry here (which is stale) will switch on\r\n                                // isOnDemandRevalidate and break the prerendering.\r\n                                null, hasResolved, ctx.waitUntil);\r\n                            } catch (err) {\r\n                                console.error('Error revalidating the page in the background', err);\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n            // When we're in minimal mode, if we're trying to debug the static shell,\r\n            // we should just return nothing instead of resuming the dynamic render.\r\n            if ((isDebugStaticShell || isDebugDynamicAccesses) && typeof postponed !== 'undefined') {\r\n                return {\r\n                    cacheControl: {\r\n                        revalidate: 1,\r\n                        expire: undefined\r\n                    },\r\n                    value: {\r\n                        kind: CachedRouteKind.PAGES,\r\n                        html: RenderResult.EMPTY,\r\n                        pageData: {},\r\n                        headers: undefined,\r\n                        status: undefined\r\n                    }\r\n                };\r\n            }\r\n            const fallbackRouteParams = // If we're in production and we have fallback route params, then we\r\n            // can use the manifest fallback route params if we need to render the\r\n            // fallback shell.\r\n            isProduction && (prerenderInfo == null ? void 0 : prerenderInfo.fallbackRouteParams) && getRequestMeta(req, 'renderFallbackShell') ? createOpaqueFallbackRouteParams(prerenderInfo.fallbackRouteParams) : // manually generate the fallback route params.\r\n            isDebugFallbackShell ? getFallbackRouteParams(normalizedSrcPage, routeModule) : null;\r\n            // Perform the render.\r\n            return doRender({\r\n                span,\r\n                postponed,\r\n                fallbackRouteParams,\r\n                forceStaticRender\r\n            });\r\n        };\r\n        const handleResponse = async (span)=>{\r\n            var _cacheEntry_value, _cachedData_headers;\r\n            const cacheEntry = await routeModule.handleResponse({\r\n                cacheKey: ssgCacheKey,\r\n                responseGenerator: (c)=>responseGenerator({\r\n                        span,\r\n                        ...c\r\n                    }),\r\n                routeKind: RouteKind.APP_PAGE,\r\n                isOnDemandRevalidate,\r\n                isRoutePPREnabled,\r\n                req,\r\n                nextConfig,\r\n                prerenderManifest,\r\n                waitUntil: ctx.waitUntil,\r\n                isMinimalMode\r\n            });\r\n            if (isDraftMode) {\r\n                res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');\r\n            }\r\n            // In dev, we should not cache pages for any reason.\r\n            if (routeModule.isDev) {\r\n                res.setHeader('Cache-Control', 'no-store, must-revalidate');\r\n            }\r\n            if (!cacheEntry) {\r\n                if (ssgCacheKey) {\r\n                    // A cache entry might not be generated if a response is written\r\n                    // in `getInitialProps` or `getServerSideProps`, but those shouldn't\r\n                    // have a cache key. If we do have a cache key but we don't end up\r\n                    // with a cache entry, then either Next.js or the application has a\r\n                    // bug that needs fixing.\r\n                    throw Object.defineProperty(new Error('invariant: cache entry required but not generated'), \"__NEXT_ERROR_CODE\", {\r\n                        value: \"E62\",\r\n                        enumerable: false,\r\n                        configurable: true\r\n                    });\r\n                }\r\n                return null;\r\n            }\r\n            if (((_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) !== CachedRouteKind.APP_PAGE) {\r\n                var _cacheEntry_value1;\r\n                throw Object.defineProperty(new Error(`Invariant app-page handler received invalid cache entry ${(_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind}`), \"__NEXT_ERROR_CODE\", {\r\n                    value: \"E707\",\r\n                    enumerable: false,\r\n                    configurable: true\r\n                });\r\n            }\r\n            const didPostpone = typeof cacheEntry.value.postponed === 'string';\r\n            if (isSSG && // We don't want to send a cache header for requests that contain dynamic\r\n            // data. If this is a Dynamic RSC request or wasn't a Prefetch RSC\r\n            // request, then we should set the cache header.\r\n            !isDynamicRSCRequest && (!didPostpone || isPrefetchRSCRequest)) {\r\n                if (!isMinimalMode) {\r\n                    // set x-nextjs-cache header to match the header\r\n                    // we set for the image-optimizer\r\n                    res.setHeader('x-nextjs-cache', isOnDemandRevalidate ? 'REVALIDATED' : cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT');\r\n                }\r\n                // Set a header used by the client router to signal the response is static\r\n                // and should respect the `static` cache staleTime value.\r\n                res.setHeader(NEXT_IS_PRERENDER_HEADER, '1');\r\n            }\r\n            const { value: cachedData } = cacheEntry;\r\n            // Coerce the cache control parameter from the render.\r\n            let cacheControl;\r\n            // If this is a resume request in minimal mode it is streamed with dynamic\r\n            // content and should not be cached.\r\n            if (minimalPostponed) {\r\n                cacheControl = {\r\n                    revalidate: 0,\r\n                    expire: undefined\r\n                };\r\n            } else if (isDynamicRSCRequest) {\r\n                cacheControl = {\r\n                    revalidate: 0,\r\n                    expire: undefined\r\n                };\r\n            } else if (!routeModule.isDev) {\r\n                // If this is a preview mode request, we shouldn't cache it\r\n                if (isDraftMode) {\r\n                    cacheControl = {\r\n                        revalidate: 0,\r\n                        expire: undefined\r\n                    };\r\n                } else if (!isSSG) {\r\n                    if (!res.getHeader('Cache-Control')) {\r\n                        cacheControl = {\r\n                            revalidate: 0,\r\n                            expire: undefined\r\n                        };\r\n                    }\r\n                } else if (cacheEntry.cacheControl) {\r\n                    // If the cache entry has a cache control with a revalidate value that's\r\n                    // a number, use it.\r\n                    if (typeof cacheEntry.cacheControl.revalidate === 'number') {\r\n                        var _cacheEntry_cacheControl;\r\n                        if (cacheEntry.cacheControl.revalidate < 1) {\r\n                            throw Object.defineProperty(new Error(`Invalid revalidate configuration provided: ${cacheEntry.cacheControl.revalidate} < 1`), \"__NEXT_ERROR_CODE\", {\r\n                                value: \"E22\",\r\n                                enumerable: false,\r\n                                configurable: true\r\n                            });\r\n                        }\r\n                        cacheControl = {\r\n                            revalidate: cacheEntry.cacheControl.revalidate,\r\n                            expire: ((_cacheEntry_cacheControl = cacheEntry.cacheControl) == null ? void 0 : _cacheEntry_cacheControl.expire) ?? nextConfig.expireTime\r\n                        };\r\n                    } else {\r\n                        cacheControl = {\r\n                            revalidate: CACHE_ONE_YEAR,\r\n                            expire: undefined\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n            cacheEntry.cacheControl = cacheControl;\r\n            if (typeof segmentPrefetchHeader === 'string' && (cachedData == null ? void 0 : cachedData.kind) === CachedRouteKind.APP_PAGE && cachedData.segmentData) {\r\n                var _cachedData_headers1;\r\n                // This is a prefetch request issued by the client Segment Cache. These\r\n                // should never reach the application layer (lambda). We should either\r\n                // respond from the cache (HIT) or respond with 204 No Content (MISS).\r\n                // Set a header to indicate that PPR is enabled for this route. This\r\n                // lets the client distinguish between a regular cache miss and a cache\r\n                // miss due to PPR being disabled. In other contexts this header is used\r\n                // to indicate that the response contains dynamic data, but here we're\r\n                // only using it to indicate that the feature is enabled â€” the segment\r\n                // response itself contains whether the data is dynamic.\r\n                res.setHeader(NEXT_DID_POSTPONE_HEADER, '2');\r\n                // Add the cache tags header to the response if it exists and we're in\r\n                // minimal mode while rendering a static page.\r\n                const tags = (_cachedData_headers1 = cachedData.headers) == null ? void 0 : _cachedData_headers1[NEXT_CACHE_TAGS_HEADER];\r\n                if (isMinimalMode && isSSG && tags && typeof tags === 'string') {\r\n                    res.setHeader(NEXT_CACHE_TAGS_HEADER, tags);\r\n                }\r\n                const matchedSegment = cachedData.segmentData.get(segmentPrefetchHeader);\r\n                if (matchedSegment !== undefined) {\r\n                    // Cache hit\r\n                    return sendRenderResult({\r\n                        req,\r\n                        res,\r\n                        generateEtags: nextConfig.generateEtags,\r\n                        poweredByHeader: nextConfig.poweredByHeader,\r\n                        result: RenderResult.fromStatic(matchedSegment, RSC_CONTENT_TYPE_HEADER),\r\n                        cacheControl: cacheEntry.cacheControl\r\n                    });\r\n                }\r\n                // Cache miss. Either a cache entry for this route has not been generated\r\n                // (which technically should not be possible when PPR is enabled, because\r\n                // at a minimum there should always be a fallback entry) or there's no\r\n                // match for the requested segment. Respond with a 204 No Content. We\r\n                // don't bother to respond with 404, because these requests are only\r\n                // issued as part of a prefetch.\r\n                res.statusCode = 204;\r\n                return sendRenderResult({\r\n                    req,\r\n                    res,\r\n                    generateEtags: nextConfig.generateEtags,\r\n                    poweredByHeader: nextConfig.poweredByHeader,\r\n                    result: RenderResult.EMPTY,\r\n                    cacheControl: cacheEntry.cacheControl\r\n                });\r\n            }\r\n            // If there's a callback for `onCacheEntry`, call it with the cache entry\r\n            // and the revalidate options. If we support RDC for Navigations, we\r\n            // prefer the `onCacheEntryV2` callback. Once RDC for Navigations is the\r\n            // default, we can remove the fallback to `onCacheEntry` as\r\n            // `onCacheEntryV2` is now fully supported.\r\n            const onCacheEntry = supportsRDCForNavigations ? getRequestMeta(req, 'onCacheEntryV2') ?? getRequestMeta(req, 'onCacheEntry') : getRequestMeta(req, 'onCacheEntry');\r\n            if (onCacheEntry) {\r\n                const finished = await onCacheEntry(cacheEntry, {\r\n                    url: getRequestMeta(req, 'initURL') ?? req.url\r\n                });\r\n                if (finished) return null;\r\n            }\r\n            if (cachedData.headers) {\r\n                const headers = {\r\n                    ...cachedData.headers\r\n                };\r\n                if (!isMinimalMode || !isSSG) {\r\n                    delete headers[NEXT_CACHE_TAGS_HEADER];\r\n                }\r\n                for (let [key, value] of Object.entries(headers)){\r\n                    if (typeof value === 'undefined') continue;\r\n                    if (Array.isArray(value)) {\r\n                        for (const v of value){\r\n                            res.appendHeader(key, v);\r\n                        }\r\n                    } else if (typeof value === 'number') {\r\n                        value = value.toString();\r\n                        res.appendHeader(key, value);\r\n                    } else {\r\n                        res.appendHeader(key, value);\r\n                    }\r\n                }\r\n            }\r\n            // Add the cache tags header to the response if it exists and we're in\r\n            // minimal mode while rendering a static page.\r\n            const tags = (_cachedData_headers = cachedData.headers) == null ? void 0 : _cachedData_headers[NEXT_CACHE_TAGS_HEADER];\r\n            if (isMinimalMode && isSSG && tags && typeof tags === 'string') {\r\n                res.setHeader(NEXT_CACHE_TAGS_HEADER, tags);\r\n            }\r\n            // If the request is a data request, then we shouldn't set the status code\r\n            // from the response because it should always be 200. This should be gated\r\n            // behind the experimental PPR flag.\r\n            if (cachedData.status && (!isRSCRequest || !isRoutePPREnabled)) {\r\n                res.statusCode = cachedData.status;\r\n            }\r\n            // Redirect information is encoded in RSC payload, so we don't need to use redirect status codes\r\n            if (!isMinimalMode && cachedData.status && RedirectStatusCode[cachedData.status] && isRSCRequest) {\r\n                res.statusCode = 200;\r\n            }\r\n            // Mark that the request did postpone.\r\n            if (didPostpone && !isDynamicRSCRequest) {\r\n                res.setHeader(NEXT_DID_POSTPONE_HEADER, '1');\r\n            }\r\n            // we don't go through this block when preview mode is true\r\n            // as preview mode is a dynamic request (bypasses cache) and doesn't\r\n            // generate both HTML and payloads in the same request so continue to just\r\n            // return the generated payload\r\n            if (isRSCRequest && !isDraftMode) {\r\n                // If this is a dynamic RSC request, then stream the response.\r\n                if (typeof cachedData.rscData === 'undefined') {\r\n                    // If the response is not an RSC response, then we can't serve it.\r\n                    if (cachedData.html.contentType !== RSC_CONTENT_TYPE_HEADER) {\r\n                        if (nextConfig.cacheComponents) {\r\n                            res.statusCode = 404;\r\n                            return sendRenderResult({\r\n                                req,\r\n                                res,\r\n                                generateEtags: nextConfig.generateEtags,\r\n                                poweredByHeader: nextConfig.poweredByHeader,\r\n                                result: RenderResult.EMPTY,\r\n                                cacheControl: cacheEntry.cacheControl\r\n                            });\r\n                        } else {\r\n                            // Otherwise this case is not expected.\r\n                            throw Object.defineProperty(new InvariantError(`Expected RSC response, got ${cachedData.html.contentType}`), \"__NEXT_ERROR_CODE\", {\r\n                                value: \"E789\",\r\n                                enumerable: false,\r\n                                configurable: true\r\n                            });\r\n                        }\r\n                    }\r\n                    return sendRenderResult({\r\n                        req,\r\n                        res,\r\n                        generateEtags: nextConfig.generateEtags,\r\n                        poweredByHeader: nextConfig.poweredByHeader,\r\n                        result: cachedData.html,\r\n                        cacheControl: cacheEntry.cacheControl\r\n                    });\r\n                }\r\n                // As this isn't a prefetch request, we should serve the static flight\r\n                // data.\r\n                return sendRenderResult({\r\n                    req,\r\n                    res,\r\n                    generateEtags: nextConfig.generateEtags,\r\n                    poweredByHeader: nextConfig.poweredByHeader,\r\n                    result: RenderResult.fromStatic(cachedData.rscData, RSC_CONTENT_TYPE_HEADER),\r\n                    cacheControl: cacheEntry.cacheControl\r\n                });\r\n            }\r\n            // This is a request for HTML data.\r\n            const body = cachedData.html;\r\n            // If there's no postponed state, we should just serve the HTML. This\r\n            // should also be the case for a resume request because it's completed\r\n            // as a server render (rather than a static render).\r\n            if (!didPostpone || isMinimalMode || isRSCRequest) {\r\n                // If we're in test mode, we should add a sentinel chunk to the response\r\n                // that's between the static and dynamic parts so we can compare the\r\n                // chunks and add assertions.\r\n                if (process.env.__NEXT_TEST_MODE && isMinimalMode && isRoutePPREnabled && body.contentType === HTML_CONTENT_TYPE_HEADER) {\r\n                    // As we're in minimal mode, the static part would have already been\r\n                    // streamed first. The only part that this streams is the dynamic part\r\n                    // so we should FIRST stream the sentinel and THEN the dynamic part.\r\n                    body.unshift(createPPRBoundarySentinel());\r\n                }\r\n                return sendRenderResult({\r\n                    req,\r\n                    res,\r\n                    generateEtags: nextConfig.generateEtags,\r\n                    poweredByHeader: nextConfig.poweredByHeader,\r\n                    result: body,\r\n                    cacheControl: cacheEntry.cacheControl\r\n                });\r\n            }\r\n            // If we're debugging the static shell or the dynamic API accesses, we\r\n            // should just serve the HTML without resuming the render. The returned\r\n            // HTML will be the static shell so all the Dynamic API's will be used\r\n            // during static generation.\r\n            if (isDebugStaticShell || isDebugDynamicAccesses) {\r\n                // Since we're not resuming the render, we need to at least add the\r\n                // closing body and html tags to create valid HTML.\r\n                body.push(new ReadableStream({\r\n                    start (controller) {\r\n                        controller.enqueue(ENCODED_TAGS.CLOSED.BODY_AND_HTML);\r\n                        controller.close();\r\n                    }\r\n                }));\r\n                return sendRenderResult({\r\n                    req,\r\n                    res,\r\n                    generateEtags: nextConfig.generateEtags,\r\n                    poweredByHeader: nextConfig.poweredByHeader,\r\n                    result: body,\r\n                    cacheControl: {\r\n                        revalidate: 0,\r\n                        expire: undefined\r\n                    }\r\n                });\r\n            }\r\n            // If we're in test mode, we should add a sentinel chunk to the response\r\n            // that's between the static and dynamic parts so we can compare the\r\n            // chunks and add assertions.\r\n            if (process.env.__NEXT_TEST_MODE) {\r\n                body.push(createPPRBoundarySentinel());\r\n            }\r\n            // This request has postponed, so let's create a new transformer that the\r\n            // dynamic data can pipe to that will attach the dynamic data to the end\r\n            // of the response.\r\n            const transformer = new TransformStream();\r\n            body.push(transformer.readable);\r\n            // Perform the render again, but this time, provide the postponed state.\r\n            // We don't await because we want the result to start streaming now, and\r\n            // we've already chained the transformer's readable to the render result.\r\n            doRender({\r\n                span,\r\n                postponed: cachedData.postponed,\r\n                // This is a resume render, not a fallback render, so we don't need to\r\n                // set this.\r\n                fallbackRouteParams: null,\r\n                forceStaticRender: false\r\n            }).then(async (result)=>{\r\n                var _result_value;\r\n                if (!result) {\r\n                    throw Object.defineProperty(new Error('Invariant: expected a result to be returned'), \"__NEXT_ERROR_CODE\", {\r\n                        value: \"E463\",\r\n                        enumerable: false,\r\n                        configurable: true\r\n                    });\r\n                }\r\n                if (((_result_value = result.value) == null ? void 0 : _result_value.kind) !== CachedRouteKind.APP_PAGE) {\r\n                    var _result_value1;\r\n                    throw Object.defineProperty(new Error(`Invariant: expected a page response, got ${(_result_value1 = result.value) == null ? void 0 : _result_value1.kind}`), \"__NEXT_ERROR_CODE\", {\r\n                        value: \"E305\",\r\n                        enumerable: false,\r\n                        configurable: true\r\n                    });\r\n                }\r\n                // Pipe the resume result to the transformer.\r\n                await result.value.html.pipeTo(transformer.writable);\r\n            }).catch((err)=>{\r\n                // An error occurred during piping or preparing the render, abort\r\n                // the transformers writer so we can terminate the stream.\r\n                transformer.writable.abort(err).catch((e)=>{\r\n                    console.error(\"couldn't abort transformer\", e);\r\n                });\r\n            });\r\n            return sendRenderResult({\r\n                req,\r\n                res,\r\n                generateEtags: nextConfig.generateEtags,\r\n                poweredByHeader: nextConfig.poweredByHeader,\r\n                result: body,\r\n                // We don't want to cache the response if it has postponed data because\r\n                // the response being sent to the client it's dynamic parts are streamed\r\n                // to the client on the same request.\r\n                cacheControl: {\r\n                    revalidate: 0,\r\n                    expire: undefined\r\n                }\r\n            });\r\n        };\r\n        // TODO: activeSpan code path is for when wrapped by\r\n        // next-server can be removed when this is no longer used\r\n        if (activeSpan) {\r\n            await handleResponse(activeSpan);\r\n        } else {\r\n            return await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(BaseServerSpan.handleRequest, {\r\n                    spanName: `${method} ${srcPage}`,\r\n                    kind: SpanKind.SERVER,\r\n                    attributes: {\r\n                        'http.method': method,\r\n                        'http.target': req.url\r\n                    }\r\n                }, handleResponse));\r\n        }\r\n    } catch (err) {\r\n        if (!(err instanceof NoFallbackError)) {\r\n            await routeModule.onRequestError(req, err, {\r\n                routerKind: 'App Router',\r\n                routePath: srcPage,\r\n                routeType: 'render',\r\n                revalidateReason: getRevalidateReason({\r\n                    isStaticGeneration: isSSG,\r\n                    isOnDemandRevalidate\r\n                })\r\n            }, routerServerContext);\r\n        }\r\n        // rethrow so that we can handle serving error page\r\n        throw err;\r\n    }\r\n}\r\n// TODO: omit this from production builds, only test builds should include it\r\n/**\r\n * Creates a readable stream that emits a PPR boundary sentinel.\r\n *\r\n * @returns A readable stream that emits a PPR boundary sentinel.\r\n */ function createPPRBoundarySentinel() {\r\n    return new ReadableStream({\r\n        start (controller) {\r\n            controller.enqueue(new TextEncoder().encode('<!-- PPR_BOUNDARY_SENTINEL -->'));\r\n            controller.close();\r\n        }\r\n    });\r\n}\r\n\r\n//# sourceMappingURL=app-page.js.map\n"],"names":[],"mappings":"uCAUA,IAAA,EAAA,EAAA,CAAA,CAAA,OAGA,EAAA,EAAA,CAAA,CAAA,OAGA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,MACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,CAAA,CAAA,OAAA,IAAA,EAAA,EAAA,CAAA,CAAA,KACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OAiBA,EAAA,EAAA,CAAA,CAAA,OAUA,EAAA,CAAA,CAAA,OAAA,IAAA,EAAA,EAAA,CAAA,CAAA,OAGA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OA9BA,IAAM,EAAO,CAAC,GAAI,CAClB,SAAY,CAAC,cAAe,CAC5B,SAAY,CAAC,WAAY,CACzB,EAAG,CACD,SAAU,CAAG,EAAI,KAAQ,CArCQ,IAAA,EAAA,CAAA,CAAA,OAqCqB,0EAA0E,AAClI,EAAE,AACF,EAAG,CACD,SAAU,CAAG,CAAE,EAAE,AACnB,EAAG,CACD,SAAU,CAAG,EAAI,OAAU,CAlDQ,IAAA,EAAA,CAAA,CAAA,OAkDuB,2BAA2B,CACrF,YAAa,CAjD4B,IAAA,EAAA,CAAA,CAAA,OAiDS,0EAA0E,CAC5H,UAAa,CAhDyB,IAAA,EAAA,CAAA,CAAA,OAgDS,0EAA0E,CACzH,aAAgB,CA/CyB,IAAA,EAAA,CAAA,CAAA,OA+CY,6EAA6E,AACpI,EAAE,CAOW,EAAe,CACxB,QAHyB,CAGhB,CAHsC,CAAC,CAAC,IAAI,CAAC,GAItD,UAH4B,CAGjB,CAHuC,CAAC,CAAC,IAAI,CAAC,EAI7D,EAYa,EAAc,IAAI,EAAA,kBAAkB,CAAC,CAC9C,WAAY,CACR,KAAM,EAAA,SAAS,CAAC,QAAQ,CACxB,KAAM,mBACN,SAAU,cAEV,WAAY,GACZ,SAAU,GACV,SAAU,EAAE,AAChB,EACA,SAAU,CACN,WAAY,CAChB,EACA,QAAS,CAAA,OACT,IADiD,eACc,CAA3C,CACxB,GACO,eAAe,EAAQ,CAAG,CAAE,CAAG,CAAE,CAAG,EACvC,IAAI,EACA,EAAY,KAAK,EAAE,AACnB,CAAA,EAAA,EAAA,cAAA,AAAc,EAAC,EAAK,+BAAgC,QAAQ,MAAM,CAAC,MAAM,IAE7E,IAAI,EAAU,mBAKV,EAAU,EAAQ,OAAO,CAAC,WAAY,KAAO,IAMjD,IAAM,GAAgB,CAAoC,CAAA,EAAA,EAAA,EAA5B,YAA4B,AAAc,EAAC,EAAK,eACxE,EAAgB,MAAM,EAAY,OAAO,CAAC,EAAK,EAAK,SACtD,EACA,mBAJE,CAAA,CAKN,GACA,GAAI,CAAC,EAID,OAHA,EAAI,IADY,MACF,CAAG,IACjB,EAAI,GAAG,CAAC,eACS,MAAjB,CAAwB,CAApB,IAAyB,KAAhB,EAAoB,EAAI,SAAS,CAAC,IAAI,CAAC,EAAK,QAAQ,OAAO,IACjE,KAEX,GAAM,SAAE,CAAO,CAAE,OAAK,QAAE,CAAM,eAAE,CAAa,eAAE,CAAa,kBAAE,CAAgB,uBAAE,CAAqB,uBAAE,CAAqB,yBAAE,CAAuB,8BAAE,CAA4B,mBAAE,CAAiB,aAAE,CAAW,kBAAE,CAAgB,yBAAE,EAAuB,qBAAE,EAAmB,YAAE,EAAU,WAAE,EAAS,2BAAE,EAAyB,CAAE,CAAG,EACpU,GAAoB,CAAA,EAAA,EAAA,gBAAA,AAAgB,EAAC,GACvC,sBAAE,EAAoB,CAAE,CAAG,EAQzB,GAAgB,GAAW,YAAY,CAAC,GAAG,EAAI,CAAC,GAAW,eAAe,EAAI,CAAA,EAAA,EAAA,0BAAA,AAA0B,EAAC,GAAoB,KAAO,EAAY,KAAK,CAAC,EAAkB,GACxK,GAAgB,CAAC,CAAC,EAAkB,MAAM,CAAC,EAAiB,CAC5D,GAAY,EAAI,OAAO,CAAC,aAAa,EAAI,GACzC,GAAU,CAAA,EAAA,EAAA,UAAA,AAAU,EAAC,IACrB,GAAY,CAAA,EAAA,EAAA,gBAAA,AAAgB,EAAC,GAI3B,GAAuB,CAAA,EAAA,EAAA,cAAA,AAAc,EAAC,EAAK,yBAAwE,IAAI,EAAjD,EAAI,OAAO,CAAC,EAAA,2BAA2B,CAAC,CAGhH,CAHqK,EAGtJ,CAAA,EAAA,EAAA,cAAA,AAAc,EAAC,EAAK,kBAAmB,CAAQ,EAAI,OAAO,CAAC,EAAA,UAAU,CAAC,CACrF,GAAyB,CAAA,EAAA,EAAA,yBAAA,AAAyB,EAAC,GAanD,GAToB,AASA,CATA,EAAA,EAAA,cASmB,MATnB,AAAoB,EAAC,GAAW,YAAY,CAAC,GAAG,GAS5B,CAAC,AAA+G,OAA9G,EAAQ,EAAkB,MAAM,CAAC,GAAkB,EAAI,EAAkB,aAAa,CAAC,GAAkB,AAAlB,EAA8B,KAAK,EAAI,EAAM,aAAA,AAAa,IAAM,mBAQjM,GARuN,GASvN,IAf2B,EAmB3B,GAAmB,GAAoB,CAAA,EAAA,EAAA,EALd,IACF,QAIgB,AAAc,EAAC,EAAK,MALZ,OAduC,KAc3B,AACN,AAIqB,EAI1E,AAvB6F,GAc7B,AAS1C,IAAqB,AAvByD,CAc/B,GASV,CAAC,CAjBkO,AANpL,EA4B1G,GAAwB,CAAA,EAAA,EAAA,GA5B+F,KAAK,MA4BpG,AAAc,EAAC,EAAK,KA5B+F,wBAiC3I,GAAyB,OAAa,EAAA,GAA4B,CAAR,CAAS,IAAmB,CAAA,EAAA,EAAA,GAAP,yBAAmC,AAA5B,EAA6B,GAAW,GAAW,gBAAe,EACxJ,IAAQ,EAAQ,CAAC,IAAiB,IAAiB,EAAkB,MAAM,CAAC,GAAA,AAAkB,GAEpG,CAAC,CAAC,AAFuG,IAE1F,EAAA,CAAiB,EAE1B,GAA4B,KAAoD,IAA/B,GAAW,eAAe,CAE3E,IAEgB,IAAtB,EAAY,EAAkB,GAAb,EAEjB,CAAC,IAE2B,IAL5B,CAGU,IAVsK,CAYhL,EAAwC,KAAjC,KAGN,IAA6B,CAAA,EAAA,EAAA,cAAA,AAAc,EAAC,EAAK,UAPiD,MADtC,EAW7D,EAFA,EAEuB,CAAC,AARqD,EAQrC,EAAA,CAAmB,CAErD,EARsG,CAQ/E,IAAa,GACtC,GAAc,IACd,CAAC,IAAe,IAAU,IAA4B,CAA7B,GAAwD,IAAqB,KACtG,GAAc,CAAA,EAMlB,IAPyD,AAOrD,CAPqG,EAOrF,AAPgE,EAQhF,AAd+D,CAM4D,CAQ1H,IAAiB,EAAY,KAAK,EAAE,AACrC,IAAgB,CAAA,EAKhB,AAAC,EAAY,KAAK,EAAK,EAAD,EAAgB,KAAS,IAAiB,IAChE,CAAA,EAAA,EAAA,GAD+D,SAAsB,MACrF,AAAkB,EAAC,EAAI,OAAO,EAElC,IAAM,GAAe,CACjB,GAAG,CAAS,MACZ,EACA,YAAA,EAAA,OAAW,SACX,cACA,eACA,CACJ,EAII,GAAyB,GACzB,CAAA,EAAA,EAAA,iBADkD,aAClD,AAA8B,EAAC,CAC3B,KAAM,0BACN,wBACA,EACA,gBAAiB,CAAA,EAAA,EAAA,qBAAA,AAAqB,EAAC,CACnC,uBACJ,EACJ,GAEJ,IAAM,GAAS,EAAI,MAAM,EAAI,MACvB,GAAS,CAAA,EAAA,EAAA,SAAA,AAAS,IAClB,GAAa,GAAO,kBAAkB,GACtC,GAAY,WAEa,MAAvB,GAA8B,KAAK,EAAI,GAAoB,SAAA,AAAS,EACpE,AADsE,MAChE,GAAoB,SAAS,CAAC,EAAK,EAAK,GAAW,IAEzD,EAAI,GAAG,CAAC,gCAEL,MAEX,GAAI,CACA,IAAM,EAAa,EAAY,aAAa,CAAC,EAAkB,IAC/D,EAAI,SAAS,CAAC,OAAQ,GACtB,IAAM,EAAoB,MAAO,EAAM,KACnC,IAAM,EAAU,IAAI,EAAA,eAAe,CAAC,GAC9B,EAAU,IAAI,EAAA,gBAAgB,CAAC,GACrC,OAAO,EAAY,MAAM,CAAC,EAAS,EAAS,GAAS,OAAO,CAAC,KACzD,GAAI,CAAC,EAAM,OACX,EAAK,aAAa,CAAC,CACf,mBAAoB,EAAI,UAAU,CAClC,YAAY,CAChB,GACA,IAAM,EAAqB,GAAO,qBAAqB,GAEvD,GAAI,CAAC,EACD,OAEJ,GAAI,EAAmB,GAAG,CAAC,EAHF,kBAGwB,EAAA,cAAc,CAAC,aAAa,CAAE,YAC3E,QAAQ,IAAI,CAAC,CAAC,2BAA2B,EAAE,EAAmB,GAAG,CAAC,kBAAkB,qEAAqE,CAAC,EAG9J,IAAM,EAAQ,EAAmB,GAAG,CAAC,cACrC,GAAI,EAAO,CACP,IAAM,EAAO,CAAA,EAAG,GAAO,CAAC,EAAE,EAAA,CAAO,CACjC,EAAK,aAAa,CAAC,CACf,aAAc,EACd,aAAc,EACd,iBAAkB,CACtB,GACA,EAAK,UAAU,CAAC,EACpB,MACI,CADG,CACE,UAAU,CAAC,CAAA,EAAG,GAAO,CAAC,EAAE,EAAA,CAAS,CAE9C,EACJ,EACM,EAAmB,CAAA,EAAA,EAAA,cAAA,AAAc,EAAC,EAAK,oBACvC,EAAW,MAAO,MAAE,CAAI,WAAE,CAAS,qBAAE,CAAmB,mBAAE,CAAiB,CAAE,IAC/E,IAAM,EAAU,OACZ,SACA,EACA,KAAM,GACN,cAAe,SACX,CACJ,EACA,yBAA0B,CAAA,EAAA,EAAA,cAAA,AAAc,EAAC,EAAK,4BAC9C,sBACA,WAAY,CACR,IAAK,IAAI,KACT,SAAU,IAAI,KACd,WAAY,CAAC,eACb,GACA,UAAW,CAAA,EAAA,EAAA,cAAA,AAAc,EAAC,WAC1B,cACA,EACA,KAAM,YACN,uBACA,0BACA,GACA,wBAA8C,UAArB,OAAO,GAA0B,iBAC1D,mBACA,wBACA,EACA,qDACA,EACA,0BACA,eAAuC,MAAvB,GAA8B,KAAK,EAAI,GAAoB,cAAc,CACzF,aAAqC,MAAvB,GAA8B,KAAK,EAAI,GAAoB,YAAY,CACrF,qBAA6C,MAAvB,GAA8B,KAAK,EAAI,GAAoB,oBAAoB,CACrG,IAA6C,CAAxC,OAAgD,QAAQ,IAAI,CAAC,AAA4B,QAAQ,GAAG,GAAI,EAAY,SAA9B,SAAgD,IAAI,UAC/I,UACA,GACA,wBACA,0BACA,YAAa,GAAW,WAAW,CACnC,iBAAkB,GAAW,MAAM,CACnC,YAAa,GAAW,WAAW,CACnC,cAAe,GAAW,aAAa,CACvC,OAAQ,GAAW,MAAM,CACzB,aAAc,EAAkB,OAAO,CACvC,aAAc,GAAW,YAAY,CACrC,eAAgB,GAAW,YAAY,CAAC,KAAK,CAC7C,gBAAiB,GAAW,eAAe,CAC3C,sBAAuB,GAAW,qBAAqB,CACvD,mBAtOV,CAAA,mBAuOU,EACA,kBAAmB,GAAW,SAAS,CACvC,SAAU,GAAW,QAAQ,CAC7B,cAAe,GAAW,YAAY,CAAC,aAAa,CACpD,GAAG,AAAsB,IAA0B,GAAuB,CACtE,YAAY,EACZ,yBAAyB,EACzB,oBAAoB,EACpB,uBAAwB,EAC5B,EAAI,CAAC,CAAC,CACN,gBAAiB,EAAQ,GAAW,eAAe,CACnD,aAAc,mBACV,GACA,WAAY,GAAW,UAAU,CACjC,WAAY,GAAW,YAAY,CAAC,UAAU,CAC9C,oBAAoB,CAAQ,GAAW,YAAY,CAAC,kBAAkB,CACtE,gBAAgB,CAAQ,GAAW,YAAY,CAAC,cAAc,CAC9D,WAAW,CAAQ,GAAW,YAAY,CAAC,SAAS,CACpD,gBAAgB,CAAQ,GAAW,YAAY,CAAC,cAAc,CAC9D,oBAAqB,GAAW,YAAY,CAAC,mBAAmB,EAAI,EAAE,CACtE,0BAA2B,GAAW,YAAY,CAAC,yBAAyB,AAChF,EACA,UAAW,EAAI,SAAS,CACxB,QAAS,AAAC,IACN,EAAI,EAAE,CAAC,QAAS,EACpB,EACA,iBAAkB,KAAK,EACvB,8BAA+B,CAAC,EAAO,EAAU,IAAe,EAAY,cAAc,CAAC,EAAK,EAAO,EAAc,IACrH,IAAK,CAAA,EAAA,EAAA,cAAc,AAAd,EAAe,EAAK,eACzB,IAAK,EAAY,KAAK,AAC1B,CACJ,EAC0B,KACtB,EAAQ,UAAU,CAAC,MAD2B,IACjB,EAAG,EAChC,EAAQ,UAAU,CAAC,uBAAuB,EAAG,EAC7C,EAAQ,UAAU,CAAC,sBAAsB,CAAG,IAI5C,IACA,EAAQ,UAAU,CAAC,EADA,qBACuB,EAAG,CAAA,EAEjD,IAAM,EAAS,MAAM,EAAkB,EAAM,GACvC,UAAE,CAAQ,CAAE,CAAG,EACf,cAAE,CAAY,SAAE,EAAU,CAAC,CAAC,CAClC,UAAW,CAAS,cAAE,CAAY,CAAE,CAAG,EAUvC,GATI,IACA,CAAO,CAAC,EAAA,GADG,mBACmB,CAAC,CAAG,CAAA,EAItC,EAAI,YAAY,CAAG,EAIf,IAAS,CAAC,AAAgB,QAAO,KAAK,EAAI,EAAa,UAAA,AAAU,IAAM,GAAK,CAAC,EAAY,KAAK,EAAI,CAAC,GAAmB,CACtH,IAAM,EAAoB,EAAS,iBAAiB,CAC9C,EAAM,OAAO,cAAc,CAAC,AAAI,MAAM,CAAC,+CAA+C,EAAE,EAAA,EAAmB,CAAC,AAAqB,QAAO,KAAK,EAAI,EAAkB,WAAA,AAAW,EAAI,CAAC,UAAU,EAAE,EAAkB,WAAW,CAAA,CAAE,CAAG,EAAE;AAAM,0EAA4E,CAAhF,AAAiF,EAAG,CAAjF,CAAC,kBAAqG,CAChV,MAAO,OACP,YAAY,EACZ,cAAc,CAClB,GACA,GAAyB,MAArB,EAA4B,KAAK,EAAI,EAAkB,KAAK,CAAE,CAC9D,IAAM,EAAQ,EAAkB,KAAK,CACrC,EAAI,KAAK,CAAG,EAAI,OAAO,CAAG,EAAM,SAAS,CAAC,EAAM,OAAO,CAAC,MAC5D,CACA,MAAM,CACV,CACA,MAAO,CACH,MAAO,CACH,KAAM,EAAA,eAAe,CAAC,QAAQ,CAC9B,KAAM,UACN,EACA,QAAS,EAAS,UAAU,CAC5B,UAAW,EAAS,SAAS,CAC7B,OAAQ,EAAS,UAAU,CAC3B,YAAa,EAAS,WAAW,AACrC,eACA,CACJ,CACJ,EACM,EAAoB,MAAO,aAAE,CAAW,CAAE,mBAAoB,CAA6B,gBAAE,CAAc,MAAE,CAAI,mBAAE,GAAoB,CAAK,CAAE,IAChJ,IAaI,EAbE,GAAqC,IAAtB,EAAY,KAAK,CAChC,EAAa,GAAe,EAAI,aAAa,CAGnD,GAAI,IAAwB,IAA2B,CAAC,GAAiC,CAAC,EAOtF,OAN2B,MAD0E,AACjG,GAA8B,KAAK,EAAI,GAAoB,SAAA,AAAS,EACpE,AADsE,MAChE,GAAoB,SAAS,CAAC,EAAK,IAEzC,EAAI,UAAU,CAAG,IACjB,EAAI,GAAG,CAAC,iCAEL,KAuBX,GApBI,KACA,EAAe,CAAA,EAAA,EAAA,GADA,eACA,AAAkB,EAAC,GAAc,QAAQ,GAKxD,IAAiB,EAAA,YAAY,CAAC,SAAS,EAAI,CAAA,EAAA,EAAA,KAAA,AAAK,EAAC,MAC7C,CAAC,IAAqB,CADmC,CACnC,GAAW,CACjC,EAAe,EAAA,YAAY,CAAC,sBAAA,AAAsB,EAGtD,CAAkC,MAAjC,EAAwC,KAAK,EAAI,EAA8B,OAAA,AAAO,IAAM,CAAC,GAAG,CACjG,IAAuB,CAAA,EAKvB,KAAyB,IAAiB,EAAA,YAAY,CAA9B,AAA+B,SAAS,EAAI,CAAA,CAA6B,GAAG,AACpG,EAAe,EAAA,YAAY,CAAC,sBAAA,AAAsB,EAElD,CAAC,GAAiB,IAAiB,EAAA,YAAY,CAAC,sBAAsB,EAAI,IAAiB,CAAC,GAAc,CAAC,GAAe,IAAkB,GAAgB,CAAC,EAAA,CAAa,CAAG,CAG7K,GAEA,CADA,AACC,AAL0I,GAK1H,EAAA,CAAa,EAC9B,GADmC,CAClB,EAAA,IAFC,QAEW,CAAC,SAAS,CAAE,CACrC,GAAI,GAAW,YAAY,CAAC,WAAW,CACnC,CADqC,AAFiD,MAG/E,MAAM,IAEjB,OAAM,IAAI,EAAA,eAAe,AAC7B,CAMA,GAAI,KAAsB,GAAW,aAAZ,EAA2B,CAAG,CAAC,GAAsB,CAAC,EAAA,CAAY,CAAG,CAC1F,IAAM,EAAW,GAAqF,UAArE,OAAO,AAAkB,MAAjB,GAAwB,KAAK,EAAI,GAAc,QAAA,AAAQ,EAAiB,GAAc,QAAQ,CAAG,GACpI,EAEN,IAAiB,AAAiB,SAAO,GAAzB,EAA8B,EAD9C,AACkD,GAAc,mBAAA,AAAmB,EAAI,CAAA,EAAA,EAAA,iBADzC,cACyC,AAA+B,EAAC,GAAc,mBAAmB,EACxJ,GAAuB,CAAA,EAAA,EAAA,sBAAA,AAAsB,EAAC,GAAmB,GAAe,KAG1E,EAAmB,MAAM,EAAY,cAAc,CAAC,UACtD,EACA,MACA,cACA,UAAW,EAAA,SAAS,CAAC,QAAQ,CAC7B,YAAY,oBACZ,oBACA,GACA,kBAAmB,SAAU,EAAS,CAC9B,OAGA,UAAW,2BACX,EACA,mBAAmB,CACvB,GACJ,UAAW,EAAI,SAAS,eACxB,CACJ,GAEA,GAAyB,OAArB,EAA2B,OAAO,KAEtC,GAAI,EAIA,OADA,OAAO,EAHW,AAGM,YAAY,CAC7B,CAEf,CACJ,CAGA,IAAI,EAAY,AAAC,IAAyB,IAAkB,QAAsC,EAAnB,GAK/E,GALyC,AAMzC,IAAoE,CAAC,GAAiB,GAAoB,IAK1G,CAAC,EAAmB,CAChB,IAAM,EAAwB,IANL,EAMW,EAAiB,CANwE,EAMrE,CAAC,EAAkB,CACvE,KAAM,EAAA,oBAAoB,CAAC,QAAQ,AAPe,CAQlD,mBAAmB,EACnB,OATgM,KASpL,CAChB,GAGI,GAAyB,EAAsB,KAAK,EAAI,EAAsB,KAAK,CAAC,IAAI,GAAK,EAAA,eAAe,CAAC,QAAQ,EAAE,CAGvH,EAAY,EAAsB,KAAK,CAAC,SAAS,CAG7C,IAGH,AAAkC,CAAC,MAAb,OAAO,GAA6C,IAH9C,AAGY,EAAsB,OAAO,AAAK,CAAI,EAG3E,CAAA,AAH8E,EAG9E,EAAA,kBAAA,AAAkB,EAAC,UACf,IAAM,EAAgB,EAAY,WAPqD,KAOrC,CAAC,GACnD,GAAI,CACA,MAAM,EAAc,UAAU,CAAC,EAAkB,EAAkB,IAAmB,EAAO,AAAC,GAAI,EAAkB,CAC5G,GAAG,CAAC,CAIJ,mBAAmB,CACvB,GAGJ,CAFA,IAEM,EAAa,EAAI,SAAS,CACpC,CAAE,MAAO,EAAK,CACV,QAAQ,KAAK,CAAC,kBAJ8C,8BAIG,EACnE,CACJ,GAGZ,CAGA,GAAI,AAAuB,CAAtB,GAAiD,KAAqB,IAAd,EACzD,MAAO,CAD6E,AAEhF,AAFyC,aAE3B,CACV,WAAY,EACZ,OAAQ,MACZ,EACA,MAAO,CACH,KAAM,EAAA,eAAe,CAAC,KAAK,CAC3B,KAAM,EAAA,OAAY,CAAC,KAAK,CACxB,SAAU,CAAC,EACX,aAAS,EACT,YAAQ,CACZ,CACJ,EAEJ,IAAM,EAGN,IAAkC,MAAjB,GAAwB,GAAzB,EAA8B,EAAI,AAFlD,GAEgE,mBAAA,AAAmB,GAAK,CAAA,EAAA,EAAA,cAAA,AAAc,EAAC,EAAK,sBAFtC,CAE+D,CAAA,EAAA,EAAA,+BAAA,AAA+B,EAAC,GAAc,mBAAmB,EACtM,GAAuB,CAAA,EAAA,EAAA,sBAAsB,AAAtB,EAAuB,GAAmB,GAAe,KAEhF,OAAO,EAAS,MACZ,YACA,sBACA,oBACA,CACJ,EACJ,EACM,EAAiB,MAAO,QACtB,EAAmB,EAuCf,EAsDQ,EAsBR,MArDJ,EA7DE,EAAa,MAAM,EAAY,cAAc,CAAC,CAChD,SAAU,GACV,kBAAmB,AAAC,GAAI,EAAkB,MAClC,EACA,GAAG,CAAC,AACR,GACJ,UAAW,EAAA,SAAS,CAAC,QAAQ,sBAC7B,qBACA,GACA,iBACA,qBACA,EACA,UAAW,EAAI,SAAS,eACxB,CACJ,GAQA,GAPI,GACA,EAAI,QADS,CACA,CAAC,gBAAiB,2DAG/B,EAAY,KAAK,EAAE,AACnB,EAAI,SAAS,CAAC,gBAAiB,6BAE/B,CAAC,EAAY,CACb,GAAI,GAMA,MAAM,IANO,GAMA,cAAc,CAAC,AAAI,MAAM,qDAAsD,oBAAqB,CAC7G,MAAO,MACP,YAAY,EACZ,cAAc,CAClB,GAEJ,OAAO,IACX,CACA,GAAI,CAA2C,AAA1C,OAAC,EAAoB,EAAW,KAAK,AAAL,EAAiB,KAAK,EAAI,EAAkB,IAAA,AAAI,IAAM,EAAA,eAAe,CAAC,QAAQ,CAE/G,CAFiH,KAE3G,OAAO,cAAc,CAAC,AAAI,MAAM,CAAC,wDAAwD,EAA6C,AAA3C,OAAC,EAAqB,EAAW,KAAA,AAAK,EAAY,KAAK,EAAI,EAAmB,IAAI,CAAA,CAAE,EAAG,oBAAqB,CACzM,MAAO,OACP,YAAY,EACZ,cAAc,CAClB,GAEJ,IAAM,EAAoD,UAAtC,OAAO,EAAW,KAAK,CAAC,SAAS,CACjD,IAGJ,CAAC,IAHY,CAGY,CAAC,GAAe,EAAA,CAAoB,GAAG,AACxD,AAAC,GAGD,EAAI,GAJY,MAIH,CAAC,AAHE,iBAGgB,GAAuB,cAAgB,EAAW,MAAM,CAAG,IAPb,GAOsB,EAAW,OAAO,CAAG,QAAU,OAIvI,EAAI,SAAS,CAAC,EAAA,wBAAwB,CAAE,MAE5C,GAAM,CAAE,MAAO,CAAU,CAAE,CAAG,EAK9B,GAAI,GACA,EAAe,CACX,WAAY,CAFE,CAGd,YAAQ,CACZ,OACG,GAAI,GACP,EAAe,CACX,WAAY,EACZ,EAHwB,UAGhB,CACZ,OACG,GAAI,CAAC,EAAY,KAAK,CAEzB,CAF2B,EAEvB,EACA,EAAe,CACX,QAFS,GAEG,EACZ,YAAQ,CACZ,OACG,GAAK,CAAD,GAOJ,GAAI,AAPQ,EAOG,YAAY,CAG9B,CAHgC,EAGkB,UAA9C,OAAO,EAAW,YAAY,CAAC,UAAU,CAAe,CAExD,GAAI,EAAW,YAAY,CAAC,UAAU,CAAG,EACrC,CADwC,KAClC,OAAO,cAAc,CAAC,AAAI,MAAM,CAAC,2CAA2C,EAAE,EAAW,YAAY,CAAC,UAAU,CAAC,IAAI,CAAC,EAAG,oBAAqB,CAChJ,MAAO,MACP,YAAY,EACZ,cAAc,CAClB,GAEJ,EAAe,CACX,WAAY,EAAW,YAAY,CAAC,UAAU,CAC9C,OAAQ,CAAC,AAAwD,OAAvD,EAA2B,EAAW,YAAA,AAAY,EAAY,KAAK,EAAI,EAAyB,MAAA,AAAM,GAAK,GAAW,UAAU,AAC9I,CACJ,MACI,CADG,CACY,CACX,WAAY,EAAA,cAAc,CAC1B,YAAQ,CACZ,CAER,MA5BS,AAAD,EAAK,SAAS,CAAC,kBAAkB,CACjC,EAAe,CACX,WAAY,EACZ,YAAQ,EACZ,EA2BZ,GADA,EAAW,YAAY,CAAG,EACW,UAAjC,OAAO,IAAsC,CAAe,MAAd,EAAqB,KAAK,EAAI,EAAW,IAAA,AAAI,IAAM,EAAA,eAAe,CAAC,QAAQ,EAAI,EAAW,WAAW,CAAE,CAWrJ,EAAI,SAAS,CAAC,EAAA,wBAAwB,CAAE,KAGxC,IAAM,EAAO,AAA+C,OAA9C,EAAuB,EAAW,OAAA,AAAO,EAAY,KAAK,EAAI,CAAoB,CAAC,EAAA,sBAAsB,CAAC,CACpH,GAAiB,IAAS,GAAwB,UAAU,AAA1B,OAAO,GACzC,EAAI,SAAS,CAAC,EAAA,sBAAsB,CAAE,GAE1C,IAAM,EAAiB,EAAW,WAAW,CAAC,GAAG,CAAC,WAClD,KAAuB,IAAnB,EAEO,CAAA,EAAA,EAFuB,AAEvB,gBAAA,AAAgB,EAAC,KACpB,MACA,EACA,cAAe,GAAW,aAAa,CACvC,gBAAiB,GAAW,eAAe,CAC3C,OAAQ,EAAA,OAAY,CAAC,UAAU,CAAC,EAAgB,EAAA,uBAAuB,EACvE,aAAc,EAAW,YAC7B,AADyC,IAS7C,EAAI,UAAU,CAAG,IACV,CAAA,EAAA,EAAA,gBAAA,AAAgB,EAAC,KACpB,MACA,EACA,cAAe,GAAW,aAAa,CACvC,gBAAiB,GAAW,eAAe,CAC3C,OAAQ,EAAA,OAAY,CAAC,KAAK,CAC1B,aAAc,EAAW,YAAY,AACzC,GACJ,CAMA,IAAM,EAAe,GAA4B,CAAA,EAAA,EAAA,cAAc,AAAd,EAAe,EAAK,mBAAqB,CAAA,EAAA,EAAA,cAAA,AAAc,EAAC,EAAK,gBAAkB,CAAA,EAAA,EAAA,cAAA,AAAc,EAAC,EAAK,gBACpJ,GAAI,GACiB,MAAM,EAAa,EAAY,CADlC,AAEV,IAAK,CAAA,EAAA,EAAA,cAAc,AAAd,EAAe,EAAK,YAAc,EAAI,GAAG,AAClD,GACc,OAAO,KAEzB,GAAI,EAAW,OAAO,CAAE,CACpB,IAAM,EAAU,CACZ,GAAG,EAAW,OAAO,AACzB,EAIA,IAAK,GAAI,CAAC,EAAK,EAAM,GAHjB,AAAC,GAAkB,IACnB,GAD0B,IACnB,CAAO,CAAC,CADG,CACH,sBAAsB,CAAC,CAEjB,OAAO,OAAO,CAAC,IACpC,GAAI,EADyC,GACxB,IAAV,EACX,GAAI,IAD8B,EACxB,OAAO,CAAC,GACd,IAAK,CADiB,GACX,KAAK,EACZ,EAAI,EADc,UACF,CAAC,EAAK,OAEF,UAAU,AAA3B,OAAO,IACd,EAAQ,EAAM,QAAQ,EAAA,EAGtB,EAAI,YAAY,CAAC,EAAK,EAGlC,CAGA,IAAM,EAAO,AAA8C,OAA7C,EAAsB,EAAW,OAAA,AAAO,EAAY,KAAK,EAAI,CAAmB,CAAC,EAAA,sBAAsB,CAAC,CAsBtH,GArBI,GAAiB,IAAS,GAAwB,UAAhB,AAA0B,OAAnB,GACzC,EAAI,SAAS,CAAC,EAAA,sBAAsB,CAAE,IAKtC,EAAW,MAAM,EAAK,AAAC,EAAF,EAAmB,KACxC,EAAI,KADmC,KAAkB,AAC3C,CAAG,EAAW,AADgC,MAChC,AAAM,EAGlC,CAAC,GAAiB,EAAW,MAAM,EAAI,EAAA,kBAAkB,CAAC,EAAW,MAAM,CAAC,EAAI,KAChF,EAAI,OAD0F,GAChF,CAAG,GAAA,EAGjB,GAAe,CAAC,IAChB,EAAI,SAAS,CAAC,EAAA,GADuB,qBACC,CAAE,KAMxC,IAAgB,CAAC,EAAa,CAE9B,GAAI,KAA8B,IAAvB,EAAW,OAAO,CAAkB,CAE3C,GAAI,EAAW,IAAI,CAAC,WAAW,GAAK,EAAA,uBAAuB,CACvD,CADyD,EACrD,GAAW,eAAe,CAE1B,CAF4B,MAC5B,EAAI,UAAU,CAAG,IACV,CAAA,EAAA,EAAA,gBAAA,AAAgB,EAAC,CACpB,MACA,MACA,cAAe,GAAW,aAAa,CACvC,gBAAiB,GAAW,eAAe,CAC3C,OAAQ,EAAA,OAAY,CAAC,KAAK,CAC1B,aAAc,EAAW,YAAY,AACzC,QAGA,MAAM,OAAO,cAAc,CAAC,IAAI,EAAA,cAAc,CAAC,CAAC,2BAA2B,EAAE,EAAW,IAAI,CAAC,WAAW,CAAA,CAAE,EAAG,oBAAqB,CAC9H,MAAO,OACP,YAAY,EACZ,cAAc,CAClB,GAGR,MAAO,CAAA,EAAA,EAAA,gBAAgB,AAAhB,EAAiB,KACpB,MACA,EACA,cAAe,GAAW,aAAa,CACvC,gBAAiB,GAAW,eAAe,CAC3C,OAAQ,EAAW,IAAI,CACvB,aAAc,EAAW,YAAY,AACzC,EACJ,CAGA,MAAO,CAAA,EAAA,EAAA,gBAAA,AAAgB,EAAC,KACpB,MACA,EACA,cAAe,GAAW,aAAa,CACvC,gBAAiB,GAAW,eAAe,CAC3C,OAAQ,EAAA,OAAY,CAAC,UAAU,CAAC,EAAW,OAAO,CAAE,EAAA,uBAAuB,EAC3E,aAAc,EAAW,YAAY,AACzC,EACJ,CAEA,IAAM,EAAO,EAAW,IAAI,CAI5B,GAAI,CAAC,GAAe,GAAiB,GAUjC,MAAO,CAAA,EAAA,EAVwC,AAUxC,gBAAA,AAAgB,EAAC,KACpB,MACA,EACA,cAAe,GAAW,aAAa,CACvC,gBAAiB,GAAW,eAAe,CAC3C,OAAQ,EACR,aAAc,EAAW,YAAY,AACzC,GAMJ,GAA0B,CAAtB,EASA,OANA,EAAK,IAAI,CAAC,IAAI,GAHgC,YAGjB,CACzB,MAAO,CAAU,EACb,EAAW,OAAO,CAAC,EAAA,YAAY,CAAC,MAAM,CAAC,aAAa,EACpD,EAAW,KAAK,EACpB,CACJ,IACO,CAAA,EAAA,EAAA,gBAAA,AAAgB,EAAC,KACpB,MACA,EACA,cAAe,GAAW,aAAa,CACvC,gBAAiB,GAAW,eAAe,CAC3C,OAAQ,EACR,aAAc,CACV,WAAY,EACZ,YAAQ,CACZ,CACJ,GAWJ,IAAM,EAAc,IAAI,gBAsCxB,OArCA,EAAK,IAAI,CAAC,EAAY,QAAQ,EAI9B,EAAS,MACL,EACA,UAAW,EAAW,SAAS,CAG/B,oBAAqB,KACrB,mBAAmB,CACvB,GAAG,IAAI,CAAC,MAAO,QACP,EASI,EARR,GAAI,CAAC,EACD,MADS,AACH,OAAO,cAAc,CAAC,AAAI,MAAM,+CAAgD,oBAAqB,CACvG,MAAO,OACP,WAAY,GACZ,cAAc,CAClB,GAEJ,GAAI,CAAC,AAAkC,OAAjC,EAAgB,EAAO,KAAA,AAAK,EAAY,KAAK,EAAI,EAAc,IAAA,AAAI,IAAM,EAAA,eAAe,CAAC,QAAQ,CAEnG,CAFqG,KAE/F,OAAO,cAAc,CAAK,AAAJ,MAAU,CAAC,yCAAyC,EAAE,AAAmC,OAAlC,EAAiB,EAAO,KAAA,AAAK,EAAY,KAAK,EAAI,EAAe,IAAI,CAAA,CAAE,EAAG,oBAAqB,CAC9K,MAAO,OACP,YAAY,EACZ,cAAc,CAClB,EAGJ,OAAM,EAAO,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,EAAY,QAAQ,CACvD,GAAG,KAAK,CAAC,AAAC,IAGN,EAAY,QAAQ,CAAC,KAAK,CAAC,GAAK,KAAK,CAAC,AAAC,IACnC,QAAQ,KAAK,CAAC,6BAA8B,EAChD,EACJ,GACO,CAAA,EAAA,EAAA,gBAAgB,AAAhB,EAAiB,KACpB,MACA,EACA,cAAe,GAAW,aAAa,CACvC,gBAAiB,GAAW,eAAe,CAC3C,OAAQ,EAIR,aAAc,CACV,WAAY,EACZ,YAAQ,CACZ,CACJ,EACJ,EAGA,IAAI,GAGA,OAAO,EAHK,IAGC,GAAO,qBAAqB,CAAC,EAAI,OAAO,CAAE,IAAI,GAAO,KAAK,CAAC,EAAA,cAAc,CAAC,aAAa,CAAE,CAC9F,SAAU,CAAA,EAAG,GAAO,CAAC,EAAE,EAAA,CAAS,CAChC,KAAM,EAAA,QAAQ,CAAC,MAAM,CACrB,WAAY,CACR,cAAe,GACf,cAAe,EAAI,GAAG,AAC1B,CACJ,EAAG,GATP,OAAM,EAAe,GAW7B,CAAE,MAAO,EAAK,CAaV,MAZI,AAAE,CAAD,YAAgB,EAAA,eAAe,EAChC,CADmC,KAC7B,EAAY,cAAc,CAAC,EAAK,EAAK,CACvC,WAAY,aACZ,UAAW,EACX,UAAW,SACX,iBAAkB,CAAA,EAAA,EAAA,mBAAA,AAAmB,EAAC,CAClC,mBAAoB,wBACpB,EACJ,EACJ,EAAG,IAGD,CACV,CACJ","ignoreList":[0]}